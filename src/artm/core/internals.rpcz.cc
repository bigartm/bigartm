// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "artm/core/internals.rpcz.h"
#include "artm/core/internals.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/stubs/once.h>
#include <rpcz/rpcz.hpp>
namespace {
const ::google::protobuf::ServiceDescriptor* MasterComponentService_descriptor_ = NULL;
const ::google::protobuf::ServiceDescriptor* NodeControllerService_descriptor_ = NULL;
}  // anonymouse namespace

namespace artm {
namespace core {

void rpcz_protobuf_AssignDesc_artm_2fcore_2finternals_2eproto() {
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "artm/core/internals.proto");
  GOOGLE_CHECK(file != NULL);
  MasterComponentService_descriptor_ = file->service(0);
  NodeControllerService_descriptor_ = file->service(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &rpcz_protobuf_AssignDesc_artm_2fcore_2finternals_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

}  // namespace

void rpcz_protobuf_ShutdownFile_artm_2fcore_2finternals_2eproto() {
}

void rpcz_protobuf_AddDesc_artm_2fcore_2finternals_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::artm::protobuf_AddDesc_artm_2fmessages_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031artm/core/internals.proto\022\tartm.core\032\023"
    "artm/messages.proto\"\031\n\004Mask\022\021\n\005value\030\001 \003"
    "(\010B\002\020\001\"\025\n\004Bool\022\r\n\005value\030\001 \001(\010\"\024\n\003Int\022\r\n\005"
    "value\030\001 \001(\005\"\027\n\006String\022\r\n\005value\030\001 \001(\t\"\006\n\004"
    "Void\"p\n\024DataLoaderCacheEntry\022\022\n\nmodel_na"
    "me\030\001 \001(\t\022\022\n\nbatch_uuid\030\002 \001(\t\022\017\n\007item_id\030"
    "\003 \003(\005\022\037\n\005theta\030\004 \003(\0132\020.artm.FloatArray\"\262"
    "\001\n\016ProcessorInput\022\032\n\005batch\030\001 \002(\0132\013.artm."
    "Batch\022\022\n\nbatch_uuid\030\002 \002(\t\022$\n\013stream_mask"
    "\030\004 \003(\0132\017.artm.core.Mask\022\023\n\013stream_name\030\005"
    " \003(\t\0225\n\014cached_theta\030\006 \003(\0132\037.artm.core.D"
    "ataLoaderCacheEntry\"\245\003\n\016ModelIncrement\022\022"
    "\n\nmodel_name\030\001 \002(\t\022\024\n\014topics_count\030\002 \002(\005"
    "\022\023\n\013topics_name\030\003 \003(\t\022\r\n\005token\030\004 \003(\t\022\020\n\010"
    "class_id\030\005 \003(\t\022\?\n\016operation_type\030\006 \003(\0162\'"
    ".artm.core.ModelIncrement.OperationType\022"
    ")\n\017token_increment\030\007 \003(\0132\020.artm.FloatArr"
    "ay\022\022\n\nscore_name\030\010 \003(\t\022\r\n\005score\030\t \003(\014\022\017\n"
    "\007item_id\030\n \003(\005\022\037\n\005theta\030\013 \003(\0132\020.artm.Flo"
    "atArray\022\022\n\nbatch_uuid\030\014 \003(\t\"^\n\rOperation"
    "Type\022\024\n\020CreateIfNotExist\020\000\022\022\n\016IncrementV"
    "alue\020\001\022\022\n\016OverwriteValue\020\002\022\017\n\013DeleteToke"
    "n\020\003\"\034\n\010BatchIds\022\020\n\010batch_id\030\001 \003(\t\"U\n\034Cre"
    "ateOrReconfigureModelArgs\022\022\n\nmodel_name\030"
    "\002 \001(\t\022!\n\006config\030\003 \001(\0132\021.artm.ModelConfig"
    "\"&\n\020DisposeModelArgs\022\022\n\nmodel_name\030\002 \001(\t"
    "\"g\n\"CreateOrReconfigureRegularizerArgs\022\030"
    "\n\020regularizer_name\030\002 \001(\t\022\'\n\006config\030\003 \001(\013"
    "2\027.artm.RegularizerConfig\"2\n\026DisposeRegu"
    "larizerArgs\022\030\n\020regularizer_name\030\002 \001(\t\"O\n"
    "!CreateOrReconfigureDictionaryArgs\022*\n\ndi"
    "ctionary\030\002 \001(\0132\026.artm.DictionaryConfig\"0"
    "\n\025DisposeDictionaryArgs\022\027\n\017dictionary_na"
    "me\030\002 \001(\t\":\n\020RequestScoreArgs\022\022\n\nmodel_na"
    "me\030\001 \001(\t\022\022\n\nscore_name\030\002 \001(\t2\375\001\n\026MasterC"
    "omponentService\0229\n\013UpdateModel\022\031.artm.co"
    "re.ModelIncrement\032\017.artm.core.Void\022:\n\rRe"
    "trieveModel\022\027.artm.GetTopicModelArgs\032\020.a"
    "rtm.TopicModel\0225\n\016RequestBatches\022\016.artm."
    "core.Int\032\023.artm.core.BatchIds\0225\n\rReportB"
    "atches\022\023.artm.core.BatchIds\032\017.artm.core."
    "Void2\341\013\n\025NodeControllerService\022K\n\033Create"
    "OrReconfigureInstance\022\033.artm.MasterCompo"
    "nentConfig\032\017.artm.core.Void\0223\n\017DisposeIn"
    "stance\022\017.artm.core.Void\032\017.artm.core.Void"
    "\022R\n\"CreateOrReconfigureMasterComponent\022\033"
    ".artm.MasterComponentConfig\032\017.artm.core."
    "Void\022:\n\026DisposeMasterComponent\022\017.artm.co"
    "re.Void\032\017.artm.core.Void\022T\n\030CreateOrReco"
    "nfigureModel\022\'.artm.core.CreateOrReconfi"
    "gureModelArgs\032\017.artm.core.Void\022<\n\014Dispos"
    "eModel\022\033.artm.core.DisposeModelArgs\032\017.ar"
    "tm.core.Void\022`\n\036CreateOrReconfigureRegul"
    "arizer\022-.artm.core.CreateOrReconfigureRe"
    "gularizerArgs\032\017.artm.core.Void\022H\n\022Dispos"
    "eRegularizer\022!.artm.core.DisposeRegulari"
    "zerArgs\032\017.artm.core.Void\022^\n\035CreateOrReco"
    "nfigureDictionary\022,.artm.core.CreateOrRe"
    "configureDictionaryArgs\032\017.artm.core.Void"
    "\022F\n\021DisposeDictionary\022 .artm.core.Dispos"
    "eDictionaryArgs\032\017.artm.core.Void\0227\n\023Forc"
    "ePullTopicModel\022\017.artm.core.Void\032\017.artm."
    "core.Void\022@\n\034ForcePushTopicModelIncremen"
    "t\022\017.artm.core.Void\032\017.artm.core.Void\0228\n\023O"
    "verwriteTopicModel\022\020.artm.TopicModel\032\017.a"
    "rtm.core.Void\022>\n\021RequestTopicModel\022\027.art"
    "m.GetTopicModelArgs\032\020.artm.TopicModel\022L\n"
    "\027RequestRegularizerState\022\021.artm.core.Str"
    "ing\032\036.artm.RegularizerInternalState\022A\n\022R"
    "equestThetaMatrix\022\030.artm.GetThetaMatrixA"
    "rgs\032\021.artm.ThetaMatrix\022<\n\014RequestScore\022\033"
    ".artm.core.RequestScoreArgs\032\017.artm.Score"
    "Data\022(\n\010AddBatch\022\013.artm.Batch\032\017.artm.cor"
    "e.Void\0223\n\017InvokeIteration\022\017.artm.core.Vo"
    "id\032\017.artm.core.Void\022+\n\010WaitIdle\022\017.artm.c"
    "ore.Void\032\016.artm.core.Int\022\?\n\020SynchronizeM"
    "odel\022\032.artm.SynchronizeModelArgs\032\017.artm."
    "core.Void\022=\n\017InitializeModel\022\031.artm.Init"
    "ializeModelArgs\032\017.artm.core.Void", 3152);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "artm/core/internals.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&rpcz_protobuf_ShutdownFile_artm_2fcore_2finternals_2eproto);
}

// ===================================================================

MasterComponentService::~MasterComponentService() {}

const ::google::protobuf::ServiceDescriptor* MasterComponentService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterComponentService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* MasterComponentService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterComponentService_descriptor_;
}

void MasterComponentService::UpdateModel(const ::artm::core::ModelIncrement&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method UpdateModel() not implemented.");
}

void MasterComponentService::RetrieveModel(const ::artm::GetTopicModelArgs&,
                         ::rpcz::reply< ::artm::TopicModel> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RetrieveModel() not implemented.");
}

void MasterComponentService::RequestBatches(const ::artm::core::Int&,
                         ::rpcz::reply< ::artm::core::BatchIds> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RequestBatches() not implemented.");
}

void MasterComponentService::ReportBatches(const ::artm::core::BatchIds&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ReportBatches() not implemented.");
}

void MasterComponentService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), MasterComponentService_descriptor_);
  switch(method->index()) {
    case 0:
      UpdateModel(
          *::google::protobuf::down_cast<const ::artm::core::ModelIncrement*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 1:
      RetrieveModel(
          *::google::protobuf::down_cast<const ::artm::GetTopicModelArgs*>(&request),
          ::rpcz::reply< ::artm::TopicModel>(channel));
      break;
    case 2:
      RequestBatches(
          *::google::protobuf::down_cast<const ::artm::core::Int*>(&request),
          ::rpcz::reply< ::artm::core::BatchIds>(channel));
      break;
    case 3:
      ReportBatches(
          *::google::protobuf::down_cast<const ::artm::core::BatchIds*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& MasterComponentService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::ModelIncrement::default_instance();
    case 1:
      return ::artm::GetTopicModelArgs::default_instance();
    case 2:
      return ::artm::core::Int::default_instance();
    case 3:
      return ::artm::core::BatchIds::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& MasterComponentService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::Void::default_instance();
    case 1:
      return ::artm::TopicModel::default_instance();
    case 2:
      return ::artm::core::BatchIds::default_instance();
    case 3:
      return ::artm::core::Void::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

MasterComponentService_Stub::MasterComponentService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
MasterComponentService_Stub::MasterComponentService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(MasterComponentService::descriptor()->name()),
    owns_channel_(owns_channel) {}
MasterComponentService_Stub::~MasterComponentService_Stub() {
  if (owns_channel_) delete channel_;
}

void MasterComponentService_Stub::UpdateModel(const ::artm::core::ModelIncrement& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(0),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::UpdateModel(const ::artm::core::ModelIncrement& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(0),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::RetrieveModel(const ::artm::GetTopicModelArgs& request,
                              ::artm::TopicModel* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(1),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::RetrieveModel(const ::artm::GetTopicModelArgs& request,
                              ::artm::TopicModel* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(1),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::RequestBatches(const ::artm::core::Int& request,
                              ::artm::core::BatchIds* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(2),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::RequestBatches(const ::artm::core::Int& request,
                              ::artm::core::BatchIds* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(2),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void MasterComponentService_Stub::ReportBatches(const ::artm::core::BatchIds& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(3),
                        request, response, rpc, done);
}
void MasterComponentService_Stub::ReportBatches(const ::artm::core::BatchIds& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        MasterComponentService::descriptor()->method(3),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
// ===================================================================

NodeControllerService::~NodeControllerService() {}

const ::google::protobuf::ServiceDescriptor* NodeControllerService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeControllerService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* NodeControllerService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeControllerService_descriptor_;
}

void NodeControllerService::CreateOrReconfigureInstance(const ::artm::MasterComponentConfig&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureInstance() not implemented.");
}

void NodeControllerService::DisposeInstance(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeInstance() not implemented.");
}

void NodeControllerService::CreateOrReconfigureMasterComponent(const ::artm::MasterComponentConfig&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureMasterComponent() not implemented.");
}

void NodeControllerService::DisposeMasterComponent(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeMasterComponent() not implemented.");
}

void NodeControllerService::CreateOrReconfigureModel(const ::artm::core::CreateOrReconfigureModelArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureModel() not implemented.");
}

void NodeControllerService::DisposeModel(const ::artm::core::DisposeModelArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeModel() not implemented.");
}

void NodeControllerService::CreateOrReconfigureRegularizer(const ::artm::core::CreateOrReconfigureRegularizerArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureRegularizer() not implemented.");
}

void NodeControllerService::DisposeRegularizer(const ::artm::core::DisposeRegularizerArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeRegularizer() not implemented.");
}

void NodeControllerService::CreateOrReconfigureDictionary(const ::artm::core::CreateOrReconfigureDictionaryArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method CreateOrReconfigureDictionary() not implemented.");
}

void NodeControllerService::DisposeDictionary(const ::artm::core::DisposeDictionaryArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method DisposeDictionary() not implemented.");
}

void NodeControllerService::ForcePullTopicModel(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ForcePullTopicModel() not implemented.");
}

void NodeControllerService::ForcePushTopicModelIncrement(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method ForcePushTopicModelIncrement() not implemented.");
}

void NodeControllerService::OverwriteTopicModel(const ::artm::TopicModel&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method OverwriteTopicModel() not implemented.");
}

void NodeControllerService::RequestTopicModel(const ::artm::GetTopicModelArgs&,
                         ::rpcz::reply< ::artm::TopicModel> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RequestTopicModel() not implemented.");
}

void NodeControllerService::RequestRegularizerState(const ::artm::core::String&,
                         ::rpcz::reply< ::artm::RegularizerInternalState> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RequestRegularizerState() not implemented.");
}

void NodeControllerService::RequestThetaMatrix(const ::artm::GetThetaMatrixArgs&,
                         ::rpcz::reply< ::artm::ThetaMatrix> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RequestThetaMatrix() not implemented.");
}

void NodeControllerService::RequestScore(const ::artm::core::RequestScoreArgs&,
                         ::rpcz::reply< ::artm::ScoreData> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method RequestScore() not implemented.");
}

void NodeControllerService::AddBatch(const ::artm::Batch&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method AddBatch() not implemented.");
}

void NodeControllerService::InvokeIteration(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method InvokeIteration() not implemented.");
}

void NodeControllerService::WaitIdle(const ::artm::core::Void&,
                         ::rpcz::reply< ::artm::core::Int> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method WaitIdle() not implemented.");
}

void NodeControllerService::SynchronizeModel(const ::artm::SynchronizeModelArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method SynchronizeModel() not implemented.");
}

void NodeControllerService::InitializeModel(const ::artm::InitializeModelArgs&,
                         ::rpcz::reply< ::artm::core::Void> reply) {
  reply.Error(::rpcz::application_error::METHOD_NOT_IMPLEMENTED,
              "Method InitializeModel() not implemented.");
}

void NodeControllerService::call_method(const ::google::protobuf::MethodDescriptor* method,
                             const ::google::protobuf::Message& request,
                             ::rpcz::server_channel* channel) {
  GOOGLE_DCHECK_EQ(method->service(), NodeControllerService_descriptor_);
  switch(method->index()) {
    case 0:
      CreateOrReconfigureInstance(
          *::google::protobuf::down_cast<const ::artm::MasterComponentConfig*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 1:
      DisposeInstance(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 2:
      CreateOrReconfigureMasterComponent(
          *::google::protobuf::down_cast<const ::artm::MasterComponentConfig*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 3:
      DisposeMasterComponent(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 4:
      CreateOrReconfigureModel(
          *::google::protobuf::down_cast<const ::artm::core::CreateOrReconfigureModelArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 5:
      DisposeModel(
          *::google::protobuf::down_cast<const ::artm::core::DisposeModelArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 6:
      CreateOrReconfigureRegularizer(
          *::google::protobuf::down_cast<const ::artm::core::CreateOrReconfigureRegularizerArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 7:
      DisposeRegularizer(
          *::google::protobuf::down_cast<const ::artm::core::DisposeRegularizerArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 8:
      CreateOrReconfigureDictionary(
          *::google::protobuf::down_cast<const ::artm::core::CreateOrReconfigureDictionaryArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 9:
      DisposeDictionary(
          *::google::protobuf::down_cast<const ::artm::core::DisposeDictionaryArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 10:
      ForcePullTopicModel(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 11:
      ForcePushTopicModelIncrement(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 12:
      OverwriteTopicModel(
          *::google::protobuf::down_cast<const ::artm::TopicModel*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 13:
      RequestTopicModel(
          *::google::protobuf::down_cast<const ::artm::GetTopicModelArgs*>(&request),
          ::rpcz::reply< ::artm::TopicModel>(channel));
      break;
    case 14:
      RequestRegularizerState(
          *::google::protobuf::down_cast<const ::artm::core::String*>(&request),
          ::rpcz::reply< ::artm::RegularizerInternalState>(channel));
      break;
    case 15:
      RequestThetaMatrix(
          *::google::protobuf::down_cast<const ::artm::GetThetaMatrixArgs*>(&request),
          ::rpcz::reply< ::artm::ThetaMatrix>(channel));
      break;
    case 16:
      RequestScore(
          *::google::protobuf::down_cast<const ::artm::core::RequestScoreArgs*>(&request),
          ::rpcz::reply< ::artm::ScoreData>(channel));
      break;
    case 17:
      AddBatch(
          *::google::protobuf::down_cast<const ::artm::Batch*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 18:
      InvokeIteration(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 19:
      WaitIdle(
          *::google::protobuf::down_cast<const ::artm::core::Void*>(&request),
          ::rpcz::reply< ::artm::core::Int>(channel));
      break;
    case 20:
      SynchronizeModel(
          *::google::protobuf::down_cast<const ::artm::SynchronizeModelArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    case 21:
      InitializeModel(
          *::google::protobuf::down_cast<const ::artm::InitializeModelArgs*>(&request),
          ::rpcz::reply< ::artm::core::Void>(channel));
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& NodeControllerService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::MasterComponentConfig::default_instance();
    case 1:
      return ::artm::core::Void::default_instance();
    case 2:
      return ::artm::MasterComponentConfig::default_instance();
    case 3:
      return ::artm::core::Void::default_instance();
    case 4:
      return ::artm::core::CreateOrReconfigureModelArgs::default_instance();
    case 5:
      return ::artm::core::DisposeModelArgs::default_instance();
    case 6:
      return ::artm::core::CreateOrReconfigureRegularizerArgs::default_instance();
    case 7:
      return ::artm::core::DisposeRegularizerArgs::default_instance();
    case 8:
      return ::artm::core::CreateOrReconfigureDictionaryArgs::default_instance();
    case 9:
      return ::artm::core::DisposeDictionaryArgs::default_instance();
    case 10:
      return ::artm::core::Void::default_instance();
    case 11:
      return ::artm::core::Void::default_instance();
    case 12:
      return ::artm::TopicModel::default_instance();
    case 13:
      return ::artm::GetTopicModelArgs::default_instance();
    case 14:
      return ::artm::core::String::default_instance();
    case 15:
      return ::artm::GetThetaMatrixArgs::default_instance();
    case 16:
      return ::artm::core::RequestScoreArgs::default_instance();
    case 17:
      return ::artm::Batch::default_instance();
    case 18:
      return ::artm::core::Void::default_instance();
    case 19:
      return ::artm::core::Void::default_instance();
    case 20:
      return ::artm::SynchronizeModelArgs::default_instance();
    case 21:
      return ::artm::InitializeModelArgs::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& NodeControllerService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::artm::core::Void::default_instance();
    case 1:
      return ::artm::core::Void::default_instance();
    case 2:
      return ::artm::core::Void::default_instance();
    case 3:
      return ::artm::core::Void::default_instance();
    case 4:
      return ::artm::core::Void::default_instance();
    case 5:
      return ::artm::core::Void::default_instance();
    case 6:
      return ::artm::core::Void::default_instance();
    case 7:
      return ::artm::core::Void::default_instance();
    case 8:
      return ::artm::core::Void::default_instance();
    case 9:
      return ::artm::core::Void::default_instance();
    case 10:
      return ::artm::core::Void::default_instance();
    case 11:
      return ::artm::core::Void::default_instance();
    case 12:
      return ::artm::core::Void::default_instance();
    case 13:
      return ::artm::TopicModel::default_instance();
    case 14:
      return ::artm::RegularizerInternalState::default_instance();
    case 15:
      return ::artm::ThetaMatrix::default_instance();
    case 16:
      return ::artm::ScoreData::default_instance();
    case 17:
      return ::artm::core::Void::default_instance();
    case 18:
      return ::artm::core::Void::default_instance();
    case 19:
      return ::artm::core::Int::default_instance();
    case 20:
      return ::artm::core::Void::default_instance();
    case 21:
      return ::artm::core::Void::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

NodeControllerService_Stub::NodeControllerService_Stub(::rpcz::rpc_channel* channel,
                                   const ::std::string& service_name,
                                   bool owns_channel)
  : channel_(channel), service_name_(service_name),
    owns_channel_(owns_channel) {}
NodeControllerService_Stub::NodeControllerService_Stub(::rpcz::rpc_channel* channel,
                                   bool owns_channel)
  : channel_(channel), service_name_(NodeControllerService::descriptor()->name()),
    owns_channel_(owns_channel) {}
NodeControllerService_Stub::~NodeControllerService_Stub() {
  if (owns_channel_) delete channel_;
}

void NodeControllerService_Stub::CreateOrReconfigureInstance(const ::artm::MasterComponentConfig& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(0),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureInstance(const ::artm::MasterComponentConfig& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(0),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeInstance(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(1),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeInstance(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(1),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureMasterComponent(const ::artm::MasterComponentConfig& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(2),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureMasterComponent(const ::artm::MasterComponentConfig& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(2),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeMasterComponent(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(3),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeMasterComponent(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(3),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureModel(const ::artm::core::CreateOrReconfigureModelArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(4),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureModel(const ::artm::core::CreateOrReconfigureModelArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(4),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeModel(const ::artm::core::DisposeModelArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(5),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeModel(const ::artm::core::DisposeModelArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(5),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureRegularizer(const ::artm::core::CreateOrReconfigureRegularizerArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(6),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureRegularizer(const ::artm::core::CreateOrReconfigureRegularizerArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(6),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeRegularizer(const ::artm::core::DisposeRegularizerArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(7),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeRegularizer(const ::artm::core::DisposeRegularizerArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(7),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::CreateOrReconfigureDictionary(const ::artm::core::CreateOrReconfigureDictionaryArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(8),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::CreateOrReconfigureDictionary(const ::artm::core::CreateOrReconfigureDictionaryArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(8),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::DisposeDictionary(const ::artm::core::DisposeDictionaryArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(9),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::DisposeDictionary(const ::artm::core::DisposeDictionaryArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(9),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::ForcePullTopicModel(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(10),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::ForcePullTopicModel(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(10),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::ForcePushTopicModelIncrement(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(11),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::ForcePushTopicModelIncrement(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(11),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::OverwriteTopicModel(const ::artm::TopicModel& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(12),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::OverwriteTopicModel(const ::artm::TopicModel& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(12),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::RequestTopicModel(const ::artm::GetTopicModelArgs& request,
                              ::artm::TopicModel* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(13),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::RequestTopicModel(const ::artm::GetTopicModelArgs& request,
                              ::artm::TopicModel* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(13),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::RequestRegularizerState(const ::artm::core::String& request,
                              ::artm::RegularizerInternalState* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(14),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::RequestRegularizerState(const ::artm::core::String& request,
                              ::artm::RegularizerInternalState* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(14),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::RequestThetaMatrix(const ::artm::GetThetaMatrixArgs& request,
                              ::artm::ThetaMatrix* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(15),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::RequestThetaMatrix(const ::artm::GetThetaMatrixArgs& request,
                              ::artm::ThetaMatrix* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(15),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::RequestScore(const ::artm::core::RequestScoreArgs& request,
                              ::artm::ScoreData* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(16),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::RequestScore(const ::artm::core::RequestScoreArgs& request,
                              ::artm::ScoreData* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(16),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::AddBatch(const ::artm::Batch& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(17),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::AddBatch(const ::artm::Batch& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(17),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::InvokeIteration(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(18),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::InvokeIteration(const ::artm::core::Void& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(18),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::WaitIdle(const ::artm::core::Void& request,
                              ::artm::core::Int* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(19),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::WaitIdle(const ::artm::core::Void& request,
                              ::artm::core::Int* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(19),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::SynchronizeModel(const ::artm::SynchronizeModelArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(20),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::SynchronizeModel(const ::artm::SynchronizeModelArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(20),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}
void NodeControllerService_Stub::InitializeModel(const ::artm::InitializeModelArgs& request,
                              ::artm::core::Void* response,
                              ::rpcz::rpc* rpc,
                              ::rpcz::closure* done) {
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(21),
                        request, response, rpc, done);
}
void NodeControllerService_Stub::InitializeModel(const ::artm::InitializeModelArgs& request,
                              ::artm::core::Void* response,
                              long deadline_ms) {
  ::rpcz::rpc rpc;
  rpc.set_deadline_ms(deadline_ms);
  channel_->call_method(service_name_,
                        NodeControllerService::descriptor()->method(21),
                        request, response, &rpc, NULL);
  rpc.wait();
  if (!rpc.ok()) {
    throw ::rpcz::rpc_error(rpc);
  }
}

}  // namespace core
}  // namespace artm
