// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: artm/messages.proto

#ifndef PROTOBUF_artm_2fmessages_2eproto__INCLUDED
#define PROTOBUF_artm_2fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace artm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_artm_2fmessages_2eproto();
void protobuf_AssignDesc_artm_2fmessages_2eproto();
void protobuf_ShutdownFile_artm_2fmessages_2eproto();

class DoubleArray;
class FloatArray;
class BoolArray;
class IntArray;
class StringArray;
class Item;
class Field;
class Batch;
class Stream;
class MasterComponentConfig;
class RegularizerSettings;
class ModelConfig;
class RegularizerConfig;
class SmoothSparseThetaConfig;
class SmoothSparsePhiConfig;
class DecorrelatorPhiConfig;
class MultiLanguagePhiConfig;
class LabelRegularizationPhiConfig;
class SpecifiedSparsePhiConfig;
class ImproveCoherencePhiConfig;
class RegularizerInternalState;
class MultiLanguagePhiInternalState;
class DictionaryConfig;
class DictionaryEntry;
class DictionaryCoocurenceEntries;
class ScoreConfig;
class ScoreData;
class PerplexityScoreConfig;
class PerplexityScore;
class SparsityThetaScoreConfig;
class SparsityThetaScore;
class SparsityPhiScoreConfig;
class SparsityPhiScore;
class ItemsProcessedScoreConfig;
class ItemsProcessedScore;
class TopTokensScoreConfig;
class TopTokensScore;
class ThetaSnippetScoreConfig;
class ThetaSnippetScore;
class TopicKernelScoreConfig;
class TopicKernelScore;
class TopicModel;
class TopicModel_TopicModelInternals;
class ThetaMatrix;
class CollectionParserConfig;
class SynchronizeModelArgs;
class InitializeModelArgs;
class InitializeModelArgs_Filter;
class GetTopicModelArgs;
class GetThetaMatrixArgs;
class GetScoreValueArgs;
class AddBatchArgs;
class InvokeIterationArgs;
class WaitIdleArgs;
class ExportModelArgs;
class ImportModelArgs;
class ProcessBatchesArgs;
class ProcessBatchesResult;
class MergeModelArgs;
class RegularizeModelArgs;
class NormalizeModelArgs;

enum Stream_Type {
  Stream_Type_Global = 0,
  Stream_Type_ItemIdModulus = 1
};
bool Stream_Type_IsValid(int value);
const Stream_Type Stream_Type_Type_MIN = Stream_Type_Global;
const Stream_Type Stream_Type_Type_MAX = Stream_Type_ItemIdModulus;
const int Stream_Type_Type_ARRAYSIZE = Stream_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Stream_Type_descriptor();
inline const ::std::string& Stream_Type_Name(Stream_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Stream_Type_descriptor(), value);
}
inline bool Stream_Type_Parse(
    const ::std::string& name, Stream_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Stream_Type>(
    Stream_Type_descriptor(), name, value);
}
enum RegularizerConfig_Type {
  RegularizerConfig_Type_SmoothSparseTheta = 0,
  RegularizerConfig_Type_SmoothSparsePhi = 1,
  RegularizerConfig_Type_DecorrelatorPhi = 2,
  RegularizerConfig_Type_MultiLanguagePhi = 3,
  RegularizerConfig_Type_LabelRegularizationPhi = 4,
  RegularizerConfig_Type_SpecifiedSparsePhi = 5,
  RegularizerConfig_Type_ImproveCoherencePhi = 6
};
bool RegularizerConfig_Type_IsValid(int value);
const RegularizerConfig_Type RegularizerConfig_Type_Type_MIN = RegularizerConfig_Type_SmoothSparseTheta;
const RegularizerConfig_Type RegularizerConfig_Type_Type_MAX = RegularizerConfig_Type_ImproveCoherencePhi;
const int RegularizerConfig_Type_Type_ARRAYSIZE = RegularizerConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegularizerConfig_Type_descriptor();
inline const ::std::string& RegularizerConfig_Type_Name(RegularizerConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegularizerConfig_Type_descriptor(), value);
}
inline bool RegularizerConfig_Type_Parse(
    const ::std::string& name, RegularizerConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegularizerConfig_Type>(
    RegularizerConfig_Type_descriptor(), name, value);
}
enum SpecifiedSparsePhiConfig_Mode {
  SpecifiedSparsePhiConfig_Mode_SparseTopics = 0,
  SpecifiedSparsePhiConfig_Mode_SparseTokens = 1
};
bool SpecifiedSparsePhiConfig_Mode_IsValid(int value);
const SpecifiedSparsePhiConfig_Mode SpecifiedSparsePhiConfig_Mode_Mode_MIN = SpecifiedSparsePhiConfig_Mode_SparseTopics;
const SpecifiedSparsePhiConfig_Mode SpecifiedSparsePhiConfig_Mode_Mode_MAX = SpecifiedSparsePhiConfig_Mode_SparseTokens;
const int SpecifiedSparsePhiConfig_Mode_Mode_ARRAYSIZE = SpecifiedSparsePhiConfig_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpecifiedSparsePhiConfig_Mode_descriptor();
inline const ::std::string& SpecifiedSparsePhiConfig_Mode_Name(SpecifiedSparsePhiConfig_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpecifiedSparsePhiConfig_Mode_descriptor(), value);
}
inline bool SpecifiedSparsePhiConfig_Mode_Parse(
    const ::std::string& name, SpecifiedSparsePhiConfig_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpecifiedSparsePhiConfig_Mode>(
    SpecifiedSparsePhiConfig_Mode_descriptor(), name, value);
}
enum RegularizerInternalState_Type {
  RegularizerInternalState_Type_MultiLanguagePhi = 3
};
bool RegularizerInternalState_Type_IsValid(int value);
const RegularizerInternalState_Type RegularizerInternalState_Type_Type_MIN = RegularizerInternalState_Type_MultiLanguagePhi;
const RegularizerInternalState_Type RegularizerInternalState_Type_Type_MAX = RegularizerInternalState_Type_MultiLanguagePhi;
const int RegularizerInternalState_Type_Type_ARRAYSIZE = RegularizerInternalState_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegularizerInternalState_Type_descriptor();
inline const ::std::string& RegularizerInternalState_Type_Name(RegularizerInternalState_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegularizerInternalState_Type_descriptor(), value);
}
inline bool RegularizerInternalState_Type_Parse(
    const ::std::string& name, RegularizerInternalState_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegularizerInternalState_Type>(
    RegularizerInternalState_Type_descriptor(), name, value);
}
enum ScoreConfig_Type {
  ScoreConfig_Type_Perplexity = 0,
  ScoreConfig_Type_SparsityTheta = 1,
  ScoreConfig_Type_SparsityPhi = 2,
  ScoreConfig_Type_ItemsProcessed = 3,
  ScoreConfig_Type_TopTokens = 4,
  ScoreConfig_Type_ThetaSnippet = 5,
  ScoreConfig_Type_TopicKernel = 6
};
bool ScoreConfig_Type_IsValid(int value);
const ScoreConfig_Type ScoreConfig_Type_Type_MIN = ScoreConfig_Type_Perplexity;
const ScoreConfig_Type ScoreConfig_Type_Type_MAX = ScoreConfig_Type_TopicKernel;
const int ScoreConfig_Type_Type_ARRAYSIZE = ScoreConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScoreConfig_Type_descriptor();
inline const ::std::string& ScoreConfig_Type_Name(ScoreConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScoreConfig_Type_descriptor(), value);
}
inline bool ScoreConfig_Type_Parse(
    const ::std::string& name, ScoreConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScoreConfig_Type>(
    ScoreConfig_Type_descriptor(), name, value);
}
enum ScoreData_Type {
  ScoreData_Type_Perplexity = 0,
  ScoreData_Type_SparsityTheta = 1,
  ScoreData_Type_SparsityPhi = 2,
  ScoreData_Type_ItemsProcessed = 3,
  ScoreData_Type_TopTokens = 4,
  ScoreData_Type_ThetaSnippet = 5,
  ScoreData_Type_TopicKernel = 6
};
bool ScoreData_Type_IsValid(int value);
const ScoreData_Type ScoreData_Type_Type_MIN = ScoreData_Type_Perplexity;
const ScoreData_Type ScoreData_Type_Type_MAX = ScoreData_Type_TopicKernel;
const int ScoreData_Type_Type_ARRAYSIZE = ScoreData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScoreData_Type_descriptor();
inline const ::std::string& ScoreData_Type_Name(ScoreData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScoreData_Type_descriptor(), value);
}
inline bool ScoreData_Type_Parse(
    const ::std::string& name, ScoreData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScoreData_Type>(
    ScoreData_Type_descriptor(), name, value);
}
enum PerplexityScoreConfig_Type {
  PerplexityScoreConfig_Type_UnigramDocumentModel = 0,
  PerplexityScoreConfig_Type_UnigramCollectionModel = 1
};
bool PerplexityScoreConfig_Type_IsValid(int value);
const PerplexityScoreConfig_Type PerplexityScoreConfig_Type_Type_MIN = PerplexityScoreConfig_Type_UnigramDocumentModel;
const PerplexityScoreConfig_Type PerplexityScoreConfig_Type_Type_MAX = PerplexityScoreConfig_Type_UnigramCollectionModel;
const int PerplexityScoreConfig_Type_Type_ARRAYSIZE = PerplexityScoreConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* PerplexityScoreConfig_Type_descriptor();
inline const ::std::string& PerplexityScoreConfig_Type_Name(PerplexityScoreConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    PerplexityScoreConfig_Type_descriptor(), value);
}
inline bool PerplexityScoreConfig_Type_Parse(
    const ::std::string& name, PerplexityScoreConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PerplexityScoreConfig_Type>(
    PerplexityScoreConfig_Type_descriptor(), name, value);
}
enum TopicModel_OperationType {
  TopicModel_OperationType_Initialize = 0,
  TopicModel_OperationType_Increment = 1,
  TopicModel_OperationType_Overwrite = 2,
  TopicModel_OperationType_Remove = 3,
  TopicModel_OperationType_Ignore = 4
};
bool TopicModel_OperationType_IsValid(int value);
const TopicModel_OperationType TopicModel_OperationType_OperationType_MIN = TopicModel_OperationType_Initialize;
const TopicModel_OperationType TopicModel_OperationType_OperationType_MAX = TopicModel_OperationType_Ignore;
const int TopicModel_OperationType_OperationType_ARRAYSIZE = TopicModel_OperationType_OperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TopicModel_OperationType_descriptor();
inline const ::std::string& TopicModel_OperationType_Name(TopicModel_OperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TopicModel_OperationType_descriptor(), value);
}
inline bool TopicModel_OperationType_Parse(
    const ::std::string& name, TopicModel_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TopicModel_OperationType>(
    TopicModel_OperationType_descriptor(), name, value);
}
enum CollectionParserConfig_Format {
  CollectionParserConfig_Format_BagOfWordsUci = 0,
  CollectionParserConfig_Format_MatrixMarket = 1,
  CollectionParserConfig_Format_VowpalWabbit = 2
};
bool CollectionParserConfig_Format_IsValid(int value);
const CollectionParserConfig_Format CollectionParserConfig_Format_Format_MIN = CollectionParserConfig_Format_BagOfWordsUci;
const CollectionParserConfig_Format CollectionParserConfig_Format_Format_MAX = CollectionParserConfig_Format_VowpalWabbit;
const int CollectionParserConfig_Format_Format_ARRAYSIZE = CollectionParserConfig_Format_Format_MAX + 1;

const ::google::protobuf::EnumDescriptor* CollectionParserConfig_Format_descriptor();
inline const ::std::string& CollectionParserConfig_Format_Name(CollectionParserConfig_Format value) {
  return ::google::protobuf::internal::NameOfEnum(
    CollectionParserConfig_Format_descriptor(), value);
}
inline bool CollectionParserConfig_Format_Parse(
    const ::std::string& name, CollectionParserConfig_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollectionParserConfig_Format>(
    CollectionParserConfig_Format_descriptor(), name, value);
}
enum InitializeModelArgs_SourceType {
  InitializeModelArgs_SourceType_Dictionary = 0,
  InitializeModelArgs_SourceType_Batches = 1
};
bool InitializeModelArgs_SourceType_IsValid(int value);
const InitializeModelArgs_SourceType InitializeModelArgs_SourceType_SourceType_MIN = InitializeModelArgs_SourceType_Dictionary;
const InitializeModelArgs_SourceType InitializeModelArgs_SourceType_SourceType_MAX = InitializeModelArgs_SourceType_Batches;
const int InitializeModelArgs_SourceType_SourceType_ARRAYSIZE = InitializeModelArgs_SourceType_SourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InitializeModelArgs_SourceType_descriptor();
inline const ::std::string& InitializeModelArgs_SourceType_Name(InitializeModelArgs_SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InitializeModelArgs_SourceType_descriptor(), value);
}
inline bool InitializeModelArgs_SourceType_Parse(
    const ::std::string& name, InitializeModelArgs_SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InitializeModelArgs_SourceType>(
    InitializeModelArgs_SourceType_descriptor(), name, value);
}
enum GetTopicModelArgs_RequestType {
  GetTopicModelArgs_RequestType_Pwt = 0,
  GetTopicModelArgs_RequestType_Nwt = 1
};
bool GetTopicModelArgs_RequestType_IsValid(int value);
const GetTopicModelArgs_RequestType GetTopicModelArgs_RequestType_RequestType_MIN = GetTopicModelArgs_RequestType_Pwt;
const GetTopicModelArgs_RequestType GetTopicModelArgs_RequestType_RequestType_MAX = GetTopicModelArgs_RequestType_Nwt;
const int GetTopicModelArgs_RequestType_RequestType_ARRAYSIZE = GetTopicModelArgs_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetTopicModelArgs_RequestType_descriptor();
inline const ::std::string& GetTopicModelArgs_RequestType_Name(GetTopicModelArgs_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetTopicModelArgs_RequestType_descriptor(), value);
}
inline bool GetTopicModelArgs_RequestType_Parse(
    const ::std::string& name, GetTopicModelArgs_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetTopicModelArgs_RequestType>(
    GetTopicModelArgs_RequestType_descriptor(), name, value);
}
enum ProcessBatchesArgs_ThetaMatrixType {
  ProcessBatchesArgs_ThetaMatrixType_None = 0,
  ProcessBatchesArgs_ThetaMatrixType_Dense = 1,
  ProcessBatchesArgs_ThetaMatrixType_Sparse = 2,
  ProcessBatchesArgs_ThetaMatrixType_Cache = 3
};
bool ProcessBatchesArgs_ThetaMatrixType_IsValid(int value);
const ProcessBatchesArgs_ThetaMatrixType ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_MIN = ProcessBatchesArgs_ThetaMatrixType_None;
const ProcessBatchesArgs_ThetaMatrixType ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_MAX = ProcessBatchesArgs_ThetaMatrixType_Cache;
const int ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_ARRAYSIZE = ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessBatchesArgs_ThetaMatrixType_descriptor();
inline const ::std::string& ProcessBatchesArgs_ThetaMatrixType_Name(ProcessBatchesArgs_ThetaMatrixType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessBatchesArgs_ThetaMatrixType_descriptor(), value);
}
inline bool ProcessBatchesArgs_ThetaMatrixType_Parse(
    const ::std::string& name, ProcessBatchesArgs_ThetaMatrixType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessBatchesArgs_ThetaMatrixType>(
    ProcessBatchesArgs_ThetaMatrixType_descriptor(), name, value);
}
// ===================================================================

class DoubleArray : public ::google::protobuf::Message {
 public:
  DoubleArray();
  virtual ~DoubleArray();

  DoubleArray(const DoubleArray& from);

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleArray& default_instance();

  void Swap(DoubleArray* other);

  // implements Message ----------------------------------------------

  DoubleArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DoubleArray& from);
  void MergeFrom(const DoubleArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.DoubleArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DoubleArray* default_instance_;
};
// -------------------------------------------------------------------

class FloatArray : public ::google::protobuf::Message {
 public:
  FloatArray();
  virtual ~FloatArray();

  FloatArray(const FloatArray& from);

  inline FloatArray& operator=(const FloatArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatArray& default_instance();

  void Swap(FloatArray* other);

  // implements Message ----------------------------------------------

  FloatArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloatArray& from);
  void MergeFrom(const FloatArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline float value(int index) const;
  inline void set_value(int index, float value);
  inline void add_value(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      value() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.FloatArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static FloatArray* default_instance_;
};
// -------------------------------------------------------------------

class BoolArray : public ::google::protobuf::Message {
 public:
  BoolArray();
  virtual ~BoolArray();

  BoolArray(const BoolArray& from);

  inline BoolArray& operator=(const BoolArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolArray& default_instance();

  void Swap(BoolArray* other);

  // implements Message ----------------------------------------------

  BoolArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoolArray& from);
  void MergeFrom(const BoolArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline bool value(int index) const;
  inline void set_value(int index, bool value);
  inline void add_value(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      value() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.BoolArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< bool > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static BoolArray* default_instance_;
};
// -------------------------------------------------------------------

class IntArray : public ::google::protobuf::Message {
 public:
  IntArray();
  virtual ~IntArray();

  IntArray(const IntArray& from);

  inline IntArray& operator=(const IntArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntArray& default_instance();

  void Swap(IntArray* other);

  // implements Message ----------------------------------------------

  IntArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntArray& from);
  void MergeFrom(const IntArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 value = 1 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::int32 value);
  inline void add_value(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:artm.IntArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static IntArray* default_instance_;
};
// -------------------------------------------------------------------

class StringArray : public ::google::protobuf::Message {
 public:
  StringArray();
  virtual ~StringArray();

  StringArray(const StringArray& from);

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringArray& default_instance();

  void Swap(StringArray* other);

  // implements Message ----------------------------------------------

  StringArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringArray& from);
  void MergeFrom(const StringArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value(int index) const;
  inline ::std::string* mutable_value(int index);
  inline void set_value(int index, const ::std::string& value);
  inline void set_value(int index, const char* value);
  inline void set_value(int index, const char* value, size_t size);
  inline ::std::string* add_value();
  inline void add_value(const ::std::string& value);
  inline void add_value(const char* value);
  inline void add_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:artm.StringArray)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static StringArray* default_instance_;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .artm.Field field = 2;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 2;
  inline const ::artm::Field& field(int index) const;
  inline ::artm::Field* mutable_field(int index);
  inline ::artm::Field* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Field >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Field >*
      mutable_field();

  // optional string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // @@protoc_insertion_point(class_scope:artm.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::Field > field_;
  ::std::string* title_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "@body"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 token_id = 2;
  inline int token_id_size() const;
  inline void clear_token_id();
  static const int kTokenIdFieldNumber = 2;
  inline ::google::protobuf::int32 token_id(int index) const;
  inline void set_token_id(int index, ::google::protobuf::int32 value);
  inline void add_token_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_id();

  // repeated int32 token_count = 3;
  inline int token_count_size() const;
  inline void clear_token_count();
  static const int kTokenCountFieldNumber = 3;
  inline ::google::protobuf::int32 token_count(int index) const;
  inline void set_token_count(int index, ::google::protobuf::int32 value);
  inline void add_token_count(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_count() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_count();

  // repeated int32 token_offset = 4;
  inline int token_offset_size() const;
  inline void clear_token_offset();
  static const int kTokenOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 token_offset(int index) const;
  inline void set_token_offset(int index, ::google::protobuf::int32 value);
  inline void add_token_offset(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      token_offset() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_token_offset();

  // optional string string_value = 5;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 5;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional int64 int_value = 6;
  inline bool has_int_value() const;
  inline void clear_int_value();
  static const int kIntValueFieldNumber = 6;
  inline ::google::protobuf::int64 int_value() const;
  inline void set_int_value(::google::protobuf::int64 value);

  // optional double double_value = 7;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 7;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional string date_value = 8;
  inline bool has_date_value() const;
  inline void clear_date_value();
  static const int kDateValueFieldNumber = 8;
  inline const ::std::string& date_value() const;
  inline void set_date_value(const ::std::string& value);
  inline void set_date_value(const char* value);
  inline void set_date_value(const char* value, size_t size);
  inline ::std::string* mutable_date_value();
  inline ::std::string* release_date_value();
  inline void set_allocated_date_value(::std::string* date_value);

  // repeated string string_array = 16;
  inline int string_array_size() const;
  inline void clear_string_array();
  static const int kStringArrayFieldNumber = 16;
  inline const ::std::string& string_array(int index) const;
  inline ::std::string* mutable_string_array(int index);
  inline void set_string_array(int index, const ::std::string& value);
  inline void set_string_array(int index, const char* value);
  inline void set_string_array(int index, const char* value, size_t size);
  inline ::std::string* add_string_array();
  inline void add_string_array(const ::std::string& value);
  inline void add_string_array(const char* value);
  inline void add_string_array(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& string_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_array();

  // repeated int64 int_array = 17;
  inline int int_array_size() const;
  inline void clear_int_array();
  static const int kIntArrayFieldNumber = 17;
  inline ::google::protobuf::int64 int_array(int index) const;
  inline void set_int_array(int index, ::google::protobuf::int64 value);
  inline void add_int_array(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      int_array() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_int_array();

  // repeated double double_array = 18;
  inline int double_array_size() const;
  inline void clear_double_array();
  static const int kDoubleArrayFieldNumber = 18;
  inline double double_array(int index) const;
  inline void set_double_array(int index, double value);
  inline void add_double_array(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      double_array() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_double_array();

  // repeated string date_array = 19;
  inline int date_array_size() const;
  inline void clear_date_array();
  static const int kDateArrayFieldNumber = 19;
  inline const ::std::string& date_array(int index) const;
  inline ::std::string* mutable_date_array(int index);
  inline void set_date_array(int index, const ::std::string& value);
  inline void set_date_array(int index, const char* value);
  inline void set_date_array(int index, const char* value, size_t size);
  inline ::std::string* add_date_array();
  inline void add_date_array(const ::std::string& value);
  inline void add_date_array(const char* value);
  inline void add_date_array(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& date_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_date_array();

  // @@protoc_insertion_point(class_scope:artm.Field)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_int_value();
  inline void clear_has_int_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_date_value();
  inline void clear_has_date_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > token_offset_;
  ::std::string* string_value_;
  ::google::protobuf::int64 int_value_;
  double double_value_;
  ::std::string* date_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_array_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > int_array_;
  ::google::protobuf::RepeatedField< double > double_array_;
  ::google::protobuf::RepeatedPtrField< ::std::string> date_array_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class Batch : public ::google::protobuf::Message {
 public:
  Batch();
  virtual ~Batch();

  Batch(const Batch& from);

  inline Batch& operator=(const Batch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Batch& default_instance();

  void Swap(Batch* other);

  // implements Message ----------------------------------------------

  Batch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Batch& from);
  void MergeFrom(const Batch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string token = 1;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated string class_id = 2;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // repeated .artm.Item item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::artm::Item& item(int index) const;
  inline ::artm::Item* mutable_item(int index);
  inline ::artm::Item* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Item >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Item >*
      mutable_item();

  // optional string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:artm.Batch)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  ::google::protobuf::RepeatedPtrField< ::artm::Item > item_;
  ::std::string* description_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Batch* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Stream_Type Type;
  static const Type Global = Stream_Type_Global;
  static const Type ItemIdModulus = Stream_Type_ItemIdModulus;
  static inline bool Type_IsValid(int value) {
    return Stream_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Stream_Type_Type_MIN;
  static const Type Type_MAX =
    Stream_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Stream_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Stream_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Stream_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Stream_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .artm.Stream.Type type = 1 [default = Global];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::artm::Stream_Type type() const;
  inline void set_type(::artm::Stream_Type value);

  // optional string name = 2 [default = "@global"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 modulus = 3;
  inline bool has_modulus() const;
  inline void clear_modulus();
  static const int kModulusFieldNumber = 3;
  inline ::google::protobuf::int32 modulus() const;
  inline void set_modulus(::google::protobuf::int32 value);

  // repeated int32 residuals = 4;
  inline int residuals_size() const;
  inline void clear_residuals();
  static const int kResidualsFieldNumber = 4;
  inline ::google::protobuf::int32 residuals(int index) const;
  inline void set_residuals(int index, ::google::protobuf::int32 value);
  inline void add_residuals(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      residuals() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_residuals();

  // @@protoc_insertion_point(class_scope:artm.Stream)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_modulus();
  inline void clear_has_modulus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  int type_;
  ::google::protobuf::int32 modulus_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > residuals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class MasterComponentConfig : public ::google::protobuf::Message {
 public:
  MasterComponentConfig();
  virtual ~MasterComponentConfig();

  MasterComponentConfig(const MasterComponentConfig& from);

  inline MasterComponentConfig& operator=(const MasterComponentConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterComponentConfig& default_instance();

  void Swap(MasterComponentConfig* other);

  // implements Message ----------------------------------------------

  MasterComponentConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterComponentConfig& from);
  void MergeFrom(const MasterComponentConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string disk_path = 2;
  inline bool has_disk_path() const;
  inline void clear_disk_path();
  static const int kDiskPathFieldNumber = 2;
  inline const ::std::string& disk_path() const;
  inline void set_disk_path(const ::std::string& value);
  inline void set_disk_path(const char* value);
  inline void set_disk_path(const char* value, size_t size);
  inline ::std::string* mutable_disk_path();
  inline ::std::string* release_disk_path();
  inline void set_allocated_disk_path(::std::string* disk_path);

  // repeated .artm.Stream stream = 3;
  inline int stream_size() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 3;
  inline const ::artm::Stream& stream(int index) const;
  inline ::artm::Stream* mutable_stream(int index);
  inline ::artm::Stream* add_stream();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::Stream >&
      stream() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::Stream >*
      mutable_stream();

  // optional bool compact_batches = 4 [default = true];
  inline bool has_compact_batches() const;
  inline void clear_compact_batches();
  static const int kCompactBatchesFieldNumber = 4;
  inline bool compact_batches() const;
  inline void set_compact_batches(bool value);

  // optional bool cache_theta = 5 [default = false];
  inline bool has_cache_theta() const;
  inline void clear_cache_theta();
  static const int kCacheThetaFieldNumber = 5;
  inline bool cache_theta() const;
  inline void set_cache_theta(bool value);

  // optional int32 processors_count = 6;
  inline bool has_processors_count() const;
  inline void clear_processors_count();
  static const int kProcessorsCountFieldNumber = 6;
  inline ::google::protobuf::int32 processors_count() const;
  inline void set_processors_count(::google::protobuf::int32 value);

  // optional int32 processor_queue_max_size = 7 [default = 10];
  inline bool has_processor_queue_max_size() const;
  inline void clear_processor_queue_max_size();
  static const int kProcessorQueueMaxSizeFieldNumber = 7;
  inline ::google::protobuf::int32 processor_queue_max_size() const;
  inline void set_processor_queue_max_size(::google::protobuf::int32 value);

  // optional int32 merger_queue_max_size = 8 [default = 10];
  inline bool has_merger_queue_max_size() const;
  inline void clear_merger_queue_max_size();
  static const int kMergerQueueMaxSizeFieldNumber = 8;
  inline ::google::protobuf::int32 merger_queue_max_size() const;
  inline void set_merger_queue_max_size(::google::protobuf::int32 value);

  // repeated .artm.ScoreConfig score_config = 9;
  inline int score_config_size() const;
  inline void clear_score_config();
  static const int kScoreConfigFieldNumber = 9;
  inline const ::artm::ScoreConfig& score_config(int index) const;
  inline ::artm::ScoreConfig* mutable_score_config(int index);
  inline ::artm::ScoreConfig* add_score_config();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >&
      score_config() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >*
      mutable_score_config();

  // optional bool online_batch_processing = 13 [default = false];
  inline bool has_online_batch_processing() const;
  inline void clear_online_batch_processing();
  static const int kOnlineBatchProcessingFieldNumber = 13;
  inline bool online_batch_processing() const;
  inline void set_online_batch_processing(bool value);

  // optional string disk_cache_path = 15;
  inline bool has_disk_cache_path() const;
  inline void clear_disk_cache_path();
  static const int kDiskCachePathFieldNumber = 15;
  inline const ::std::string& disk_cache_path() const;
  inline void set_disk_cache_path(const ::std::string& value);
  inline void set_disk_cache_path(const char* value);
  inline void set_disk_cache_path(const char* value, size_t size);
  inline ::std::string* mutable_disk_cache_path();
  inline ::std::string* release_disk_cache_path();
  inline void set_allocated_disk_cache_path(::std::string* disk_cache_path);

  // @@protoc_insertion_point(class_scope:artm.MasterComponentConfig)
 private:
  inline void set_has_disk_path();
  inline void clear_has_disk_path();
  inline void set_has_compact_batches();
  inline void clear_has_compact_batches();
  inline void set_has_cache_theta();
  inline void clear_has_cache_theta();
  inline void set_has_processors_count();
  inline void clear_has_processors_count();
  inline void set_has_processor_queue_max_size();
  inline void clear_has_processor_queue_max_size();
  inline void set_has_merger_queue_max_size();
  inline void clear_has_merger_queue_max_size();
  inline void set_has_online_batch_processing();
  inline void clear_has_online_batch_processing();
  inline void set_has_disk_cache_path();
  inline void clear_has_disk_cache_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* disk_path_;
  ::google::protobuf::RepeatedPtrField< ::artm::Stream > stream_;
  ::google::protobuf::int32 processors_count_;
  bool compact_batches_;
  bool cache_theta_;
  bool online_batch_processing_;
  ::google::protobuf::int32 processor_queue_max_size_;
  ::google::protobuf::int32 merger_queue_max_size_;
  ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig > score_config_;
  ::std::string* disk_cache_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MasterComponentConfig* default_instance_;
};
// -------------------------------------------------------------------

class RegularizerSettings : public ::google::protobuf::Message {
 public:
  RegularizerSettings();
  virtual ~RegularizerSettings();

  RegularizerSettings(const RegularizerSettings& from);

  inline RegularizerSettings& operator=(const RegularizerSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularizerSettings& default_instance();

  void Swap(RegularizerSettings* other);

  // implements Message ----------------------------------------------

  RegularizerSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularizerSettings& from);
  void MergeFrom(const RegularizerSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double tau = 2;
  inline bool has_tau() const;
  inline void clear_tau();
  static const int kTauFieldNumber = 2;
  inline double tau() const;
  inline void set_tau(double value);

  // optional bool use_relative_regularization = 3;
  inline bool has_use_relative_regularization() const;
  inline void clear_use_relative_regularization();
  static const int kUseRelativeRegularizationFieldNumber = 3;
  inline bool use_relative_regularization() const;
  inline void set_use_relative_regularization(bool value);

  // optional double gamma = 4;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 4;
  inline double gamma() const;
  inline void set_gamma(double value);

  // @@protoc_insertion_point(class_scope:artm.RegularizerSettings)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tau();
  inline void clear_has_tau();
  inline void set_has_use_relative_regularization();
  inline void clear_has_use_relative_regularization();
  inline void set_has_gamma();
  inline void clear_has_gamma();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double tau_;
  double gamma_;
  bool use_relative_regularization_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegularizerSettings* default_instance_;
};
// -------------------------------------------------------------------

class ModelConfig : public ::google::protobuf::Message {
 public:
  ModelConfig();
  virtual ~ModelConfig();

  ModelConfig(const ModelConfig& from);

  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelConfig& default_instance();

  void Swap(ModelConfig* other);

  // implements Message ----------------------------------------------

  ModelConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelConfig& from);
  void MergeFrom(const ModelConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "@model"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 topics_count = 2 [default = 32];
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 2;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // repeated string topic_name = 3;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 3;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // optional bool enabled = 4 [default = true];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional int32 inner_iterations_count = 5 [default = 10];
  inline bool has_inner_iterations_count() const;
  inline void clear_inner_iterations_count();
  static const int kInnerIterationsCountFieldNumber = 5;
  inline ::google::protobuf::int32 inner_iterations_count() const;
  inline void set_inner_iterations_count(::google::protobuf::int32 value);

  // optional string field_name = 6 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 6;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 7 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 7;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // repeated string score_name = 8;
  inline int score_name_size() const;
  inline void clear_score_name();
  static const int kScoreNameFieldNumber = 8;
  inline const ::std::string& score_name(int index) const;
  inline ::std::string* mutable_score_name(int index);
  inline void set_score_name(int index, const ::std::string& value);
  inline void set_score_name(int index, const char* value);
  inline void set_score_name(int index, const char* value, size_t size);
  inline ::std::string* add_score_name();
  inline void add_score_name(const ::std::string& value);
  inline void add_score_name(const char* value);
  inline void add_score_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& score_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_score_name();

  // optional bool reuse_theta = 9 [default = false];
  inline bool has_reuse_theta() const;
  inline void clear_reuse_theta();
  static const int kReuseThetaFieldNumber = 9;
  inline bool reuse_theta() const;
  inline void set_reuse_theta(bool value);

  // repeated string regularizer_name = 10;
  inline int regularizer_name_size() const;
  inline void clear_regularizer_name();
  static const int kRegularizerNameFieldNumber = 10;
  inline const ::std::string& regularizer_name(int index) const;
  inline ::std::string* mutable_regularizer_name(int index);
  inline void set_regularizer_name(int index, const ::std::string& value);
  inline void set_regularizer_name(int index, const char* value);
  inline void set_regularizer_name(int index, const char* value, size_t size);
  inline ::std::string* add_regularizer_name();
  inline void add_regularizer_name(const ::std::string& value);
  inline void add_regularizer_name(const char* value);
  inline void add_regularizer_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& regularizer_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_regularizer_name();

  // repeated double regularizer_tau = 11;
  inline int regularizer_tau_size() const;
  inline void clear_regularizer_tau();
  static const int kRegularizerTauFieldNumber = 11;
  inline double regularizer_tau(int index) const;
  inline void set_regularizer_tau(int index, double value);
  inline void add_regularizer_tau(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      regularizer_tau() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_regularizer_tau();

  // repeated string class_id = 12;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 12;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // repeated float class_weight = 13;
  inline int class_weight_size() const;
  inline void clear_class_weight();
  static const int kClassWeightFieldNumber = 13;
  inline float class_weight(int index) const;
  inline void set_class_weight(int index, float value);
  inline void add_class_weight(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      class_weight() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_class_weight();

  // optional bool use_sparse_bow = 14 [default = true];
  inline bool has_use_sparse_bow() const;
  inline void clear_use_sparse_bow();
  static const int kUseSparseBowFieldNumber = 14;
  inline bool use_sparse_bow() const;
  inline void set_use_sparse_bow(bool value);

  // optional bool use_random_theta = 15 [default = false];
  inline bool has_use_random_theta() const;
  inline void clear_use_random_theta();
  static const int kUseRandomThetaFieldNumber = 15;
  inline bool use_random_theta() const;
  inline void set_use_random_theta(bool value);

  // optional bool use_new_tokens = 16 [default = true];
  inline bool has_use_new_tokens() const;
  inline void clear_use_new_tokens();
  static const int kUseNewTokensFieldNumber = 16;
  inline bool use_new_tokens() const;
  inline void set_use_new_tokens(bool value);

  // optional bool opt_for_avx = 17 [default = true];
  inline bool has_opt_for_avx() const;
  inline void clear_opt_for_avx();
  static const int kOptForAvxFieldNumber = 17;
  inline bool opt_for_avx() const;
  inline void set_opt_for_avx(bool value);

  // repeated .artm.RegularizerSettings regularizer_settings = 18;
  inline int regularizer_settings_size() const;
  inline void clear_regularizer_settings();
  static const int kRegularizerSettingsFieldNumber = 18;
  inline const ::artm::RegularizerSettings& regularizer_settings(int index) const;
  inline ::artm::RegularizerSettings* mutable_regularizer_settings(int index);
  inline ::artm::RegularizerSettings* add_regularizer_settings();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >&
      regularizer_settings() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >*
      mutable_regularizer_settings();

  // @@protoc_insertion_point(class_scope:artm.ModelConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_topics_count();
  inline void clear_has_topics_count();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_inner_iterations_count();
  inline void clear_has_inner_iterations_count();
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_reuse_theta();
  inline void clear_has_reuse_theta();
  inline void set_has_use_sparse_bow();
  inline void clear_has_use_sparse_bow();
  inline void set_has_use_random_theta();
  inline void clear_has_use_random_theta();
  inline void set_has_use_new_tokens();
  inline void clear_has_use_new_tokens();
  inline void set_has_opt_for_avx();
  inline void clear_has_opt_for_avx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::int32 topics_count_;
  ::google::protobuf::int32 inner_iterations_count_;
  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> score_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> regularizer_name_;
  ::google::protobuf::RepeatedField< double > regularizer_tau_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  bool enabled_;
  bool reuse_theta_;
  bool use_sparse_bow_;
  bool use_random_theta_;
  bool use_new_tokens_;
  bool opt_for_avx_;
  ::google::protobuf::RepeatedField< float > class_weight_;
  ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings > regularizer_settings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ModelConfig* default_instance_;
};
// -------------------------------------------------------------------

class RegularizerConfig : public ::google::protobuf::Message {
 public:
  RegularizerConfig();
  virtual ~RegularizerConfig();

  RegularizerConfig(const RegularizerConfig& from);

  inline RegularizerConfig& operator=(const RegularizerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularizerConfig& default_instance();

  void Swap(RegularizerConfig* other);

  // implements Message ----------------------------------------------

  RegularizerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularizerConfig& from);
  void MergeFrom(const RegularizerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegularizerConfig_Type Type;
  static const Type SmoothSparseTheta = RegularizerConfig_Type_SmoothSparseTheta;
  static const Type SmoothSparsePhi = RegularizerConfig_Type_SmoothSparsePhi;
  static const Type DecorrelatorPhi = RegularizerConfig_Type_DecorrelatorPhi;
  static const Type MultiLanguagePhi = RegularizerConfig_Type_MultiLanguagePhi;
  static const Type LabelRegularizationPhi = RegularizerConfig_Type_LabelRegularizationPhi;
  static const Type SpecifiedSparsePhi = RegularizerConfig_Type_SpecifiedSparsePhi;
  static const Type ImproveCoherencePhi = RegularizerConfig_Type_ImproveCoherencePhi;
  static inline bool Type_IsValid(int value) {
    return RegularizerConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RegularizerConfig_Type_Type_MIN;
  static const Type Type_MAX =
    RegularizerConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RegularizerConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RegularizerConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RegularizerConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RegularizerConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.RegularizerConfig.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::RegularizerConfig_Type type() const;
  inline void set_type(::artm::RegularizerConfig_Type value);

  // optional bytes config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const void* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:artm.RegularizerConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* config_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegularizerConfig* default_instance_;
};
// -------------------------------------------------------------------

class SmoothSparseThetaConfig : public ::google::protobuf::Message {
 public:
  SmoothSparseThetaConfig();
  virtual ~SmoothSparseThetaConfig();

  SmoothSparseThetaConfig(const SmoothSparseThetaConfig& from);

  inline SmoothSparseThetaConfig& operator=(const SmoothSparseThetaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmoothSparseThetaConfig& default_instance();

  void Swap(SmoothSparseThetaConfig* other);

  // implements Message ----------------------------------------------

  SmoothSparseThetaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmoothSparseThetaConfig& from);
  void MergeFrom(const SmoothSparseThetaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topic_name = 1;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated float alpha_iter = 2;
  inline int alpha_iter_size() const;
  inline void clear_alpha_iter();
  static const int kAlphaIterFieldNumber = 2;
  inline float alpha_iter(int index) const;
  inline void set_alpha_iter(int index, float value);
  inline void add_alpha_iter(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      alpha_iter() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_alpha_iter();

  // @@protoc_insertion_point(class_scope:artm.SmoothSparseThetaConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedField< float > alpha_iter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SmoothSparseThetaConfig* default_instance_;
};
// -------------------------------------------------------------------

class SmoothSparsePhiConfig : public ::google::protobuf::Message {
 public:
  SmoothSparsePhiConfig();
  virtual ~SmoothSparsePhiConfig();

  SmoothSparsePhiConfig(const SmoothSparsePhiConfig& from);

  inline SmoothSparsePhiConfig& operator=(const SmoothSparsePhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmoothSparsePhiConfig& default_instance();

  void Swap(SmoothSparsePhiConfig* other);

  // implements Message ----------------------------------------------

  SmoothSparsePhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmoothSparsePhiConfig& from);
  void MergeFrom(const SmoothSparsePhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topic_name = 1;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated string class_id = 2;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // optional string dictionary_name = 3;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 3;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.SmoothSparsePhiConfig)
 private:
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  ::std::string* dictionary_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SmoothSparsePhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class DecorrelatorPhiConfig : public ::google::protobuf::Message {
 public:
  DecorrelatorPhiConfig();
  virtual ~DecorrelatorPhiConfig();

  DecorrelatorPhiConfig(const DecorrelatorPhiConfig& from);

  inline DecorrelatorPhiConfig& operator=(const DecorrelatorPhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecorrelatorPhiConfig& default_instance();

  void Swap(DecorrelatorPhiConfig* other);

  // implements Message ----------------------------------------------

  DecorrelatorPhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecorrelatorPhiConfig& from);
  void MergeFrom(const DecorrelatorPhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topic_name = 1;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated string class_id = 2;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // @@protoc_insertion_point(class_scope:artm.DecorrelatorPhiConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DecorrelatorPhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class MultiLanguagePhiConfig : public ::google::protobuf::Message {
 public:
  MultiLanguagePhiConfig();
  virtual ~MultiLanguagePhiConfig();

  MultiLanguagePhiConfig(const MultiLanguagePhiConfig& from);

  inline MultiLanguagePhiConfig& operator=(const MultiLanguagePhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiLanguagePhiConfig& default_instance();

  void Swap(MultiLanguagePhiConfig* other);

  // implements Message ----------------------------------------------

  MultiLanguagePhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiLanguagePhiConfig& from);
  void MergeFrom(const MultiLanguagePhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:artm.MultiLanguagePhiConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MultiLanguagePhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class LabelRegularizationPhiConfig : public ::google::protobuf::Message {
 public:
  LabelRegularizationPhiConfig();
  virtual ~LabelRegularizationPhiConfig();

  LabelRegularizationPhiConfig(const LabelRegularizationPhiConfig& from);

  inline LabelRegularizationPhiConfig& operator=(const LabelRegularizationPhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelRegularizationPhiConfig& default_instance();

  void Swap(LabelRegularizationPhiConfig* other);

  // implements Message ----------------------------------------------

  LabelRegularizationPhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabelRegularizationPhiConfig& from);
  void MergeFrom(const LabelRegularizationPhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topic_name = 1;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated string class_id = 2;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // optional string dictionary_name = 3;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 3;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.LabelRegularizationPhiConfig)
 private:
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  ::std::string* dictionary_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static LabelRegularizationPhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class SpecifiedSparsePhiConfig : public ::google::protobuf::Message {
 public:
  SpecifiedSparsePhiConfig();
  virtual ~SpecifiedSparsePhiConfig();

  SpecifiedSparsePhiConfig(const SpecifiedSparsePhiConfig& from);

  inline SpecifiedSparsePhiConfig& operator=(const SpecifiedSparsePhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpecifiedSparsePhiConfig& default_instance();

  void Swap(SpecifiedSparsePhiConfig* other);

  // implements Message ----------------------------------------------

  SpecifiedSparsePhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpecifiedSparsePhiConfig& from);
  void MergeFrom(const SpecifiedSparsePhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SpecifiedSparsePhiConfig_Mode Mode;
  static const Mode SparseTopics = SpecifiedSparsePhiConfig_Mode_SparseTopics;
  static const Mode SparseTokens = SpecifiedSparsePhiConfig_Mode_SparseTokens;
  static inline bool Mode_IsValid(int value) {
    return SpecifiedSparsePhiConfig_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    SpecifiedSparsePhiConfig_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    SpecifiedSparsePhiConfig_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    SpecifiedSparsePhiConfig_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return SpecifiedSparsePhiConfig_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return SpecifiedSparsePhiConfig_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return SpecifiedSparsePhiConfig_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string topic_name = 1;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // optional string class_id = 2 [default = "@default_class"];
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const char* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // optional int32 max_elements_count = 3 [default = 20];
  inline bool has_max_elements_count() const;
  inline void clear_max_elements_count();
  static const int kMaxElementsCountFieldNumber = 3;
  inline ::google::protobuf::int32 max_elements_count() const;
  inline void set_max_elements_count(::google::protobuf::int32 value);

  // optional float probability_threshold = 4 [default = 0.99];
  inline bool has_probability_threshold() const;
  inline void clear_probability_threshold();
  static const int kProbabilityThresholdFieldNumber = 4;
  inline float probability_threshold() const;
  inline void set_probability_threshold(float value);

  // optional .artm.SpecifiedSparsePhiConfig.Mode mode = 5 [default = SparseTopics];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline ::artm::SpecifiedSparsePhiConfig_Mode mode() const;
  inline void set_mode(::artm::SpecifiedSparsePhiConfig_Mode value);

  // @@protoc_insertion_point(class_scope:artm.SpecifiedSparsePhiConfig)
 private:
  inline void set_has_class_id();
  inline void clear_has_class_id();
  inline void set_has_max_elements_count();
  inline void clear_has_max_elements_count();
  inline void set_has_probability_threshold();
  inline void clear_has_probability_threshold();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::std::string* class_id_;
  static ::std::string* _default_class_id_;
  ::google::protobuf::int32 max_elements_count_;
  float probability_threshold_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SpecifiedSparsePhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class ImproveCoherencePhiConfig : public ::google::protobuf::Message {
 public:
  ImproveCoherencePhiConfig();
  virtual ~ImproveCoherencePhiConfig();

  ImproveCoherencePhiConfig(const ImproveCoherencePhiConfig& from);

  inline ImproveCoherencePhiConfig& operator=(const ImproveCoherencePhiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImproveCoherencePhiConfig& default_instance();

  void Swap(ImproveCoherencePhiConfig* other);

  // implements Message ----------------------------------------------

  ImproveCoherencePhiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImproveCoherencePhiConfig& from);
  void MergeFrom(const ImproveCoherencePhiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topic_name = 1;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated string class_id = 2;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // optional string dictionary_name = 3;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 3;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.ImproveCoherencePhiConfig)
 private:
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  ::std::string* dictionary_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ImproveCoherencePhiConfig* default_instance_;
};
// -------------------------------------------------------------------

class RegularizerInternalState : public ::google::protobuf::Message {
 public:
  RegularizerInternalState();
  virtual ~RegularizerInternalState();

  RegularizerInternalState(const RegularizerInternalState& from);

  inline RegularizerInternalState& operator=(const RegularizerInternalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularizerInternalState& default_instance();

  void Swap(RegularizerInternalState* other);

  // implements Message ----------------------------------------------

  RegularizerInternalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularizerInternalState& from);
  void MergeFrom(const RegularizerInternalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegularizerInternalState_Type Type;
  static const Type MultiLanguagePhi = RegularizerInternalState_Type_MultiLanguagePhi;
  static inline bool Type_IsValid(int value) {
    return RegularizerInternalState_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RegularizerInternalState_Type_Type_MIN;
  static const Type Type_MAX =
    RegularizerInternalState_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RegularizerInternalState_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RegularizerInternalState_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RegularizerInternalState_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RegularizerInternalState_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.RegularizerInternalState.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::RegularizerInternalState_Type type() const;
  inline void set_type(::artm::RegularizerInternalState_Type value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:artm.RegularizerInternalState)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegularizerInternalState* default_instance_;
};
// -------------------------------------------------------------------

class MultiLanguagePhiInternalState : public ::google::protobuf::Message {
 public:
  MultiLanguagePhiInternalState();
  virtual ~MultiLanguagePhiInternalState();

  MultiLanguagePhiInternalState(const MultiLanguagePhiInternalState& from);

  inline MultiLanguagePhiInternalState& operator=(const MultiLanguagePhiInternalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiLanguagePhiInternalState& default_instance();

  void Swap(MultiLanguagePhiInternalState* other);

  // implements Message ----------------------------------------------

  MultiLanguagePhiInternalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiLanguagePhiInternalState& from);
  void MergeFrom(const MultiLanguagePhiInternalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 no_regularization_calls = 1 [default = 0];
  inline bool has_no_regularization_calls() const;
  inline void clear_no_regularization_calls();
  static const int kNoRegularizationCallsFieldNumber = 1;
  inline ::google::protobuf::int32 no_regularization_calls() const;
  inline void set_no_regularization_calls(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.MultiLanguagePhiInternalState)
 private:
  inline void set_has_no_regularization_calls();
  inline void clear_has_no_regularization_calls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 no_regularization_calls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MultiLanguagePhiInternalState* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryConfig : public ::google::protobuf::Message {
 public:
  DictionaryConfig();
  virtual ~DictionaryConfig();

  DictionaryConfig(const DictionaryConfig& from);

  inline DictionaryConfig& operator=(const DictionaryConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryConfig& default_instance();

  void Swap(DictionaryConfig* other);

  // implements Message ----------------------------------------------

  DictionaryConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryConfig& from);
  void MergeFrom(const DictionaryConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .artm.DictionaryEntry entry = 2;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline const ::artm::DictionaryEntry& entry(int index) const;
  inline ::artm::DictionaryEntry* mutable_entry(int index);
  inline ::artm::DictionaryEntry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >*
      mutable_entry();

  // optional int32 total_token_count = 3;
  inline bool has_total_token_count() const;
  inline void clear_total_token_count();
  static const int kTotalTokenCountFieldNumber = 3;
  inline ::google::protobuf::int32 total_token_count() const;
  inline void set_total_token_count(::google::protobuf::int32 value);

  // optional int32 total_items_count = 4;
  inline bool has_total_items_count() const;
  inline void clear_total_items_count();
  static const int kTotalItemsCountFieldNumber = 4;
  inline ::google::protobuf::int32 total_items_count() const;
  inline void set_total_items_count(::google::protobuf::int32 value);

  // optional .artm.DictionaryCoocurenceEntries cooc_entries = 5;
  inline bool has_cooc_entries() const;
  inline void clear_cooc_entries();
  static const int kCoocEntriesFieldNumber = 5;
  inline const ::artm::DictionaryCoocurenceEntries& cooc_entries() const;
  inline ::artm::DictionaryCoocurenceEntries* mutable_cooc_entries();
  inline ::artm::DictionaryCoocurenceEntries* release_cooc_entries();
  inline void set_allocated_cooc_entries(::artm::DictionaryCoocurenceEntries* cooc_entries);

  // @@protoc_insertion_point(class_scope:artm.DictionaryConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_total_token_count();
  inline void clear_has_total_token_count();
  inline void set_has_total_items_count();
  inline void clear_has_total_items_count();
  inline void set_has_cooc_entries();
  inline void clear_has_cooc_entries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry > entry_;
  ::google::protobuf::int32 total_token_count_;
  ::google::protobuf::int32 total_items_count_;
  ::artm::DictionaryCoocurenceEntries* cooc_entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DictionaryConfig* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryEntry : public ::google::protobuf::Message {
 public:
  DictionaryEntry();
  virtual ~DictionaryEntry();

  DictionaryEntry(const DictionaryEntry& from);

  inline DictionaryEntry& operator=(const DictionaryEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryEntry& default_instance();

  void Swap(DictionaryEntry* other);

  // implements Message ----------------------------------------------

  DictionaryEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryEntry& from);
  void MergeFrom(const DictionaryEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key_token = 1;
  inline bool has_key_token() const;
  inline void clear_key_token();
  static const int kKeyTokenFieldNumber = 1;
  inline const ::std::string& key_token() const;
  inline void set_key_token(const ::std::string& value);
  inline void set_key_token(const char* value);
  inline void set_key_token(const char* value, size_t size);
  inline ::std::string* mutable_key_token();
  inline ::std::string* release_key_token();
  inline void set_allocated_key_token(::std::string* key_token);

  // optional string class_id = 2;
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const char* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // optional float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);

  // repeated string value_tokens = 4;
  inline int value_tokens_size() const;
  inline void clear_value_tokens();
  static const int kValueTokensFieldNumber = 4;
  inline const ::std::string& value_tokens(int index) const;
  inline ::std::string* mutable_value_tokens(int index);
  inline void set_value_tokens(int index, const ::std::string& value);
  inline void set_value_tokens(int index, const char* value);
  inline void set_value_tokens(int index, const char* value, size_t size);
  inline ::std::string* add_value_tokens();
  inline void add_value_tokens(const ::std::string& value);
  inline void add_value_tokens(const char* value);
  inline void add_value_tokens(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value_tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value_tokens();

  // optional .artm.FloatArray values = 5;
  inline bool has_values() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 5;
  inline const ::artm::FloatArray& values() const;
  inline ::artm::FloatArray* mutable_values();
  inline ::artm::FloatArray* release_values();
  inline void set_allocated_values(::artm::FloatArray* values);

  // optional int32 token_count = 6;
  inline bool has_token_count() const;
  inline void clear_token_count();
  static const int kTokenCountFieldNumber = 6;
  inline ::google::protobuf::int32 token_count() const;
  inline void set_token_count(::google::protobuf::int32 value);

  // optional int32 items_count = 7;
  inline bool has_items_count() const;
  inline void clear_items_count();
  static const int kItemsCountFieldNumber = 7;
  inline ::google::protobuf::int32 items_count() const;
  inline void set_items_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.DictionaryEntry)
 private:
  inline void set_has_key_token();
  inline void clear_has_key_token();
  inline void set_has_class_id();
  inline void clear_has_class_id();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_values();
  inline void clear_has_values();
  inline void set_has_token_count();
  inline void clear_has_token_count();
  inline void set_has_items_count();
  inline void clear_has_items_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_token_;
  ::std::string* class_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_tokens_;
  float value_;
  ::google::protobuf::int32 token_count_;
  ::artm::FloatArray* values_;
  ::google::protobuf::int32 items_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DictionaryEntry* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryCoocurenceEntries : public ::google::protobuf::Message {
 public:
  DictionaryCoocurenceEntries();
  virtual ~DictionaryCoocurenceEntries();

  DictionaryCoocurenceEntries(const DictionaryCoocurenceEntries& from);

  inline DictionaryCoocurenceEntries& operator=(const DictionaryCoocurenceEntries& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryCoocurenceEntries& default_instance();

  void Swap(DictionaryCoocurenceEntries* other);

  // implements Message ----------------------------------------------

  DictionaryCoocurenceEntries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryCoocurenceEntries& from);
  void MergeFrom(const DictionaryCoocurenceEntries& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 first_index = 1;
  inline int first_index_size() const;
  inline void clear_first_index();
  static const int kFirstIndexFieldNumber = 1;
  inline ::google::protobuf::int32 first_index(int index) const;
  inline void set_first_index(int index, ::google::protobuf::int32 value);
  inline void add_first_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      first_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_first_index();

  // repeated int32 second_index = 2;
  inline int second_index_size() const;
  inline void clear_second_index();
  static const int kSecondIndexFieldNumber = 2;
  inline ::google::protobuf::int32 second_index(int index) const;
  inline void set_second_index(int index, ::google::protobuf::int32 value);
  inline void add_second_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      second_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_second_index();

  // repeated float items_count = 3;
  inline int items_count_size() const;
  inline void clear_items_count();
  static const int kItemsCountFieldNumber = 3;
  inline float items_count(int index) const;
  inline void set_items_count(int index, float value);
  inline void add_items_count(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      items_count() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_items_count();

  // @@protoc_insertion_point(class_scope:artm.DictionaryCoocurenceEntries)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > first_index_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > second_index_;
  ::google::protobuf::RepeatedField< float > items_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DictionaryCoocurenceEntries* default_instance_;
};
// -------------------------------------------------------------------

class ScoreConfig : public ::google::protobuf::Message {
 public:
  ScoreConfig();
  virtual ~ScoreConfig();

  ScoreConfig(const ScoreConfig& from);

  inline ScoreConfig& operator=(const ScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreConfig& default_instance();

  void Swap(ScoreConfig* other);

  // implements Message ----------------------------------------------

  ScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreConfig& from);
  void MergeFrom(const ScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScoreConfig_Type Type;
  static const Type Perplexity = ScoreConfig_Type_Perplexity;
  static const Type SparsityTheta = ScoreConfig_Type_SparsityTheta;
  static const Type SparsityPhi = ScoreConfig_Type_SparsityPhi;
  static const Type ItemsProcessed = ScoreConfig_Type_ItemsProcessed;
  static const Type TopTokens = ScoreConfig_Type_TopTokens;
  static const Type ThetaSnippet = ScoreConfig_Type_ThetaSnippet;
  static const Type TopicKernel = ScoreConfig_Type_TopicKernel;
  static inline bool Type_IsValid(int value) {
    return ScoreConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ScoreConfig_Type_Type_MIN;
  static const Type Type_MAX =
    ScoreConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ScoreConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ScoreConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ScoreConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ScoreConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.ScoreConfig.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::ScoreConfig_Type type() const;
  inline void set_type(::artm::ScoreConfig_Type value);

  // optional bytes config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const void* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:artm.ScoreConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* config_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class ScoreData : public ::google::protobuf::Message {
 public:
  ScoreData();
  virtual ~ScoreData();

  ScoreData(const ScoreData& from);

  inline ScoreData& operator=(const ScoreData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreData& default_instance();

  void Swap(ScoreData* other);

  // implements Message ----------------------------------------------

  ScoreData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreData& from);
  void MergeFrom(const ScoreData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScoreData_Type Type;
  static const Type Perplexity = ScoreData_Type_Perplexity;
  static const Type SparsityTheta = ScoreData_Type_SparsityTheta;
  static const Type SparsityPhi = ScoreData_Type_SparsityPhi;
  static const Type ItemsProcessed = ScoreData_Type_ItemsProcessed;
  static const Type TopTokens = ScoreData_Type_TopTokens;
  static const Type ThetaSnippet = ScoreData_Type_ThetaSnippet;
  static const Type TopicKernel = ScoreData_Type_TopicKernel;
  static inline bool Type_IsValid(int value) {
    return ScoreData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ScoreData_Type_Type_MIN;
  static const Type Type_MAX =
    ScoreData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ScoreData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ScoreData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ScoreData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ScoreData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .artm.ScoreData.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::artm::ScoreData_Type type() const;
  inline void set_type(::artm::ScoreData_Type value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:artm.ScoreData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ScoreData* default_instance_;
};
// -------------------------------------------------------------------

class PerplexityScoreConfig : public ::google::protobuf::Message {
 public:
  PerplexityScoreConfig();
  virtual ~PerplexityScoreConfig();

  PerplexityScoreConfig(const PerplexityScoreConfig& from);

  inline PerplexityScoreConfig& operator=(const PerplexityScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerplexityScoreConfig& default_instance();

  void Swap(PerplexityScoreConfig* other);

  // implements Message ----------------------------------------------

  PerplexityScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerplexityScoreConfig& from);
  void MergeFrom(const PerplexityScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PerplexityScoreConfig_Type Type;
  static const Type UnigramDocumentModel = PerplexityScoreConfig_Type_UnigramDocumentModel;
  static const Type UnigramCollectionModel = PerplexityScoreConfig_Type_UnigramCollectionModel;
  static inline bool Type_IsValid(int value) {
    return PerplexityScoreConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PerplexityScoreConfig_Type_Type_MIN;
  static const Type Type_MAX =
    PerplexityScoreConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PerplexityScoreConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return PerplexityScoreConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return PerplexityScoreConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return PerplexityScoreConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string field_name = 1 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 2 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 2;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // optional .artm.PerplexityScoreConfig.Type model_type = 3 [default = UnigramDocumentModel];
  inline bool has_model_type() const;
  inline void clear_model_type();
  static const int kModelTypeFieldNumber = 3;
  inline ::artm::PerplexityScoreConfig_Type model_type() const;
  inline void set_model_type(::artm::PerplexityScoreConfig_Type value);

  // optional string dictionary_name = 4;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 4;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // optional float theta_sparsity_eps = 5 [default = 1e-037];
  inline bool has_theta_sparsity_eps() const;
  inline void clear_theta_sparsity_eps();
  static const int kThetaSparsityEpsFieldNumber = 5;
  inline float theta_sparsity_eps() const;
  inline void set_theta_sparsity_eps(float value);

  // repeated string theta_sparsity_topic_name = 6;
  inline int theta_sparsity_topic_name_size() const;
  inline void clear_theta_sparsity_topic_name();
  static const int kThetaSparsityTopicNameFieldNumber = 6;
  inline const ::std::string& theta_sparsity_topic_name(int index) const;
  inline ::std::string* mutable_theta_sparsity_topic_name(int index);
  inline void set_theta_sparsity_topic_name(int index, const ::std::string& value);
  inline void set_theta_sparsity_topic_name(int index, const char* value);
  inline void set_theta_sparsity_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_theta_sparsity_topic_name();
  inline void add_theta_sparsity_topic_name(const ::std::string& value);
  inline void add_theta_sparsity_topic_name(const char* value);
  inline void add_theta_sparsity_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& theta_sparsity_topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_theta_sparsity_topic_name();

  // repeated string class_id = 7;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 7;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // @@protoc_insertion_point(class_scope:artm.PerplexityScoreConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_model_type();
  inline void clear_has_model_type();
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();
  inline void set_has_theta_sparsity_eps();
  inline void clear_has_theta_sparsity_eps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::std::string* dictionary_name_;
  int model_type_;
  float theta_sparsity_eps_;
  ::google::protobuf::RepeatedPtrField< ::std::string> theta_sparsity_topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PerplexityScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class PerplexityScore : public ::google::protobuf::Message {
 public:
  PerplexityScore();
  virtual ~PerplexityScore();

  PerplexityScore(const PerplexityScore& from);

  inline PerplexityScore& operator=(const PerplexityScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerplexityScore& default_instance();

  void Swap(PerplexityScore* other);

  // implements Message ----------------------------------------------

  PerplexityScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerplexityScore& from);
  void MergeFrom(const PerplexityScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // optional double raw = 2;
  inline bool has_raw() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 2;
  inline double raw() const;
  inline void set_raw(double value);

  // optional double normalizer = 3;
  inline bool has_normalizer() const;
  inline void clear_normalizer();
  static const int kNormalizerFieldNumber = 3;
  inline double normalizer() const;
  inline void set_normalizer(double value);

  // optional int32 zero_words = 4;
  inline bool has_zero_words() const;
  inline void clear_zero_words();
  static const int kZeroWordsFieldNumber = 4;
  inline ::google::protobuf::int32 zero_words() const;
  inline void set_zero_words(::google::protobuf::int32 value);

  // optional double theta_sparsity_value = 5;
  inline bool has_theta_sparsity_value() const;
  inline void clear_theta_sparsity_value();
  static const int kThetaSparsityValueFieldNumber = 5;
  inline double theta_sparsity_value() const;
  inline void set_theta_sparsity_value(double value);

  // optional int32 theta_sparsity_zero_topics = 6;
  inline bool has_theta_sparsity_zero_topics() const;
  inline void clear_theta_sparsity_zero_topics();
  static const int kThetaSparsityZeroTopicsFieldNumber = 6;
  inline ::google::protobuf::int32 theta_sparsity_zero_topics() const;
  inline void set_theta_sparsity_zero_topics(::google::protobuf::int32 value);

  // optional int32 theta_sparsity_total_topics = 7;
  inline bool has_theta_sparsity_total_topics() const;
  inline void clear_theta_sparsity_total_topics();
  static const int kThetaSparsityTotalTopicsFieldNumber = 7;
  inline ::google::protobuf::int32 theta_sparsity_total_topics() const;
  inline void set_theta_sparsity_total_topics(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.PerplexityScore)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_raw();
  inline void clear_has_raw();
  inline void set_has_normalizer();
  inline void clear_has_normalizer();
  inline void set_has_zero_words();
  inline void clear_has_zero_words();
  inline void set_has_theta_sparsity_value();
  inline void clear_has_theta_sparsity_value();
  inline void set_has_theta_sparsity_zero_topics();
  inline void clear_has_theta_sparsity_zero_topics();
  inline void set_has_theta_sparsity_total_topics();
  inline void clear_has_theta_sparsity_total_topics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;
  double raw_;
  double normalizer_;
  double theta_sparsity_value_;
  ::google::protobuf::int32 zero_words_;
  ::google::protobuf::int32 theta_sparsity_zero_topics_;
  ::google::protobuf::int32 theta_sparsity_total_topics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PerplexityScore* default_instance_;
};
// -------------------------------------------------------------------

class SparsityThetaScoreConfig : public ::google::protobuf::Message {
 public:
  SparsityThetaScoreConfig();
  virtual ~SparsityThetaScoreConfig();

  SparsityThetaScoreConfig(const SparsityThetaScoreConfig& from);

  inline SparsityThetaScoreConfig& operator=(const SparsityThetaScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparsityThetaScoreConfig& default_instance();

  void Swap(SparsityThetaScoreConfig* other);

  // implements Message ----------------------------------------------

  SparsityThetaScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparsityThetaScoreConfig& from);
  void MergeFrom(const SparsityThetaScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string field_name = 1 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 2 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 2;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // optional float eps = 3 [default = 1e-037];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 3;
  inline float eps() const;
  inline void set_eps(float value);

  // repeated string topic_name = 4;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 4;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // @@protoc_insertion_point(class_scope:artm.SparsityThetaScoreConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_eps();
  inline void clear_has_eps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  float eps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SparsityThetaScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class SparsityThetaScore : public ::google::protobuf::Message {
 public:
  SparsityThetaScore();
  virtual ~SparsityThetaScore();

  SparsityThetaScore(const SparsityThetaScore& from);

  inline SparsityThetaScore& operator=(const SparsityThetaScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparsityThetaScore& default_instance();

  void Swap(SparsityThetaScore* other);

  // implements Message ----------------------------------------------

  SparsityThetaScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparsityThetaScore& from);
  void MergeFrom(const SparsityThetaScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // optional int32 zero_topics = 2;
  inline bool has_zero_topics() const;
  inline void clear_zero_topics();
  static const int kZeroTopicsFieldNumber = 2;
  inline ::google::protobuf::int32 zero_topics() const;
  inline void set_zero_topics(::google::protobuf::int32 value);

  // optional int32 total_topics = 3;
  inline bool has_total_topics() const;
  inline void clear_total_topics();
  static const int kTotalTopicsFieldNumber = 3;
  inline ::google::protobuf::int32 total_topics() const;
  inline void set_total_topics(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.SparsityThetaScore)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_zero_topics();
  inline void clear_has_zero_topics();
  inline void set_has_total_topics();
  inline void clear_has_total_topics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;
  ::google::protobuf::int32 zero_topics_;
  ::google::protobuf::int32 total_topics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SparsityThetaScore* default_instance_;
};
// -------------------------------------------------------------------

class SparsityPhiScoreConfig : public ::google::protobuf::Message {
 public:
  SparsityPhiScoreConfig();
  virtual ~SparsityPhiScoreConfig();

  SparsityPhiScoreConfig(const SparsityPhiScoreConfig& from);

  inline SparsityPhiScoreConfig& operator=(const SparsityPhiScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparsityPhiScoreConfig& default_instance();

  void Swap(SparsityPhiScoreConfig* other);

  // implements Message ----------------------------------------------

  SparsityPhiScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparsityPhiScoreConfig& from);
  void MergeFrom(const SparsityPhiScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float eps = 1 [default = 1e-037];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 1;
  inline float eps() const;
  inline void set_eps(float value);

  // optional string class_id = 2 [default = "@default_class"];
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const char* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // repeated string topic_name = 3;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 3;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // @@protoc_insertion_point(class_scope:artm.SparsityPhiScoreConfig)
 private:
  inline void set_has_eps();
  inline void clear_has_eps();
  inline void set_has_class_id();
  inline void clear_has_class_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* class_id_;
  static ::std::string* _default_class_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  float eps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SparsityPhiScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class SparsityPhiScore : public ::google::protobuf::Message {
 public:
  SparsityPhiScore();
  virtual ~SparsityPhiScore();

  SparsityPhiScore(const SparsityPhiScore& from);

  inline SparsityPhiScore& operator=(const SparsityPhiScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparsityPhiScore& default_instance();

  void Swap(SparsityPhiScore* other);

  // implements Message ----------------------------------------------

  SparsityPhiScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparsityPhiScore& from);
  void MergeFrom(const SparsityPhiScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // optional int32 zero_tokens = 2;
  inline bool has_zero_tokens() const;
  inline void clear_zero_tokens();
  static const int kZeroTokensFieldNumber = 2;
  inline ::google::protobuf::int32 zero_tokens() const;
  inline void set_zero_tokens(::google::protobuf::int32 value);

  // optional int32 total_tokens = 3;
  inline bool has_total_tokens() const;
  inline void clear_total_tokens();
  static const int kTotalTokensFieldNumber = 3;
  inline ::google::protobuf::int32 total_tokens() const;
  inline void set_total_tokens(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.SparsityPhiScore)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_zero_tokens();
  inline void clear_has_zero_tokens();
  inline void set_has_total_tokens();
  inline void clear_has_total_tokens();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;
  ::google::protobuf::int32 zero_tokens_;
  ::google::protobuf::int32 total_tokens_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SparsityPhiScore* default_instance_;
};
// -------------------------------------------------------------------

class ItemsProcessedScoreConfig : public ::google::protobuf::Message {
 public:
  ItemsProcessedScoreConfig();
  virtual ~ItemsProcessedScoreConfig();

  ItemsProcessedScoreConfig(const ItemsProcessedScoreConfig& from);

  inline ItemsProcessedScoreConfig& operator=(const ItemsProcessedScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemsProcessedScoreConfig& default_instance();

  void Swap(ItemsProcessedScoreConfig* other);

  // implements Message ----------------------------------------------

  ItemsProcessedScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemsProcessedScoreConfig& from);
  void MergeFrom(const ItemsProcessedScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string field_name = 1 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 2 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 2;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // @@protoc_insertion_point(class_scope:artm.ItemsProcessedScoreConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ItemsProcessedScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class ItemsProcessedScore : public ::google::protobuf::Message {
 public:
  ItemsProcessedScore();
  virtual ~ItemsProcessedScore();

  ItemsProcessedScore(const ItemsProcessedScore& from);

  inline ItemsProcessedScore& operator=(const ItemsProcessedScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemsProcessedScore& default_instance();

  void Swap(ItemsProcessedScore* other);

  // implements Message ----------------------------------------------

  ItemsProcessedScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemsProcessedScore& from);
  void MergeFrom(const ItemsProcessedScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.ItemsProcessedScore)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ItemsProcessedScore* default_instance_;
};
// -------------------------------------------------------------------

class TopTokensScoreConfig : public ::google::protobuf::Message {
 public:
  TopTokensScoreConfig();
  virtual ~TopTokensScoreConfig();

  TopTokensScoreConfig(const TopTokensScoreConfig& from);

  inline TopTokensScoreConfig& operator=(const TopTokensScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopTokensScoreConfig& default_instance();

  void Swap(TopTokensScoreConfig* other);

  // implements Message ----------------------------------------------

  TopTokensScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopTokensScoreConfig& from);
  void MergeFrom(const TopTokensScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 num_tokens = 1 [default = 10];
  inline bool has_num_tokens() const;
  inline void clear_num_tokens();
  static const int kNumTokensFieldNumber = 1;
  inline ::google::protobuf::int32 num_tokens() const;
  inline void set_num_tokens(::google::protobuf::int32 value);

  // optional string class_id = 2 [default = "@default_class"];
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const char* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // repeated string topic_name = 3;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 3;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // optional string cooccurrence_dictionary_name = 4;
  inline bool has_cooccurrence_dictionary_name() const;
  inline void clear_cooccurrence_dictionary_name();
  static const int kCooccurrenceDictionaryNameFieldNumber = 4;
  inline const ::std::string& cooccurrence_dictionary_name() const;
  inline void set_cooccurrence_dictionary_name(const ::std::string& value);
  inline void set_cooccurrence_dictionary_name(const char* value);
  inline void set_cooccurrence_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_cooccurrence_dictionary_name();
  inline ::std::string* release_cooccurrence_dictionary_name();
  inline void set_allocated_cooccurrence_dictionary_name(::std::string* cooccurrence_dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.TopTokensScoreConfig)
 private:
  inline void set_has_num_tokens();
  inline void clear_has_num_tokens();
  inline void set_has_class_id();
  inline void clear_has_class_id();
  inline void set_has_cooccurrence_dictionary_name();
  inline void clear_has_cooccurrence_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* class_id_;
  static ::std::string* _default_class_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::std::string* cooccurrence_dictionary_name_;
  ::google::protobuf::int32 num_tokens_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopTokensScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class TopTokensScore : public ::google::protobuf::Message {
 public:
  TopTokensScore();
  virtual ~TopTokensScore();

  TopTokensScore(const TopTokensScore& from);

  inline TopTokensScore& operator=(const TopTokensScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopTokensScore& default_instance();

  void Swap(TopTokensScore* other);

  // implements Message ----------------------------------------------

  TopTokensScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopTokensScore& from);
  void MergeFrom(const TopTokensScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 num_entries = 1;
  inline bool has_num_entries() const;
  inline void clear_num_entries();
  static const int kNumEntriesFieldNumber = 1;
  inline ::google::protobuf::int32 num_entries() const;
  inline void set_num_entries(::google::protobuf::int32 value);

  // repeated string topic_name = 2;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 2;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated int32 topic_index = 3;
  inline int topic_index_size() const;
  inline void clear_topic_index();
  static const int kTopicIndexFieldNumber = 3;
  inline ::google::protobuf::int32 topic_index(int index) const;
  inline void set_topic_index(int index, ::google::protobuf::int32 value);
  inline void add_topic_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      topic_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_topic_index();

  // repeated string token = 4;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated float weight = 5;
  inline int weight_size() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 5;
  inline float weight(int index) const;
  inline void set_weight(int index, float value);
  inline void add_weight(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      weight() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_weight();

  // optional .artm.FloatArray coherence = 6;
  inline bool has_coherence() const;
  inline void clear_coherence();
  static const int kCoherenceFieldNumber = 6;
  inline const ::artm::FloatArray& coherence() const;
  inline ::artm::FloatArray* mutable_coherence();
  inline ::artm::FloatArray* release_coherence();
  inline void set_allocated_coherence(::artm::FloatArray* coherence);

  // optional float average_coherence = 7;
  inline bool has_average_coherence() const;
  inline void clear_average_coherence();
  static const int kAverageCoherenceFieldNumber = 7;
  inline float average_coherence() const;
  inline void set_average_coherence(float value);

  // @@protoc_insertion_point(class_scope:artm.TopTokensScore)
 private:
  inline void set_has_num_entries();
  inline void clear_has_num_entries();
  inline void set_has_coherence();
  inline void clear_has_coherence();
  inline void set_has_average_coherence();
  inline void clear_has_average_coherence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > topic_index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::int32 num_entries_;
  float average_coherence_;
  ::google::protobuf::RepeatedField< float > weight_;
  ::artm::FloatArray* coherence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopTokensScore* default_instance_;
};
// -------------------------------------------------------------------

class ThetaSnippetScoreConfig : public ::google::protobuf::Message {
 public:
  ThetaSnippetScoreConfig();
  virtual ~ThetaSnippetScoreConfig();

  ThetaSnippetScoreConfig(const ThetaSnippetScoreConfig& from);

  inline ThetaSnippetScoreConfig& operator=(const ThetaSnippetScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThetaSnippetScoreConfig& default_instance();

  void Swap(ThetaSnippetScoreConfig* other);

  // implements Message ----------------------------------------------

  ThetaSnippetScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThetaSnippetScoreConfig& from);
  void MergeFrom(const ThetaSnippetScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string field_name = 1 [default = "@body"];
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const char* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // optional string stream_name = 2 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 2;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // repeated int32 item_id = 3 [packed = true];
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::int32 value);
  inline void add_item_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_id();

  // optional int32 item_count = 4 [default = 10];
  inline bool has_item_count() const;
  inline void clear_item_count();
  static const int kItemCountFieldNumber = 4;
  inline ::google::protobuf::int32 item_count() const;
  inline void set_item_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.ThetaSnippetScoreConfig)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_item_count();
  inline void clear_has_item_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_name_;
  static ::std::string* _default_field_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_id_;
  mutable int _item_id_cached_byte_size_;
  ::google::protobuf::int32 item_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ThetaSnippetScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class ThetaSnippetScore : public ::google::protobuf::Message {
 public:
  ThetaSnippetScore();
  virtual ~ThetaSnippetScore();

  ThetaSnippetScore(const ThetaSnippetScore& from);

  inline ThetaSnippetScore& operator=(const ThetaSnippetScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThetaSnippetScore& default_instance();

  void Swap(ThetaSnippetScore* other);

  // implements Message ----------------------------------------------

  ThetaSnippetScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThetaSnippetScore& from);
  void MergeFrom(const ThetaSnippetScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 item_id = 1;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::int32 value);
  inline void add_item_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_id();

  // repeated .artm.FloatArray values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::artm::FloatArray& values(int index) const;
  inline ::artm::FloatArray* mutable_values(int index);
  inline ::artm::FloatArray* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:artm.ThetaSnippetScore)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_id_;
  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ThetaSnippetScore* default_instance_;
};
// -------------------------------------------------------------------

class TopicKernelScoreConfig : public ::google::protobuf::Message {
 public:
  TopicKernelScoreConfig();
  virtual ~TopicKernelScoreConfig();

  TopicKernelScoreConfig(const TopicKernelScoreConfig& from);

  inline TopicKernelScoreConfig& operator=(const TopicKernelScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicKernelScoreConfig& default_instance();

  void Swap(TopicKernelScoreConfig* other);

  // implements Message ----------------------------------------------

  TopicKernelScoreConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicKernelScoreConfig& from);
  void MergeFrom(const TopicKernelScoreConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float eps = 1 [default = 1e-037];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 1;
  inline float eps() const;
  inline void set_eps(float value);

  // optional string class_id = 2 [default = "@default_class"];
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 2;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const char* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // repeated string topic_name = 3;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 3;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // optional double probability_mass_threshold = 4 [default = 0.1];
  inline bool has_probability_mass_threshold() const;
  inline void clear_probability_mass_threshold();
  static const int kProbabilityMassThresholdFieldNumber = 4;
  inline double probability_mass_threshold() const;
  inline void set_probability_mass_threshold(double value);

  // optional string cooccurrence_dictionary_name = 5;
  inline bool has_cooccurrence_dictionary_name() const;
  inline void clear_cooccurrence_dictionary_name();
  static const int kCooccurrenceDictionaryNameFieldNumber = 5;
  inline const ::std::string& cooccurrence_dictionary_name() const;
  inline void set_cooccurrence_dictionary_name(const ::std::string& value);
  inline void set_cooccurrence_dictionary_name(const char* value);
  inline void set_cooccurrence_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_cooccurrence_dictionary_name();
  inline ::std::string* release_cooccurrence_dictionary_name();
  inline void set_allocated_cooccurrence_dictionary_name(::std::string* cooccurrence_dictionary_name);

  // @@protoc_insertion_point(class_scope:artm.TopicKernelScoreConfig)
 private:
  inline void set_has_eps();
  inline void clear_has_eps();
  inline void set_has_class_id();
  inline void clear_has_class_id();
  inline void set_has_probability_mass_threshold();
  inline void clear_has_probability_mass_threshold();
  inline void set_has_cooccurrence_dictionary_name();
  inline void clear_has_cooccurrence_dictionary_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* class_id_;
  static ::std::string* _default_class_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  double probability_mass_threshold_;
  ::std::string* cooccurrence_dictionary_name_;
  float eps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopicKernelScoreConfig* default_instance_;
};
// -------------------------------------------------------------------

class TopicKernelScore : public ::google::protobuf::Message {
 public:
  TopicKernelScore();
  virtual ~TopicKernelScore();

  TopicKernelScore(const TopicKernelScore& from);

  inline TopicKernelScore& operator=(const TopicKernelScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicKernelScore& default_instance();

  void Swap(TopicKernelScore* other);

  // implements Message ----------------------------------------------

  TopicKernelScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicKernelScore& from);
  void MergeFrom(const TopicKernelScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .artm.DoubleArray kernel_size = 1;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 1;
  inline const ::artm::DoubleArray& kernel_size() const;
  inline ::artm::DoubleArray* mutable_kernel_size();
  inline ::artm::DoubleArray* release_kernel_size();
  inline void set_allocated_kernel_size(::artm::DoubleArray* kernel_size);

  // optional .artm.DoubleArray kernel_purity = 2;
  inline bool has_kernel_purity() const;
  inline void clear_kernel_purity();
  static const int kKernelPurityFieldNumber = 2;
  inline const ::artm::DoubleArray& kernel_purity() const;
  inline ::artm::DoubleArray* mutable_kernel_purity();
  inline ::artm::DoubleArray* release_kernel_purity();
  inline void set_allocated_kernel_purity(::artm::DoubleArray* kernel_purity);

  // optional .artm.DoubleArray kernel_contrast = 3;
  inline bool has_kernel_contrast() const;
  inline void clear_kernel_contrast();
  static const int kKernelContrastFieldNumber = 3;
  inline const ::artm::DoubleArray& kernel_contrast() const;
  inline ::artm::DoubleArray* mutable_kernel_contrast();
  inline ::artm::DoubleArray* release_kernel_contrast();
  inline void set_allocated_kernel_contrast(::artm::DoubleArray* kernel_contrast);

  // optional double average_kernel_size = 4;
  inline bool has_average_kernel_size() const;
  inline void clear_average_kernel_size();
  static const int kAverageKernelSizeFieldNumber = 4;
  inline double average_kernel_size() const;
  inline void set_average_kernel_size(double value);

  // optional double average_kernel_purity = 5;
  inline bool has_average_kernel_purity() const;
  inline void clear_average_kernel_purity();
  static const int kAverageKernelPurityFieldNumber = 5;
  inline double average_kernel_purity() const;
  inline void set_average_kernel_purity(double value);

  // optional double average_kernel_contrast = 6;
  inline bool has_average_kernel_contrast() const;
  inline void clear_average_kernel_contrast();
  static const int kAverageKernelContrastFieldNumber = 6;
  inline double average_kernel_contrast() const;
  inline void set_average_kernel_contrast(double value);

  // optional .artm.DoubleArray coherence = 7;
  inline bool has_coherence() const;
  inline void clear_coherence();
  static const int kCoherenceFieldNumber = 7;
  inline const ::artm::DoubleArray& coherence() const;
  inline ::artm::DoubleArray* mutable_coherence();
  inline ::artm::DoubleArray* release_coherence();
  inline void set_allocated_coherence(::artm::DoubleArray* coherence);

  // optional float average_coherence = 8;
  inline bool has_average_coherence() const;
  inline void clear_average_coherence();
  static const int kAverageCoherenceFieldNumber = 8;
  inline float average_coherence() const;
  inline void set_average_coherence(float value);

  // repeated .artm.StringArray kernel_tokens = 9;
  inline int kernel_tokens_size() const;
  inline void clear_kernel_tokens();
  static const int kKernelTokensFieldNumber = 9;
  inline const ::artm::StringArray& kernel_tokens(int index) const;
  inline ::artm::StringArray* mutable_kernel_tokens(int index);
  inline ::artm::StringArray* add_kernel_tokens();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::StringArray >&
      kernel_tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::StringArray >*
      mutable_kernel_tokens();

  // @@protoc_insertion_point(class_scope:artm.TopicKernelScore)
 private:
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_kernel_purity();
  inline void clear_has_kernel_purity();
  inline void set_has_kernel_contrast();
  inline void clear_has_kernel_contrast();
  inline void set_has_average_kernel_size();
  inline void clear_has_average_kernel_size();
  inline void set_has_average_kernel_purity();
  inline void clear_has_average_kernel_purity();
  inline void set_has_average_kernel_contrast();
  inline void clear_has_average_kernel_contrast();
  inline void set_has_coherence();
  inline void clear_has_coherence();
  inline void set_has_average_coherence();
  inline void clear_has_average_coherence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::artm::DoubleArray* kernel_size_;
  ::artm::DoubleArray* kernel_purity_;
  ::artm::DoubleArray* kernel_contrast_;
  double average_kernel_size_;
  double average_kernel_purity_;
  double average_kernel_contrast_;
  ::artm::DoubleArray* coherence_;
  ::google::protobuf::RepeatedPtrField< ::artm::StringArray > kernel_tokens_;
  float average_coherence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopicKernelScore* default_instance_;
};
// -------------------------------------------------------------------

class TopicModel_TopicModelInternals : public ::google::protobuf::Message {
 public:
  TopicModel_TopicModelInternals();
  virtual ~TopicModel_TopicModelInternals();

  TopicModel_TopicModelInternals(const TopicModel_TopicModelInternals& from);

  inline TopicModel_TopicModelInternals& operator=(const TopicModel_TopicModelInternals& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicModel_TopicModelInternals& default_instance();

  void Swap(TopicModel_TopicModelInternals* other);

  // implements Message ----------------------------------------------

  TopicModel_TopicModelInternals* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicModel_TopicModelInternals& from);
  void MergeFrom(const TopicModel_TopicModelInternals& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .artm.FloatArray n_wt = 1;
  inline int n_wt_size() const;
  inline void clear_n_wt();
  static const int kNWtFieldNumber = 1;
  inline const ::artm::FloatArray& n_wt(int index) const;
  inline ::artm::FloatArray* mutable_n_wt(int index);
  inline ::artm::FloatArray* add_n_wt();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      n_wt() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_n_wt();

  // @@protoc_insertion_point(class_scope:artm.TopicModel.TopicModelInternals)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > n_wt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopicModel_TopicModelInternals* default_instance_;
};
// -------------------------------------------------------------------

class TopicModel : public ::google::protobuf::Message {
 public:
  TopicModel();
  virtual ~TopicModel();

  TopicModel(const TopicModel& from);

  inline TopicModel& operator=(const TopicModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicModel& default_instance();

  void Swap(TopicModel* other);

  // implements Message ----------------------------------------------

  TopicModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicModel& from);
  void MergeFrom(const TopicModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TopicModel_TopicModelInternals TopicModelInternals;

  typedef TopicModel_OperationType OperationType;
  static const OperationType Initialize = TopicModel_OperationType_Initialize;
  static const OperationType Increment = TopicModel_OperationType_Increment;
  static const OperationType Overwrite = TopicModel_OperationType_Overwrite;
  static const OperationType Remove = TopicModel_OperationType_Remove;
  static const OperationType Ignore = TopicModel_OperationType_Ignore;
  static inline bool OperationType_IsValid(int value) {
    return TopicModel_OperationType_IsValid(value);
  }
  static const OperationType OperationType_MIN =
    TopicModel_OperationType_OperationType_MIN;
  static const OperationType OperationType_MAX =
    TopicModel_OperationType_OperationType_MAX;
  static const int OperationType_ARRAYSIZE =
    TopicModel_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperationType_descriptor() {
    return TopicModel_OperationType_descriptor();
  }
  static inline const ::std::string& OperationType_Name(OperationType value) {
    return TopicModel_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(const ::std::string& name,
      OperationType* value) {
    return TopicModel_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "@model"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 topics_count = 2;
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 2;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // repeated string topic_name = 3;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 3;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated string token = 4;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated .artm.FloatArray token_weights = 5;
  inline int token_weights_size() const;
  inline void clear_token_weights();
  static const int kTokenWeightsFieldNumber = 5;
  inline const ::artm::FloatArray& token_weights(int index) const;
  inline ::artm::FloatArray* mutable_token_weights(int index);
  inline ::artm::FloatArray* add_token_weights();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      token_weights() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_token_weights();

  // repeated string class_id = 6;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 6;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // optional bytes internals = 7;
  inline bool has_internals() const;
  inline void clear_internals();
  static const int kInternalsFieldNumber = 7;
  inline const ::std::string& internals() const;
  inline void set_internals(const ::std::string& value);
  inline void set_internals(const char* value);
  inline void set_internals(const void* value, size_t size);
  inline ::std::string* mutable_internals();
  inline ::std::string* release_internals();
  inline void set_allocated_internals(::std::string* internals);

  // repeated .artm.IntArray topic_index = 8;
  inline int topic_index_size() const;
  inline void clear_topic_index();
  static const int kTopicIndexFieldNumber = 8;
  inline const ::artm::IntArray& topic_index(int index) const;
  inline ::artm::IntArray* mutable_topic_index(int index);
  inline ::artm::IntArray* add_topic_index();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::IntArray >&
      topic_index() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::IntArray >*
      mutable_topic_index();

  // repeated .artm.TopicModel.OperationType operation_type = 9;
  inline int operation_type_size() const;
  inline void clear_operation_type();
  static const int kOperationTypeFieldNumber = 9;
  inline ::artm::TopicModel_OperationType operation_type(int index) const;
  inline void set_operation_type(int index, ::artm::TopicModel_OperationType value);
  inline void add_operation_type(::artm::TopicModel_OperationType value);
  inline const ::google::protobuf::RepeatedField<int>& operation_type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_operation_type();

  // @@protoc_insertion_point(class_scope:artm.TopicModel)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_topics_count();
  inline void clear_has_topics_count();
  inline void set_has_internals();
  inline void clear_has_internals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > token_weights_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  ::std::string* internals_;
  ::google::protobuf::RepeatedPtrField< ::artm::IntArray > topic_index_;
  ::google::protobuf::RepeatedField<int> operation_type_;
  ::google::protobuf::int32 topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static TopicModel* default_instance_;
};
// -------------------------------------------------------------------

class ThetaMatrix : public ::google::protobuf::Message {
 public:
  ThetaMatrix();
  virtual ~ThetaMatrix();

  ThetaMatrix(const ThetaMatrix& from);

  inline ThetaMatrix& operator=(const ThetaMatrix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThetaMatrix& default_instance();

  void Swap(ThetaMatrix* other);

  // implements Message ----------------------------------------------

  ThetaMatrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThetaMatrix& from);
  void MergeFrom(const ThetaMatrix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model_name = 1 [default = "@model"];
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // repeated int32 item_id = 2;
  inline int item_id_size() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 item_id(int index) const;
  inline void set_item_id(int index, ::google::protobuf::int32 value);
  inline void add_item_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_id();

  // repeated .artm.FloatArray item_weights = 3;
  inline int item_weights_size() const;
  inline void clear_item_weights();
  static const int kItemWeightsFieldNumber = 3;
  inline const ::artm::FloatArray& item_weights(int index) const;
  inline ::artm::FloatArray* mutable_item_weights(int index);
  inline ::artm::FloatArray* add_item_weights();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
      item_weights() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
      mutable_item_weights();

  // repeated string topic_name = 4;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 4;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // optional int32 topics_count = 5;
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 5;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // repeated string item_title = 6;
  inline int item_title_size() const;
  inline void clear_item_title();
  static const int kItemTitleFieldNumber = 6;
  inline const ::std::string& item_title(int index) const;
  inline ::std::string* mutable_item_title(int index);
  inline void set_item_title(int index, const ::std::string& value);
  inline void set_item_title(int index, const char* value);
  inline void set_item_title(int index, const char* value, size_t size);
  inline ::std::string* add_item_title();
  inline void add_item_title(const ::std::string& value);
  inline void add_item_title(const char* value);
  inline void add_item_title(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item_title() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item_title();

  // repeated .artm.IntArray topic_index = 7;
  inline int topic_index_size() const;
  inline void clear_topic_index();
  static const int kTopicIndexFieldNumber = 7;
  inline const ::artm::IntArray& topic_index(int index) const;
  inline ::artm::IntArray* mutable_topic_index(int index);
  inline ::artm::IntArray* add_topic_index();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::IntArray >&
      topic_index() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::IntArray >*
      mutable_topic_index();

  // @@protoc_insertion_point(class_scope:artm.ThetaMatrix)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_topics_count();
  inline void clear_has_topics_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  static ::std::string* _default_model_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_id_;
  ::google::protobuf::RepeatedPtrField< ::artm::FloatArray > item_weights_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_title_;
  ::google::protobuf::RepeatedPtrField< ::artm::IntArray > topic_index_;
  ::google::protobuf::int32 topics_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ThetaMatrix* default_instance_;
};
// -------------------------------------------------------------------

class CollectionParserConfig : public ::google::protobuf::Message {
 public:
  CollectionParserConfig();
  virtual ~CollectionParserConfig();

  CollectionParserConfig(const CollectionParserConfig& from);

  inline CollectionParserConfig& operator=(const CollectionParserConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionParserConfig& default_instance();

  void Swap(CollectionParserConfig* other);

  // implements Message ----------------------------------------------

  CollectionParserConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionParserConfig& from);
  void MergeFrom(const CollectionParserConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CollectionParserConfig_Format Format;
  static const Format BagOfWordsUci = CollectionParserConfig_Format_BagOfWordsUci;
  static const Format MatrixMarket = CollectionParserConfig_Format_MatrixMarket;
  static const Format VowpalWabbit = CollectionParserConfig_Format_VowpalWabbit;
  static inline bool Format_IsValid(int value) {
    return CollectionParserConfig_Format_IsValid(value);
  }
  static const Format Format_MIN =
    CollectionParserConfig_Format_Format_MIN;
  static const Format Format_MAX =
    CollectionParserConfig_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    CollectionParserConfig_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Format_descriptor() {
    return CollectionParserConfig_Format_descriptor();
  }
  static inline const ::std::string& Format_Name(Format value) {
    return CollectionParserConfig_Format_Name(value);
  }
  static inline bool Format_Parse(const ::std::string& name,
      Format* value) {
    return CollectionParserConfig_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .artm.CollectionParserConfig.Format format = 1 [default = BagOfWordsUci];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline ::artm::CollectionParserConfig_Format format() const;
  inline void set_format(::artm::CollectionParserConfig_Format value);

  // optional string docword_file_path = 2;
  inline bool has_docword_file_path() const;
  inline void clear_docword_file_path();
  static const int kDocwordFilePathFieldNumber = 2;
  inline const ::std::string& docword_file_path() const;
  inline void set_docword_file_path(const ::std::string& value);
  inline void set_docword_file_path(const char* value);
  inline void set_docword_file_path(const char* value, size_t size);
  inline ::std::string* mutable_docword_file_path();
  inline ::std::string* release_docword_file_path();
  inline void set_allocated_docword_file_path(::std::string* docword_file_path);

  // optional string vocab_file_path = 3;
  inline bool has_vocab_file_path() const;
  inline void clear_vocab_file_path();
  static const int kVocabFilePathFieldNumber = 3;
  inline const ::std::string& vocab_file_path() const;
  inline void set_vocab_file_path(const ::std::string& value);
  inline void set_vocab_file_path(const char* value);
  inline void set_vocab_file_path(const char* value, size_t size);
  inline ::std::string* mutable_vocab_file_path();
  inline ::std::string* release_vocab_file_path();
  inline void set_allocated_vocab_file_path(::std::string* vocab_file_path);

  // optional string target_folder = 4;
  inline bool has_target_folder() const;
  inline void clear_target_folder();
  static const int kTargetFolderFieldNumber = 4;
  inline const ::std::string& target_folder() const;
  inline void set_target_folder(const ::std::string& value);
  inline void set_target_folder(const char* value);
  inline void set_target_folder(const char* value, size_t size);
  inline ::std::string* mutable_target_folder();
  inline ::std::string* release_target_folder();
  inline void set_allocated_target_folder(::std::string* target_folder);

  // optional string dictionary_file_name = 5;
  inline bool has_dictionary_file_name() const;
  inline void clear_dictionary_file_name();
  static const int kDictionaryFileNameFieldNumber = 5;
  inline const ::std::string& dictionary_file_name() const;
  inline void set_dictionary_file_name(const ::std::string& value);
  inline void set_dictionary_file_name(const char* value);
  inline void set_dictionary_file_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_file_name();
  inline ::std::string* release_dictionary_file_name();
  inline void set_allocated_dictionary_file_name(::std::string* dictionary_file_name);

  // optional int32 num_items_per_batch = 6 [default = 1000];
  inline bool has_num_items_per_batch() const;
  inline void clear_num_items_per_batch();
  static const int kNumItemsPerBatchFieldNumber = 6;
  inline ::google::protobuf::int32 num_items_per_batch() const;
  inline void set_num_items_per_batch(::google::protobuf::int32 value);

  // repeated string cooccurrence_token = 7;
  inline int cooccurrence_token_size() const;
  inline void clear_cooccurrence_token();
  static const int kCooccurrenceTokenFieldNumber = 7;
  inline const ::std::string& cooccurrence_token(int index) const;
  inline ::std::string* mutable_cooccurrence_token(int index);
  inline void set_cooccurrence_token(int index, const ::std::string& value);
  inline void set_cooccurrence_token(int index, const char* value);
  inline void set_cooccurrence_token(int index, const char* value, size_t size);
  inline ::std::string* add_cooccurrence_token();
  inline void add_cooccurrence_token(const ::std::string& value);
  inline void add_cooccurrence_token(const char* value);
  inline void add_cooccurrence_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cooccurrence_token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cooccurrence_token();

  // optional bool use_unity_based_indices = 8 [default = true];
  inline bool has_use_unity_based_indices() const;
  inline void clear_use_unity_based_indices();
  static const int kUseUnityBasedIndicesFieldNumber = 8;
  inline bool use_unity_based_indices() const;
  inline void set_use_unity_based_indices(bool value);

  // optional bool gather_cooc = 9 [default = false];
  inline bool has_gather_cooc() const;
  inline void clear_gather_cooc();
  static const int kGatherCoocFieldNumber = 9;
  inline bool gather_cooc() const;
  inline void set_gather_cooc(bool value);

  // @@protoc_insertion_point(class_scope:artm.CollectionParserConfig)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_docword_file_path();
  inline void clear_has_docword_file_path();
  inline void set_has_vocab_file_path();
  inline void clear_has_vocab_file_path();
  inline void set_has_target_folder();
  inline void clear_has_target_folder();
  inline void set_has_dictionary_file_name();
  inline void clear_has_dictionary_file_name();
  inline void set_has_num_items_per_batch();
  inline void clear_has_num_items_per_batch();
  inline void set_has_use_unity_based_indices();
  inline void clear_has_use_unity_based_indices();
  inline void set_has_gather_cooc();
  inline void clear_has_gather_cooc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* docword_file_path_;
  ::std::string* vocab_file_path_;
  int format_;
  ::google::protobuf::int32 num_items_per_batch_;
  ::std::string* target_folder_;
  ::std::string* dictionary_file_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cooccurrence_token_;
  bool use_unity_based_indices_;
  bool gather_cooc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static CollectionParserConfig* default_instance_;
};
// -------------------------------------------------------------------

class SynchronizeModelArgs : public ::google::protobuf::Message {
 public:
  SynchronizeModelArgs();
  virtual ~SynchronizeModelArgs();

  SynchronizeModelArgs(const SynchronizeModelArgs& from);

  inline SynchronizeModelArgs& operator=(const SynchronizeModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SynchronizeModelArgs& default_instance();

  void Swap(SynchronizeModelArgs* other);

  // implements Message ----------------------------------------------

  SynchronizeModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SynchronizeModelArgs& from);
  void MergeFrom(const SynchronizeModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model_name = 1;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional float decay_weight = 2 [default = 0];
  inline bool has_decay_weight() const;
  inline void clear_decay_weight();
  static const int kDecayWeightFieldNumber = 2;
  inline float decay_weight() const;
  inline void set_decay_weight(float value);

  // optional bool invoke_regularizers = 3 [default = true];
  inline bool has_invoke_regularizers() const;
  inline void clear_invoke_regularizers();
  static const int kInvokeRegularizersFieldNumber = 3;
  inline bool invoke_regularizers() const;
  inline void set_invoke_regularizers(bool value);

  // optional float apply_weight = 4 [default = 1];
  inline bool has_apply_weight() const;
  inline void clear_apply_weight();
  static const int kApplyWeightFieldNumber = 4;
  inline float apply_weight() const;
  inline void set_apply_weight(float value);

  // @@protoc_insertion_point(class_scope:artm.SynchronizeModelArgs)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_decay_weight();
  inline void clear_has_decay_weight();
  inline void set_has_invoke_regularizers();
  inline void clear_has_invoke_regularizers();
  inline void set_has_apply_weight();
  inline void clear_has_apply_weight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  float decay_weight_;
  bool invoke_regularizers_;
  float apply_weight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static SynchronizeModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class InitializeModelArgs_Filter : public ::google::protobuf::Message {
 public:
  InitializeModelArgs_Filter();
  virtual ~InitializeModelArgs_Filter();

  InitializeModelArgs_Filter(const InitializeModelArgs_Filter& from);

  inline InitializeModelArgs_Filter& operator=(const InitializeModelArgs_Filter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeModelArgs_Filter& default_instance();

  void Swap(InitializeModelArgs_Filter* other);

  // implements Message ----------------------------------------------

  InitializeModelArgs_Filter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitializeModelArgs_Filter& from);
  void MergeFrom(const InitializeModelArgs_Filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string class_id = 1;
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 1;
  inline const ::std::string& class_id() const;
  inline void set_class_id(const ::std::string& value);
  inline void set_class_id(const char* value);
  inline void set_class_id(const char* value, size_t size);
  inline ::std::string* mutable_class_id();
  inline ::std::string* release_class_id();
  inline void set_allocated_class_id(::std::string* class_id);

  // optional float min_percentage = 2;
  inline bool has_min_percentage() const;
  inline void clear_min_percentage();
  static const int kMinPercentageFieldNumber = 2;
  inline float min_percentage() const;
  inline void set_min_percentage(float value);

  // optional float max_percentage = 3;
  inline bool has_max_percentage() const;
  inline void clear_max_percentage();
  static const int kMaxPercentageFieldNumber = 3;
  inline float max_percentage() const;
  inline void set_max_percentage(float value);

  // optional int32 min_items = 4;
  inline bool has_min_items() const;
  inline void clear_min_items();
  static const int kMinItemsFieldNumber = 4;
  inline ::google::protobuf::int32 min_items() const;
  inline void set_min_items(::google::protobuf::int32 value);

  // optional int32 max_items = 5;
  inline bool has_max_items() const;
  inline void clear_max_items();
  static const int kMaxItemsFieldNumber = 5;
  inline ::google::protobuf::int32 max_items() const;
  inline void set_max_items(::google::protobuf::int32 value);

  // optional int32 min_total_count = 6;
  inline bool has_min_total_count() const;
  inline void clear_min_total_count();
  static const int kMinTotalCountFieldNumber = 6;
  inline ::google::protobuf::int32 min_total_count() const;
  inline void set_min_total_count(::google::protobuf::int32 value);

  // optional int32 min_one_item_count = 7;
  inline bool has_min_one_item_count() const;
  inline void clear_min_one_item_count();
  static const int kMinOneItemCountFieldNumber = 7;
  inline ::google::protobuf::int32 min_one_item_count() const;
  inline void set_min_one_item_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.InitializeModelArgs.Filter)
 private:
  inline void set_has_class_id();
  inline void clear_has_class_id();
  inline void set_has_min_percentage();
  inline void clear_has_min_percentage();
  inline void set_has_max_percentage();
  inline void clear_has_max_percentage();
  inline void set_has_min_items();
  inline void clear_has_min_items();
  inline void set_has_max_items();
  inline void clear_has_max_items();
  inline void set_has_min_total_count();
  inline void clear_has_min_total_count();
  inline void set_has_min_one_item_count();
  inline void clear_has_min_one_item_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* class_id_;
  float min_percentage_;
  float max_percentage_;
  ::google::protobuf::int32 min_items_;
  ::google::protobuf::int32 max_items_;
  ::google::protobuf::int32 min_total_count_;
  ::google::protobuf::int32 min_one_item_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static InitializeModelArgs_Filter* default_instance_;
};
// -------------------------------------------------------------------

class InitializeModelArgs : public ::google::protobuf::Message {
 public:
  InitializeModelArgs();
  virtual ~InitializeModelArgs();

  InitializeModelArgs(const InitializeModelArgs& from);

  inline InitializeModelArgs& operator=(const InitializeModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeModelArgs& default_instance();

  void Swap(InitializeModelArgs* other);

  // implements Message ----------------------------------------------

  InitializeModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitializeModelArgs& from);
  void MergeFrom(const InitializeModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InitializeModelArgs_Filter Filter;

  typedef InitializeModelArgs_SourceType SourceType;
  static const SourceType Dictionary = InitializeModelArgs_SourceType_Dictionary;
  static const SourceType Batches = InitializeModelArgs_SourceType_Batches;
  static inline bool SourceType_IsValid(int value) {
    return InitializeModelArgs_SourceType_IsValid(value);
  }
  static const SourceType SourceType_MIN =
    InitializeModelArgs_SourceType_SourceType_MIN;
  static const SourceType SourceType_MAX =
    InitializeModelArgs_SourceType_SourceType_MAX;
  static const int SourceType_ARRAYSIZE =
    InitializeModelArgs_SourceType_SourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SourceType_descriptor() {
    return InitializeModelArgs_SourceType_descriptor();
  }
  static inline const ::std::string& SourceType_Name(SourceType value) {
    return InitializeModelArgs_SourceType_Name(value);
  }
  static inline bool SourceType_Parse(const ::std::string& name,
      SourceType* value) {
    return InitializeModelArgs_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string model_name = 1;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional string dictionary_name = 2;
  inline bool has_dictionary_name() const;
  inline void clear_dictionary_name();
  static const int kDictionaryNameFieldNumber = 2;
  inline const ::std::string& dictionary_name() const;
  inline void set_dictionary_name(const ::std::string& value);
  inline void set_dictionary_name(const char* value);
  inline void set_dictionary_name(const char* value, size_t size);
  inline ::std::string* mutable_dictionary_name();
  inline ::std::string* release_dictionary_name();
  inline void set_allocated_dictionary_name(::std::string* dictionary_name);

  // optional .artm.InitializeModelArgs.SourceType source_type = 3 [default = Dictionary];
  inline bool has_source_type() const;
  inline void clear_source_type();
  static const int kSourceTypeFieldNumber = 3;
  inline ::artm::InitializeModelArgs_SourceType source_type() const;
  inline void set_source_type(::artm::InitializeModelArgs_SourceType value);

  // optional string disk_path = 4;
  inline bool has_disk_path() const;
  inline void clear_disk_path();
  static const int kDiskPathFieldNumber = 4;
  inline const ::std::string& disk_path() const;
  inline void set_disk_path(const ::std::string& value);
  inline void set_disk_path(const char* value);
  inline void set_disk_path(const char* value, size_t size);
  inline ::std::string* mutable_disk_path();
  inline ::std::string* release_disk_path();
  inline void set_allocated_disk_path(::std::string* disk_path);

  // repeated .artm.InitializeModelArgs.Filter filter = 5;
  inline int filter_size() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 5;
  inline const ::artm::InitializeModelArgs_Filter& filter(int index) const;
  inline ::artm::InitializeModelArgs_Filter* mutable_filter(int index);
  inline ::artm::InitializeModelArgs_Filter* add_filter();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::InitializeModelArgs_Filter >&
      filter() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::InitializeModelArgs_Filter >*
      mutable_filter();

  // optional int32 topics_count = 6;
  inline bool has_topics_count() const;
  inline void clear_topics_count();
  static const int kTopicsCountFieldNumber = 6;
  inline ::google::protobuf::int32 topics_count() const;
  inline void set_topics_count(::google::protobuf::int32 value);

  // repeated string topic_name = 7;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 7;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // @@protoc_insertion_point(class_scope:artm.InitializeModelArgs)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_dictionary_name();
  inline void clear_has_dictionary_name();
  inline void set_has_source_type();
  inline void clear_has_source_type();
  inline void set_has_disk_path();
  inline void clear_has_disk_path();
  inline void set_has_topics_count();
  inline void clear_has_topics_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  ::std::string* dictionary_name_;
  ::std::string* disk_path_;
  int source_type_;
  ::google::protobuf::int32 topics_count_;
  ::google::protobuf::RepeatedPtrField< ::artm::InitializeModelArgs_Filter > filter_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static InitializeModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class GetTopicModelArgs : public ::google::protobuf::Message {
 public:
  GetTopicModelArgs();
  virtual ~GetTopicModelArgs();

  GetTopicModelArgs(const GetTopicModelArgs& from);

  inline GetTopicModelArgs& operator=(const GetTopicModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTopicModelArgs& default_instance();

  void Swap(GetTopicModelArgs* other);

  // implements Message ----------------------------------------------

  GetTopicModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTopicModelArgs& from);
  void MergeFrom(const GetTopicModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetTopicModelArgs_RequestType RequestType;
  static const RequestType Pwt = GetTopicModelArgs_RequestType_Pwt;
  static const RequestType Nwt = GetTopicModelArgs_RequestType_Nwt;
  static inline bool RequestType_IsValid(int value) {
    return GetTopicModelArgs_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    GetTopicModelArgs_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    GetTopicModelArgs_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    GetTopicModelArgs_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return GetTopicModelArgs_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return GetTopicModelArgs_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return GetTopicModelArgs_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string model_name = 1;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // repeated string topic_name = 2;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 2;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated string token = 3;
  inline int token_size() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token(int index) const;
  inline ::std::string* mutable_token(int index);
  inline void set_token(int index, const ::std::string& value);
  inline void set_token(int index, const char* value);
  inline void set_token(int index, const char* value, size_t size);
  inline ::std::string* add_token();
  inline void add_token(const ::std::string& value);
  inline void add_token(const char* value);
  inline void add_token(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& token() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_token();

  // repeated string class_id = 4;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 4;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // optional bool use_sparse_format = 5;
  inline bool has_use_sparse_format() const;
  inline void clear_use_sparse_format();
  static const int kUseSparseFormatFieldNumber = 5;
  inline bool use_sparse_format() const;
  inline void set_use_sparse_format(bool value);

  // optional float eps = 6 [default = 1e-037];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 6;
  inline float eps() const;
  inline void set_eps(float value);

  // optional .artm.GetTopicModelArgs.RequestType request_type = 7 [default = Pwt];
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 7;
  inline ::artm::GetTopicModelArgs_RequestType request_type() const;
  inline void set_request_type(::artm::GetTopicModelArgs_RequestType value);

  // @@protoc_insertion_point(class_scope:artm.GetTopicModelArgs)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_use_sparse_format();
  inline void clear_has_use_sparse_format();
  inline void set_has_eps();
  inline void clear_has_eps();
  inline void set_has_request_type();
  inline void clear_has_request_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  bool use_sparse_format_;
  float eps_;
  int request_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetTopicModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class GetThetaMatrixArgs : public ::google::protobuf::Message {
 public:
  GetThetaMatrixArgs();
  virtual ~GetThetaMatrixArgs();

  GetThetaMatrixArgs(const GetThetaMatrixArgs& from);

  inline GetThetaMatrixArgs& operator=(const GetThetaMatrixArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetThetaMatrixArgs& default_instance();

  void Swap(GetThetaMatrixArgs* other);

  // implements Message ----------------------------------------------

  GetThetaMatrixArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetThetaMatrixArgs& from);
  void MergeFrom(const GetThetaMatrixArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model_name = 1;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional .artm.Batch batch = 2;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 2;
  inline const ::artm::Batch& batch() const;
  inline ::artm::Batch* mutable_batch();
  inline ::artm::Batch* release_batch();
  inline void set_allocated_batch(::artm::Batch* batch);

  // repeated string topic_name = 3;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 3;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // repeated int32 topic_index = 4;
  inline int topic_index_size() const;
  inline void clear_topic_index();
  static const int kTopicIndexFieldNumber = 4;
  inline ::google::protobuf::int32 topic_index(int index) const;
  inline void set_topic_index(int index, ::google::protobuf::int32 value);
  inline void add_topic_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      topic_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_topic_index();

  // optional bool clean_cache = 5 [default = false];
  inline bool has_clean_cache() const;
  inline void clear_clean_cache();
  static const int kCleanCacheFieldNumber = 5;
  inline bool clean_cache() const;
  inline void set_clean_cache(bool value);

  // optional bool use_sparse_format = 6;
  inline bool has_use_sparse_format() const;
  inline void clear_use_sparse_format();
  static const int kUseSparseFormatFieldNumber = 6;
  inline bool use_sparse_format() const;
  inline void set_use_sparse_format(bool value);

  // optional float eps = 7 [default = 1e-037];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 7;
  inline float eps() const;
  inline void set_eps(float value);

  // @@protoc_insertion_point(class_scope:artm.GetThetaMatrixArgs)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_batch();
  inline void clear_has_batch();
  inline void set_has_clean_cache();
  inline void clear_has_clean_cache();
  inline void set_has_use_sparse_format();
  inline void clear_has_use_sparse_format();
  inline void set_has_eps();
  inline void clear_has_eps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  ::artm::Batch* batch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > topic_index_;
  bool clean_cache_;
  bool use_sparse_format_;
  float eps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetThetaMatrixArgs* default_instance_;
};
// -------------------------------------------------------------------

class GetScoreValueArgs : public ::google::protobuf::Message {
 public:
  GetScoreValueArgs();
  virtual ~GetScoreValueArgs();

  GetScoreValueArgs(const GetScoreValueArgs& from);

  inline GetScoreValueArgs& operator=(const GetScoreValueArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetScoreValueArgs& default_instance();

  void Swap(GetScoreValueArgs* other);

  // implements Message ----------------------------------------------

  GetScoreValueArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetScoreValueArgs& from);
  void MergeFrom(const GetScoreValueArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model_name = 1;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // optional string score_name = 2;
  inline bool has_score_name() const;
  inline void clear_score_name();
  static const int kScoreNameFieldNumber = 2;
  inline const ::std::string& score_name() const;
  inline void set_score_name(const ::std::string& value);
  inline void set_score_name(const char* value);
  inline void set_score_name(const char* value, size_t size);
  inline ::std::string* mutable_score_name();
  inline ::std::string* release_score_name();
  inline void set_allocated_score_name(::std::string* score_name);

  // optional .artm.Batch batch = 3;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 3;
  inline const ::artm::Batch& batch() const;
  inline ::artm::Batch* mutable_batch();
  inline ::artm::Batch* release_batch();
  inline void set_allocated_batch(::artm::Batch* batch);

  // @@protoc_insertion_point(class_scope:artm.GetScoreValueArgs)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_score_name();
  inline void clear_has_score_name();
  inline void set_has_batch();
  inline void clear_has_batch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_name_;
  ::std::string* score_name_;
  ::artm::Batch* batch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static GetScoreValueArgs* default_instance_;
};
// -------------------------------------------------------------------

class AddBatchArgs : public ::google::protobuf::Message {
 public:
  AddBatchArgs();
  virtual ~AddBatchArgs();

  AddBatchArgs(const AddBatchArgs& from);

  inline AddBatchArgs& operator=(const AddBatchArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddBatchArgs& default_instance();

  void Swap(AddBatchArgs* other);

  // implements Message ----------------------------------------------

  AddBatchArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddBatchArgs& from);
  void MergeFrom(const AddBatchArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .artm.Batch batch = 1;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 1;
  inline const ::artm::Batch& batch() const;
  inline ::artm::Batch* mutable_batch();
  inline ::artm::Batch* release_batch();
  inline void set_allocated_batch(::artm::Batch* batch);

  // optional int32 timeout_milliseconds = 2 [default = -1];
  inline bool has_timeout_milliseconds() const;
  inline void clear_timeout_milliseconds();
  static const int kTimeoutMillisecondsFieldNumber = 2;
  inline ::google::protobuf::int32 timeout_milliseconds() const;
  inline void set_timeout_milliseconds(::google::protobuf::int32 value);

  // optional bool reset_scores = 3 [default = false];
  inline bool has_reset_scores() const;
  inline void clear_reset_scores();
  static const int kResetScoresFieldNumber = 3;
  inline bool reset_scores() const;
  inline void set_reset_scores(bool value);

  // optional string batch_file_name = 4;
  inline bool has_batch_file_name() const;
  inline void clear_batch_file_name();
  static const int kBatchFileNameFieldNumber = 4;
  inline const ::std::string& batch_file_name() const;
  inline void set_batch_file_name(const ::std::string& value);
  inline void set_batch_file_name(const char* value);
  inline void set_batch_file_name(const char* value, size_t size);
  inline ::std::string* mutable_batch_file_name();
  inline ::std::string* release_batch_file_name();
  inline void set_allocated_batch_file_name(::std::string* batch_file_name);

  // @@protoc_insertion_point(class_scope:artm.AddBatchArgs)
 private:
  inline void set_has_batch();
  inline void clear_has_batch();
  inline void set_has_timeout_milliseconds();
  inline void clear_has_timeout_milliseconds();
  inline void set_has_reset_scores();
  inline void clear_has_reset_scores();
  inline void set_has_batch_file_name();
  inline void clear_has_batch_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::artm::Batch* batch_;
  ::google::protobuf::int32 timeout_milliseconds_;
  bool reset_scores_;
  ::std::string* batch_file_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static AddBatchArgs* default_instance_;
};
// -------------------------------------------------------------------

class InvokeIterationArgs : public ::google::protobuf::Message {
 public:
  InvokeIterationArgs();
  virtual ~InvokeIterationArgs();

  InvokeIterationArgs(const InvokeIterationArgs& from);

  inline InvokeIterationArgs& operator=(const InvokeIterationArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvokeIterationArgs& default_instance();

  void Swap(InvokeIterationArgs* other);

  // implements Message ----------------------------------------------

  InvokeIterationArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvokeIterationArgs& from);
  void MergeFrom(const InvokeIterationArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 iterations_count = 1 [default = 1];
  inline bool has_iterations_count() const;
  inline void clear_iterations_count();
  static const int kIterationsCountFieldNumber = 1;
  inline ::google::protobuf::int32 iterations_count() const;
  inline void set_iterations_count(::google::protobuf::int32 value);

  // optional bool reset_scores = 2 [default = true];
  inline bool has_reset_scores() const;
  inline void clear_reset_scores();
  static const int kResetScoresFieldNumber = 2;
  inline bool reset_scores() const;
  inline void set_reset_scores(bool value);

  // optional string disk_path = 3;
  inline bool has_disk_path() const;
  inline void clear_disk_path();
  static const int kDiskPathFieldNumber = 3;
  inline const ::std::string& disk_path() const;
  inline void set_disk_path(const ::std::string& value);
  inline void set_disk_path(const char* value);
  inline void set_disk_path(const char* value, size_t size);
  inline ::std::string* mutable_disk_path();
  inline ::std::string* release_disk_path();
  inline void set_allocated_disk_path(::std::string* disk_path);

  // @@protoc_insertion_point(class_scope:artm.InvokeIterationArgs)
 private:
  inline void set_has_iterations_count();
  inline void clear_has_iterations_count();
  inline void set_has_reset_scores();
  inline void clear_has_reset_scores();
  inline void set_has_disk_path();
  inline void clear_has_disk_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 iterations_count_;
  bool reset_scores_;
  ::std::string* disk_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static InvokeIterationArgs* default_instance_;
};
// -------------------------------------------------------------------

class WaitIdleArgs : public ::google::protobuf::Message {
 public:
  WaitIdleArgs();
  virtual ~WaitIdleArgs();

  WaitIdleArgs(const WaitIdleArgs& from);

  inline WaitIdleArgs& operator=(const WaitIdleArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitIdleArgs& default_instance();

  void Swap(WaitIdleArgs* other);

  // implements Message ----------------------------------------------

  WaitIdleArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WaitIdleArgs& from);
  void MergeFrom(const WaitIdleArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timeout_milliseconds = 1 [default = -1];
  inline bool has_timeout_milliseconds() const;
  inline void clear_timeout_milliseconds();
  static const int kTimeoutMillisecondsFieldNumber = 1;
  inline ::google::protobuf::int32 timeout_milliseconds() const;
  inline void set_timeout_milliseconds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:artm.WaitIdleArgs)
 private:
  inline void set_has_timeout_milliseconds();
  inline void clear_has_timeout_milliseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timeout_milliseconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static WaitIdleArgs* default_instance_;
};
// -------------------------------------------------------------------

class ExportModelArgs : public ::google::protobuf::Message {
 public:
  ExportModelArgs();
  virtual ~ExportModelArgs();

  ExportModelArgs(const ExportModelArgs& from);

  inline ExportModelArgs& operator=(const ExportModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportModelArgs& default_instance();

  void Swap(ExportModelArgs* other);

  // implements Message ----------------------------------------------

  ExportModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportModelArgs& from);
  void MergeFrom(const ExportModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string model_name = 2;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // @@protoc_insertion_point(class_scope:artm.ExportModelArgs)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_model_name();
  inline void clear_has_model_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_name_;
  ::std::string* model_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ExportModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class ImportModelArgs : public ::google::protobuf::Message {
 public:
  ImportModelArgs();
  virtual ~ImportModelArgs();

  ImportModelArgs(const ImportModelArgs& from);

  inline ImportModelArgs& operator=(const ImportModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportModelArgs& default_instance();

  void Swap(ImportModelArgs* other);

  // implements Message ----------------------------------------------

  ImportModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportModelArgs& from);
  void MergeFrom(const ImportModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string model_name = 2;
  inline bool has_model_name() const;
  inline void clear_model_name();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& model_name() const;
  inline void set_model_name(const ::std::string& value);
  inline void set_model_name(const char* value);
  inline void set_model_name(const char* value, size_t size);
  inline ::std::string* mutable_model_name();
  inline ::std::string* release_model_name();
  inline void set_allocated_model_name(::std::string* model_name);

  // @@protoc_insertion_point(class_scope:artm.ImportModelArgs)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_model_name();
  inline void clear_has_model_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_name_;
  ::std::string* model_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ImportModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class ProcessBatchesArgs : public ::google::protobuf::Message {
 public:
  ProcessBatchesArgs();
  virtual ~ProcessBatchesArgs();

  ProcessBatchesArgs(const ProcessBatchesArgs& from);

  inline ProcessBatchesArgs& operator=(const ProcessBatchesArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessBatchesArgs& default_instance();

  void Swap(ProcessBatchesArgs* other);

  // implements Message ----------------------------------------------

  ProcessBatchesArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessBatchesArgs& from);
  void MergeFrom(const ProcessBatchesArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProcessBatchesArgs_ThetaMatrixType ThetaMatrixType;
  static const ThetaMatrixType None = ProcessBatchesArgs_ThetaMatrixType_None;
  static const ThetaMatrixType Dense = ProcessBatchesArgs_ThetaMatrixType_Dense;
  static const ThetaMatrixType Sparse = ProcessBatchesArgs_ThetaMatrixType_Sparse;
  static const ThetaMatrixType Cache = ProcessBatchesArgs_ThetaMatrixType_Cache;
  static inline bool ThetaMatrixType_IsValid(int value) {
    return ProcessBatchesArgs_ThetaMatrixType_IsValid(value);
  }
  static const ThetaMatrixType ThetaMatrixType_MIN =
    ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_MIN;
  static const ThetaMatrixType ThetaMatrixType_MAX =
    ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_MAX;
  static const int ThetaMatrixType_ARRAYSIZE =
    ProcessBatchesArgs_ThetaMatrixType_ThetaMatrixType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ThetaMatrixType_descriptor() {
    return ProcessBatchesArgs_ThetaMatrixType_descriptor();
  }
  static inline const ::std::string& ThetaMatrixType_Name(ThetaMatrixType value) {
    return ProcessBatchesArgs_ThetaMatrixType_Name(value);
  }
  static inline bool ThetaMatrixType_Parse(const ::std::string& name,
      ThetaMatrixType* value) {
    return ProcessBatchesArgs_ThetaMatrixType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string nwt_target_name = 1;
  inline bool has_nwt_target_name() const;
  inline void clear_nwt_target_name();
  static const int kNwtTargetNameFieldNumber = 1;
  inline const ::std::string& nwt_target_name() const;
  inline void set_nwt_target_name(const ::std::string& value);
  inline void set_nwt_target_name(const char* value);
  inline void set_nwt_target_name(const char* value, size_t size);
  inline ::std::string* mutable_nwt_target_name();
  inline ::std::string* release_nwt_target_name();
  inline void set_allocated_nwt_target_name(::std::string* nwt_target_name);

  // repeated string batch_filename = 2;
  inline int batch_filename_size() const;
  inline void clear_batch_filename();
  static const int kBatchFilenameFieldNumber = 2;
  inline const ::std::string& batch_filename(int index) const;
  inline ::std::string* mutable_batch_filename(int index);
  inline void set_batch_filename(int index, const ::std::string& value);
  inline void set_batch_filename(int index, const char* value);
  inline void set_batch_filename(int index, const char* value, size_t size);
  inline ::std::string* add_batch_filename();
  inline void add_batch_filename(const ::std::string& value);
  inline void add_batch_filename(const char* value);
  inline void add_batch_filename(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& batch_filename() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_batch_filename();

  // optional string pwt_source_name = 3;
  inline bool has_pwt_source_name() const;
  inline void clear_pwt_source_name();
  static const int kPwtSourceNameFieldNumber = 3;
  inline const ::std::string& pwt_source_name() const;
  inline void set_pwt_source_name(const ::std::string& value);
  inline void set_pwt_source_name(const char* value);
  inline void set_pwt_source_name(const char* value, size_t size);
  inline ::std::string* mutable_pwt_source_name();
  inline ::std::string* release_pwt_source_name();
  inline void set_allocated_pwt_source_name(::std::string* pwt_source_name);

  // optional int32 inner_iterations_count = 4 [default = 10];
  inline bool has_inner_iterations_count() const;
  inline void clear_inner_iterations_count();
  static const int kInnerIterationsCountFieldNumber = 4;
  inline ::google::protobuf::int32 inner_iterations_count() const;
  inline void set_inner_iterations_count(::google::protobuf::int32 value);

  // optional string stream_name = 5 [default = "@global"];
  inline bool has_stream_name() const;
  inline void clear_stream_name();
  static const int kStreamNameFieldNumber = 5;
  inline const ::std::string& stream_name() const;
  inline void set_stream_name(const ::std::string& value);
  inline void set_stream_name(const char* value);
  inline void set_stream_name(const char* value, size_t size);
  inline ::std::string* mutable_stream_name();
  inline ::std::string* release_stream_name();
  inline void set_allocated_stream_name(::std::string* stream_name);

  // repeated string regularizer_name = 6;
  inline int regularizer_name_size() const;
  inline void clear_regularizer_name();
  static const int kRegularizerNameFieldNumber = 6;
  inline const ::std::string& regularizer_name(int index) const;
  inline ::std::string* mutable_regularizer_name(int index);
  inline void set_regularizer_name(int index, const ::std::string& value);
  inline void set_regularizer_name(int index, const char* value);
  inline void set_regularizer_name(int index, const char* value, size_t size);
  inline ::std::string* add_regularizer_name();
  inline void add_regularizer_name(const ::std::string& value);
  inline void add_regularizer_name(const char* value);
  inline void add_regularizer_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& regularizer_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_regularizer_name();

  // repeated double regularizer_tau = 7;
  inline int regularizer_tau_size() const;
  inline void clear_regularizer_tau();
  static const int kRegularizerTauFieldNumber = 7;
  inline double regularizer_tau(int index) const;
  inline void set_regularizer_tau(int index, double value);
  inline void add_regularizer_tau(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      regularizer_tau() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_regularizer_tau();

  // repeated string class_id = 8;
  inline int class_id_size() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 8;
  inline const ::std::string& class_id(int index) const;
  inline ::std::string* mutable_class_id(int index);
  inline void set_class_id(int index, const ::std::string& value);
  inline void set_class_id(int index, const char* value);
  inline void set_class_id(int index, const char* value, size_t size);
  inline ::std::string* add_class_id();
  inline void add_class_id(const ::std::string& value);
  inline void add_class_id(const char* value);
  inline void add_class_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& class_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_class_id();

  // repeated float class_weight = 9;
  inline int class_weight_size() const;
  inline void clear_class_weight();
  static const int kClassWeightFieldNumber = 9;
  inline float class_weight(int index) const;
  inline void set_class_weight(int index, float value);
  inline void add_class_weight(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      class_weight() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_class_weight();

  // optional bool reuse_theta = 10 [default = false];
  inline bool has_reuse_theta() const;
  inline void clear_reuse_theta();
  static const int kReuseThetaFieldNumber = 10;
  inline bool reuse_theta() const;
  inline void set_reuse_theta(bool value);

  // optional bool opt_for_avx = 11 [default = true];
  inline bool has_opt_for_avx() const;
  inline void clear_opt_for_avx();
  static const int kOptForAvxFieldNumber = 11;
  inline bool opt_for_avx() const;
  inline void set_opt_for_avx(bool value);

  // optional bool use_sparse_bow = 12 [default = true];
  inline bool has_use_sparse_bow() const;
  inline void clear_use_sparse_bow();
  static const int kUseSparseBowFieldNumber = 12;
  inline bool use_sparse_bow() const;
  inline void set_use_sparse_bow(bool value);

  // optional bool reset_scores = 13 [default = true];
  inline bool has_reset_scores() const;
  inline void clear_reset_scores();
  static const int kResetScoresFieldNumber = 13;
  inline bool reset_scores() const;
  inline void set_reset_scores(bool value);

  // optional .artm.ProcessBatchesArgs.ThetaMatrixType theta_matrix_type = 14 [default = Cache];
  inline bool has_theta_matrix_type() const;
  inline void clear_theta_matrix_type();
  static const int kThetaMatrixTypeFieldNumber = 14;
  inline ::artm::ProcessBatchesArgs_ThetaMatrixType theta_matrix_type() const;
  inline void set_theta_matrix_type(::artm::ProcessBatchesArgs_ThetaMatrixType value);

  // @@protoc_insertion_point(class_scope:artm.ProcessBatchesArgs)
 private:
  inline void set_has_nwt_target_name();
  inline void clear_has_nwt_target_name();
  inline void set_has_pwt_source_name();
  inline void clear_has_pwt_source_name();
  inline void set_has_inner_iterations_count();
  inline void clear_has_inner_iterations_count();
  inline void set_has_stream_name();
  inline void clear_has_stream_name();
  inline void set_has_reuse_theta();
  inline void clear_has_reuse_theta();
  inline void set_has_opt_for_avx();
  inline void clear_has_opt_for_avx();
  inline void set_has_use_sparse_bow();
  inline void clear_has_use_sparse_bow();
  inline void set_has_reset_scores();
  inline void clear_has_reset_scores();
  inline void set_has_theta_matrix_type();
  inline void clear_has_theta_matrix_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nwt_target_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> batch_filename_;
  ::std::string* pwt_source_name_;
  ::std::string* stream_name_;
  static ::std::string* _default_stream_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> regularizer_name_;
  ::google::protobuf::RepeatedField< double > regularizer_tau_;
  ::google::protobuf::RepeatedPtrField< ::std::string> class_id_;
  ::google::protobuf::RepeatedField< float > class_weight_;
  ::google::protobuf::int32 inner_iterations_count_;
  bool reuse_theta_;
  bool opt_for_avx_;
  bool use_sparse_bow_;
  bool reset_scores_;
  int theta_matrix_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ProcessBatchesArgs* default_instance_;
};
// -------------------------------------------------------------------

class ProcessBatchesResult : public ::google::protobuf::Message {
 public:
  ProcessBatchesResult();
  virtual ~ProcessBatchesResult();

  ProcessBatchesResult(const ProcessBatchesResult& from);

  inline ProcessBatchesResult& operator=(const ProcessBatchesResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessBatchesResult& default_instance();

  void Swap(ProcessBatchesResult* other);

  // implements Message ----------------------------------------------

  ProcessBatchesResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessBatchesResult& from);
  void MergeFrom(const ProcessBatchesResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .artm.ScoreData score_data = 1;
  inline int score_data_size() const;
  inline void clear_score_data();
  static const int kScoreDataFieldNumber = 1;
  inline const ::artm::ScoreData& score_data(int index) const;
  inline ::artm::ScoreData* mutable_score_data(int index);
  inline ::artm::ScoreData* add_score_data();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::ScoreData >&
      score_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::ScoreData >*
      mutable_score_data();

  // optional .artm.ThetaMatrix theta_matrix = 2;
  inline bool has_theta_matrix() const;
  inline void clear_theta_matrix();
  static const int kThetaMatrixFieldNumber = 2;
  inline const ::artm::ThetaMatrix& theta_matrix() const;
  inline ::artm::ThetaMatrix* mutable_theta_matrix();
  inline ::artm::ThetaMatrix* release_theta_matrix();
  inline void set_allocated_theta_matrix(::artm::ThetaMatrix* theta_matrix);

  // @@protoc_insertion_point(class_scope:artm.ProcessBatchesResult)
 private:
  inline void set_has_theta_matrix();
  inline void clear_has_theta_matrix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::artm::ScoreData > score_data_;
  ::artm::ThetaMatrix* theta_matrix_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static ProcessBatchesResult* default_instance_;
};
// -------------------------------------------------------------------

class MergeModelArgs : public ::google::protobuf::Message {
 public:
  MergeModelArgs();
  virtual ~MergeModelArgs();

  MergeModelArgs(const MergeModelArgs& from);

  inline MergeModelArgs& operator=(const MergeModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeModelArgs& default_instance();

  void Swap(MergeModelArgs* other);

  // implements Message ----------------------------------------------

  MergeModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MergeModelArgs& from);
  void MergeFrom(const MergeModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nwt_target_name = 1;
  inline bool has_nwt_target_name() const;
  inline void clear_nwt_target_name();
  static const int kNwtTargetNameFieldNumber = 1;
  inline const ::std::string& nwt_target_name() const;
  inline void set_nwt_target_name(const ::std::string& value);
  inline void set_nwt_target_name(const char* value);
  inline void set_nwt_target_name(const char* value, size_t size);
  inline ::std::string* mutable_nwt_target_name();
  inline ::std::string* release_nwt_target_name();
  inline void set_allocated_nwt_target_name(::std::string* nwt_target_name);

  // repeated string nwt_source_name = 2;
  inline int nwt_source_name_size() const;
  inline void clear_nwt_source_name();
  static const int kNwtSourceNameFieldNumber = 2;
  inline const ::std::string& nwt_source_name(int index) const;
  inline ::std::string* mutable_nwt_source_name(int index);
  inline void set_nwt_source_name(int index, const ::std::string& value);
  inline void set_nwt_source_name(int index, const char* value);
  inline void set_nwt_source_name(int index, const char* value, size_t size);
  inline ::std::string* add_nwt_source_name();
  inline void add_nwt_source_name(const ::std::string& value);
  inline void add_nwt_source_name(const char* value);
  inline void add_nwt_source_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nwt_source_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nwt_source_name();

  // repeated float source_weight = 3;
  inline int source_weight_size() const;
  inline void clear_source_weight();
  static const int kSourceWeightFieldNumber = 3;
  inline float source_weight(int index) const;
  inline void set_source_weight(int index, float value);
  inline void add_source_weight(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      source_weight() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_source_weight();

  // repeated string topic_name = 4;
  inline int topic_name_size() const;
  inline void clear_topic_name();
  static const int kTopicNameFieldNumber = 4;
  inline const ::std::string& topic_name(int index) const;
  inline ::std::string* mutable_topic_name(int index);
  inline void set_topic_name(int index, const ::std::string& value);
  inline void set_topic_name(int index, const char* value);
  inline void set_topic_name(int index, const char* value, size_t size);
  inline ::std::string* add_topic_name();
  inline void add_topic_name(const ::std::string& value);
  inline void add_topic_name(const char* value);
  inline void add_topic_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topic_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topic_name();

  // @@protoc_insertion_point(class_scope:artm.MergeModelArgs)
 private:
  inline void set_has_nwt_target_name();
  inline void clear_has_nwt_target_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nwt_target_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nwt_source_name_;
  ::google::protobuf::RepeatedField< float > source_weight_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topic_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static MergeModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class RegularizeModelArgs : public ::google::protobuf::Message {
 public:
  RegularizeModelArgs();
  virtual ~RegularizeModelArgs();

  RegularizeModelArgs(const RegularizeModelArgs& from);

  inline RegularizeModelArgs& operator=(const RegularizeModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularizeModelArgs& default_instance();

  void Swap(RegularizeModelArgs* other);

  // implements Message ----------------------------------------------

  RegularizeModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularizeModelArgs& from);
  void MergeFrom(const RegularizeModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rwt_target_name = 1;
  inline bool has_rwt_target_name() const;
  inline void clear_rwt_target_name();
  static const int kRwtTargetNameFieldNumber = 1;
  inline const ::std::string& rwt_target_name() const;
  inline void set_rwt_target_name(const ::std::string& value);
  inline void set_rwt_target_name(const char* value);
  inline void set_rwt_target_name(const char* value, size_t size);
  inline ::std::string* mutable_rwt_target_name();
  inline ::std::string* release_rwt_target_name();
  inline void set_allocated_rwt_target_name(::std::string* rwt_target_name);

  // optional string pwt_source_name = 2;
  inline bool has_pwt_source_name() const;
  inline void clear_pwt_source_name();
  static const int kPwtSourceNameFieldNumber = 2;
  inline const ::std::string& pwt_source_name() const;
  inline void set_pwt_source_name(const ::std::string& value);
  inline void set_pwt_source_name(const char* value);
  inline void set_pwt_source_name(const char* value, size_t size);
  inline ::std::string* mutable_pwt_source_name();
  inline ::std::string* release_pwt_source_name();
  inline void set_allocated_pwt_source_name(::std::string* pwt_source_name);

  // optional string nwt_source_name = 3;
  inline bool has_nwt_source_name() const;
  inline void clear_nwt_source_name();
  static const int kNwtSourceNameFieldNumber = 3;
  inline const ::std::string& nwt_source_name() const;
  inline void set_nwt_source_name(const ::std::string& value);
  inline void set_nwt_source_name(const char* value);
  inline void set_nwt_source_name(const char* value, size_t size);
  inline ::std::string* mutable_nwt_source_name();
  inline ::std::string* release_nwt_source_name();
  inline void set_allocated_nwt_source_name(::std::string* nwt_source_name);

  // repeated .artm.RegularizerSettings regularizer_settings = 4;
  inline int regularizer_settings_size() const;
  inline void clear_regularizer_settings();
  static const int kRegularizerSettingsFieldNumber = 4;
  inline const ::artm::RegularizerSettings& regularizer_settings(int index) const;
  inline ::artm::RegularizerSettings* mutable_regularizer_settings(int index);
  inline ::artm::RegularizerSettings* add_regularizer_settings();
  inline const ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >&
      regularizer_settings() const;
  inline ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >*
      mutable_regularizer_settings();

  // @@protoc_insertion_point(class_scope:artm.RegularizeModelArgs)
 private:
  inline void set_has_rwt_target_name();
  inline void clear_has_rwt_target_name();
  inline void set_has_pwt_source_name();
  inline void clear_has_pwt_source_name();
  inline void set_has_nwt_source_name();
  inline void clear_has_nwt_source_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rwt_target_name_;
  ::std::string* pwt_source_name_;
  ::std::string* nwt_source_name_;
  ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings > regularizer_settings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static RegularizeModelArgs* default_instance_;
};
// -------------------------------------------------------------------

class NormalizeModelArgs : public ::google::protobuf::Message {
 public:
  NormalizeModelArgs();
  virtual ~NormalizeModelArgs();

  NormalizeModelArgs(const NormalizeModelArgs& from);

  inline NormalizeModelArgs& operator=(const NormalizeModelArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizeModelArgs& default_instance();

  void Swap(NormalizeModelArgs* other);

  // implements Message ----------------------------------------------

  NormalizeModelArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NormalizeModelArgs& from);
  void MergeFrom(const NormalizeModelArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pwt_target_name = 1;
  inline bool has_pwt_target_name() const;
  inline void clear_pwt_target_name();
  static const int kPwtTargetNameFieldNumber = 1;
  inline const ::std::string& pwt_target_name() const;
  inline void set_pwt_target_name(const ::std::string& value);
  inline void set_pwt_target_name(const char* value);
  inline void set_pwt_target_name(const char* value, size_t size);
  inline ::std::string* mutable_pwt_target_name();
  inline ::std::string* release_pwt_target_name();
  inline void set_allocated_pwt_target_name(::std::string* pwt_target_name);

  // optional string nwt_source_name = 2;
  inline bool has_nwt_source_name() const;
  inline void clear_nwt_source_name();
  static const int kNwtSourceNameFieldNumber = 2;
  inline const ::std::string& nwt_source_name() const;
  inline void set_nwt_source_name(const ::std::string& value);
  inline void set_nwt_source_name(const char* value);
  inline void set_nwt_source_name(const char* value, size_t size);
  inline ::std::string* mutable_nwt_source_name();
  inline ::std::string* release_nwt_source_name();
  inline void set_allocated_nwt_source_name(::std::string* nwt_source_name);

  // optional string rwt_source_name = 3;
  inline bool has_rwt_source_name() const;
  inline void clear_rwt_source_name();
  static const int kRwtSourceNameFieldNumber = 3;
  inline const ::std::string& rwt_source_name() const;
  inline void set_rwt_source_name(const ::std::string& value);
  inline void set_rwt_source_name(const char* value);
  inline void set_rwt_source_name(const char* value, size_t size);
  inline ::std::string* mutable_rwt_source_name();
  inline ::std::string* release_rwt_source_name();
  inline void set_allocated_rwt_source_name(::std::string* rwt_source_name);

  // @@protoc_insertion_point(class_scope:artm.NormalizeModelArgs)
 private:
  inline void set_has_pwt_target_name();
  inline void clear_has_pwt_target_name();
  inline void set_has_nwt_source_name();
  inline void clear_has_nwt_source_name();
  inline void set_has_rwt_source_name();
  inline void clear_has_rwt_source_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pwt_target_name_;
  ::std::string* nwt_source_name_;
  ::std::string* rwt_source_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_artm_2fmessages_2eproto();
  friend void protobuf_AssignDesc_artm_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_artm_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static NormalizeModelArgs* default_instance_;
};
// ===================================================================


// ===================================================================

// DoubleArray

// repeated double value = 1 [packed = true];
inline int DoubleArray::value_size() const {
  return value_.size();
}
inline void DoubleArray::clear_value() {
  value_.Clear();
}
inline double DoubleArray::value(int index) const {
  return value_.Get(index);
}
inline void DoubleArray::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void DoubleArray::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// FloatArray

// repeated float value = 1 [packed = true];
inline int FloatArray::value_size() const {
  return value_.size();
}
inline void FloatArray::clear_value() {
  value_.Clear();
}
inline float FloatArray::value(int index) const {
  return value_.Get(index);
}
inline void FloatArray::set_value(int index, float value) {
  value_.Set(index, value);
}
inline void FloatArray::add_value(float value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
FloatArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// BoolArray

// repeated bool value = 1 [packed = true];
inline int BoolArray::value_size() const {
  return value_.size();
}
inline void BoolArray::clear_value() {
  value_.Clear();
}
inline bool BoolArray::value(int index) const {
  return value_.Get(index);
}
inline void BoolArray::set_value(int index, bool value) {
  value_.Set(index, value);
}
inline void BoolArray::add_value(bool value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
BoolArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< bool >*
BoolArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// IntArray

// repeated int32 value = 1 [packed = true];
inline int IntArray::value_size() const {
  return value_.size();
}
inline void IntArray::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 IntArray::value(int index) const {
  return value_.Get(index);
}
inline void IntArray::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
}
inline void IntArray::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IntArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IntArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// StringArray

// repeated string value = 1;
inline int StringArray::value_size() const {
  return value_.size();
}
inline void StringArray::clear_value() {
  value_.Clear();
}
inline const ::std::string& StringArray::value(int index) const {
  return value_.Get(index);
}
inline ::std::string* StringArray::mutable_value(int index) {
  return value_.Mutable(index);
}
inline void StringArray::set_value(int index, const ::std::string& value) {
  value_.Mutable(index)->assign(value);
}
inline void StringArray::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
}
inline void StringArray::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringArray::add_value() {
  return value_.Add();
}
inline void StringArray::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
}
inline void StringArray::add_value(const char* value) {
  value_.Add()->assign(value);
}
inline void StringArray::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringArray::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringArray::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Item

// optional int32 id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Item::id() const {
  return id_;
}
inline void Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .artm.Field field = 2;
inline int Item::field_size() const {
  return field_.size();
}
inline void Item::clear_field() {
  field_.Clear();
}
inline const ::artm::Field& Item::field(int index) const {
  return field_.Get(index);
}
inline ::artm::Field* Item::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::artm::Field* Item::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Field >&
Item::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Field >*
Item::mutable_field() {
  return &field_;
}

// optional string title = 3;
inline bool Item::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyString()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Item::title() const {
  return *title_;
}
inline void Item::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Item::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Item::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Item::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Item::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyString()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Field

// optional string name = 1 [default = "@body"];
inline bool Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Field::name() const {
  return *name_;
}
inline void Field::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Field::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Field::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated int32 token_id = 2;
inline int Field::token_id_size() const {
  return token_id_.size();
}
inline void Field::clear_token_id() {
  token_id_.Clear();
}
inline ::google::protobuf::int32 Field::token_id(int index) const {
  return token_id_.Get(index);
}
inline void Field::set_token_id(int index, ::google::protobuf::int32 value) {
  token_id_.Set(index, value);
}
inline void Field::add_token_id(::google::protobuf::int32 value) {
  token_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_id() const {
  return token_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_id() {
  return &token_id_;
}

// repeated int32 token_count = 3;
inline int Field::token_count_size() const {
  return token_count_.size();
}
inline void Field::clear_token_count() {
  token_count_.Clear();
}
inline ::google::protobuf::int32 Field::token_count(int index) const {
  return token_count_.Get(index);
}
inline void Field::set_token_count(int index, ::google::protobuf::int32 value) {
  token_count_.Set(index, value);
}
inline void Field::add_token_count(::google::protobuf::int32 value) {
  token_count_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_count() const {
  return token_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_count() {
  return &token_count_;
}

// repeated int32 token_offset = 4;
inline int Field::token_offset_size() const {
  return token_offset_.size();
}
inline void Field::clear_token_offset() {
  token_offset_.Clear();
}
inline ::google::protobuf::int32 Field::token_offset(int index) const {
  return token_offset_.Get(index);
}
inline void Field::set_token_offset(int index, ::google::protobuf::int32 value) {
  token_offset_.Set(index, value);
}
inline void Field::add_token_offset(::google::protobuf::int32 value) {
  token_offset_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Field::token_offset() const {
  return token_offset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Field::mutable_token_offset() {
  return &token_offset_;
}

// optional string string_value = 5;
inline bool Field::has_string_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Field::set_has_string_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Field::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Field::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::GetEmptyString()) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& Field::string_value() const {
  return *string_value_;
}
inline void Field::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void Field::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void Field::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* Field::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Field::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::GetEmptyString()) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 int_value = 6;
inline bool Field::has_int_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Field::set_has_int_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Field::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Field::clear_int_value() {
  int_value_ = GOOGLE_LONGLONG(0);
  clear_has_int_value();
}
inline ::google::protobuf::int64 Field::int_value() const {
  return int_value_;
}
inline void Field::set_int_value(::google::protobuf::int64 value) {
  set_has_int_value();
  int_value_ = value;
}

// optional double double_value = 7;
inline bool Field::has_double_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Field::set_has_double_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Field::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Field::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double Field::double_value() const {
  return double_value_;
}
inline void Field::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}

// optional string date_value = 8;
inline bool Field::has_date_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Field::set_has_date_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Field::clear_has_date_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Field::clear_date_value() {
  if (date_value_ != &::google::protobuf::internal::GetEmptyString()) {
    date_value_->clear();
  }
  clear_has_date_value();
}
inline const ::std::string& Field::date_value() const {
  return *date_value_;
}
inline void Field::set_date_value(const ::std::string& value) {
  set_has_date_value();
  if (date_value_ == &::google::protobuf::internal::GetEmptyString()) {
    date_value_ = new ::std::string;
  }
  date_value_->assign(value);
}
inline void Field::set_date_value(const char* value) {
  set_has_date_value();
  if (date_value_ == &::google::protobuf::internal::GetEmptyString()) {
    date_value_ = new ::std::string;
  }
  date_value_->assign(value);
}
inline void Field::set_date_value(const char* value, size_t size) {
  set_has_date_value();
  if (date_value_ == &::google::protobuf::internal::GetEmptyString()) {
    date_value_ = new ::std::string;
  }
  date_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_date_value() {
  set_has_date_value();
  if (date_value_ == &::google::protobuf::internal::GetEmptyString()) {
    date_value_ = new ::std::string;
  }
  return date_value_;
}
inline ::std::string* Field::release_date_value() {
  clear_has_date_value();
  if (date_value_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = date_value_;
    date_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Field::set_allocated_date_value(::std::string* date_value) {
  if (date_value_ != &::google::protobuf::internal::GetEmptyString()) {
    delete date_value_;
  }
  if (date_value) {
    set_has_date_value();
    date_value_ = date_value;
  } else {
    clear_has_date_value();
    date_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated string string_array = 16;
inline int Field::string_array_size() const {
  return string_array_.size();
}
inline void Field::clear_string_array() {
  string_array_.Clear();
}
inline const ::std::string& Field::string_array(int index) const {
  return string_array_.Get(index);
}
inline ::std::string* Field::mutable_string_array(int index) {
  return string_array_.Mutable(index);
}
inline void Field::set_string_array(int index, const ::std::string& value) {
  string_array_.Mutable(index)->assign(value);
}
inline void Field::set_string_array(int index, const char* value) {
  string_array_.Mutable(index)->assign(value);
}
inline void Field::set_string_array(int index, const char* value, size_t size) {
  string_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::add_string_array() {
  return string_array_.Add();
}
inline void Field::add_string_array(const ::std::string& value) {
  string_array_.Add()->assign(value);
}
inline void Field::add_string_array(const char* value) {
  string_array_.Add()->assign(value);
}
inline void Field::add_string_array(const char* value, size_t size) {
  string_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Field::string_array() const {
  return string_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Field::mutable_string_array() {
  return &string_array_;
}

// repeated int64 int_array = 17;
inline int Field::int_array_size() const {
  return int_array_.size();
}
inline void Field::clear_int_array() {
  int_array_.Clear();
}
inline ::google::protobuf::int64 Field::int_array(int index) const {
  return int_array_.Get(index);
}
inline void Field::set_int_array(int index, ::google::protobuf::int64 value) {
  int_array_.Set(index, value);
}
inline void Field::add_int_array(::google::protobuf::int64 value) {
  int_array_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Field::int_array() const {
  return int_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Field::mutable_int_array() {
  return &int_array_;
}

// repeated double double_array = 18;
inline int Field::double_array_size() const {
  return double_array_.size();
}
inline void Field::clear_double_array() {
  double_array_.Clear();
}
inline double Field::double_array(int index) const {
  return double_array_.Get(index);
}
inline void Field::set_double_array(int index, double value) {
  double_array_.Set(index, value);
}
inline void Field::add_double_array(double value) {
  double_array_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Field::double_array() const {
  return double_array_;
}
inline ::google::protobuf::RepeatedField< double >*
Field::mutable_double_array() {
  return &double_array_;
}

// repeated string date_array = 19;
inline int Field::date_array_size() const {
  return date_array_.size();
}
inline void Field::clear_date_array() {
  date_array_.Clear();
}
inline const ::std::string& Field::date_array(int index) const {
  return date_array_.Get(index);
}
inline ::std::string* Field::mutable_date_array(int index) {
  return date_array_.Mutable(index);
}
inline void Field::set_date_array(int index, const ::std::string& value) {
  date_array_.Mutable(index)->assign(value);
}
inline void Field::set_date_array(int index, const char* value) {
  date_array_.Mutable(index)->assign(value);
}
inline void Field::set_date_array(int index, const char* value, size_t size) {
  date_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::add_date_array() {
  return date_array_.Add();
}
inline void Field::add_date_array(const ::std::string& value) {
  date_array_.Add()->assign(value);
}
inline void Field::add_date_array(const char* value) {
  date_array_.Add()->assign(value);
}
inline void Field::add_date_array(const char* value, size_t size) {
  date_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Field::date_array() const {
  return date_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Field::mutable_date_array() {
  return &date_array_;
}

// -------------------------------------------------------------------

// Batch

// repeated string token = 1;
inline int Batch::token_size() const {
  return token_.size();
}
inline void Batch::clear_token() {
  token_.Clear();
}
inline const ::std::string& Batch::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* Batch::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void Batch::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void Batch::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void Batch::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Batch::add_token() {
  return token_.Add();
}
inline void Batch::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void Batch::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void Batch::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Batch::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Batch::mutable_token() {
  return &token_;
}

// repeated string class_id = 2;
inline int Batch::class_id_size() const {
  return class_id_.size();
}
inline void Batch::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& Batch::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* Batch::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void Batch::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void Batch::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void Batch::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Batch::add_class_id() {
  return class_id_.Add();
}
inline void Batch::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void Batch::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void Batch::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Batch::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Batch::mutable_class_id() {
  return &class_id_;
}

// repeated .artm.Item item = 3;
inline int Batch::item_size() const {
  return item_.size();
}
inline void Batch::clear_item() {
  item_.Clear();
}
inline const ::artm::Item& Batch::item(int index) const {
  return item_.Get(index);
}
inline ::artm::Item* Batch::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::artm::Item* Batch::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Item >&
Batch::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Item >*
Batch::mutable_item() {
  return &item_;
}

// optional string description = 4;
inline bool Batch::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Batch::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Batch::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Batch::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyString()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Batch::description() const {
  return *description_;
}
inline void Batch::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Batch::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Batch::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Batch::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Batch::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Batch::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyString()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string id = 5;
inline bool Batch::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Batch::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Batch::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Batch::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyString()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Batch::id() const {
  return *id_;
}
inline void Batch::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Batch::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Batch::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Batch::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Batch::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Batch::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Stream

// optional .artm.Stream.Type type = 1 [default = Global];
inline bool Stream::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::Stream_Type Stream::type() const {
  return static_cast< ::artm::Stream_Type >(type_);
}
inline void Stream::set_type(::artm::Stream_Type value) {
  assert(::artm::Stream_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 2 [default = "@global"];
inline bool Stream::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Stream::name() const {
  return *name_;
}
inline void Stream::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stream::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stream::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stream::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Stream::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Stream::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 modulus = 3;
inline bool Stream::has_modulus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stream::set_has_modulus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stream::clear_has_modulus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stream::clear_modulus() {
  modulus_ = 0;
  clear_has_modulus();
}
inline ::google::protobuf::int32 Stream::modulus() const {
  return modulus_;
}
inline void Stream::set_modulus(::google::protobuf::int32 value) {
  set_has_modulus();
  modulus_ = value;
}

// repeated int32 residuals = 4;
inline int Stream::residuals_size() const {
  return residuals_.size();
}
inline void Stream::clear_residuals() {
  residuals_.Clear();
}
inline ::google::protobuf::int32 Stream::residuals(int index) const {
  return residuals_.Get(index);
}
inline void Stream::set_residuals(int index, ::google::protobuf::int32 value) {
  residuals_.Set(index, value);
}
inline void Stream::add_residuals(::google::protobuf::int32 value) {
  residuals_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Stream::residuals() const {
  return residuals_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Stream::mutable_residuals() {
  return &residuals_;
}

// -------------------------------------------------------------------

// MasterComponentConfig

// optional string disk_path = 2;
inline bool MasterComponentConfig::has_disk_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterComponentConfig::set_has_disk_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterComponentConfig::clear_has_disk_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterComponentConfig::clear_disk_path() {
  if (disk_path_ != &::google::protobuf::internal::GetEmptyString()) {
    disk_path_->clear();
  }
  clear_has_disk_path();
}
inline const ::std::string& MasterComponentConfig::disk_path() const {
  return *disk_path_;
}
inline void MasterComponentConfig::set_disk_path(const ::std::string& value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void MasterComponentConfig::set_disk_path(const char* value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void MasterComponentConfig::set_disk_path(const char* value, size_t size) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterComponentConfig::mutable_disk_path() {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  return disk_path_;
}
inline ::std::string* MasterComponentConfig::release_disk_path() {
  clear_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = disk_path_;
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MasterComponentConfig::set_allocated_disk_path(::std::string* disk_path) {
  if (disk_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete disk_path_;
  }
  if (disk_path) {
    set_has_disk_path();
    disk_path_ = disk_path;
  } else {
    clear_has_disk_path();
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .artm.Stream stream = 3;
inline int MasterComponentConfig::stream_size() const {
  return stream_.size();
}
inline void MasterComponentConfig::clear_stream() {
  stream_.Clear();
}
inline const ::artm::Stream& MasterComponentConfig::stream(int index) const {
  return stream_.Get(index);
}
inline ::artm::Stream* MasterComponentConfig::mutable_stream(int index) {
  return stream_.Mutable(index);
}
inline ::artm::Stream* MasterComponentConfig::add_stream() {
  return stream_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::Stream >&
MasterComponentConfig::stream() const {
  return stream_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::Stream >*
MasterComponentConfig::mutable_stream() {
  return &stream_;
}

// optional bool compact_batches = 4 [default = true];
inline bool MasterComponentConfig::has_compact_batches() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterComponentConfig::set_has_compact_batches() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterComponentConfig::clear_has_compact_batches() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterComponentConfig::clear_compact_batches() {
  compact_batches_ = true;
  clear_has_compact_batches();
}
inline bool MasterComponentConfig::compact_batches() const {
  return compact_batches_;
}
inline void MasterComponentConfig::set_compact_batches(bool value) {
  set_has_compact_batches();
  compact_batches_ = value;
}

// optional bool cache_theta = 5 [default = false];
inline bool MasterComponentConfig::has_cache_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterComponentConfig::set_has_cache_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterComponentConfig::clear_has_cache_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterComponentConfig::clear_cache_theta() {
  cache_theta_ = false;
  clear_has_cache_theta();
}
inline bool MasterComponentConfig::cache_theta() const {
  return cache_theta_;
}
inline void MasterComponentConfig::set_cache_theta(bool value) {
  set_has_cache_theta();
  cache_theta_ = value;
}

// optional int32 processors_count = 6;
inline bool MasterComponentConfig::has_processors_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterComponentConfig::set_has_processors_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterComponentConfig::clear_has_processors_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterComponentConfig::clear_processors_count() {
  processors_count_ = 0;
  clear_has_processors_count();
}
inline ::google::protobuf::int32 MasterComponentConfig::processors_count() const {
  return processors_count_;
}
inline void MasterComponentConfig::set_processors_count(::google::protobuf::int32 value) {
  set_has_processors_count();
  processors_count_ = value;
}

// optional int32 processor_queue_max_size = 7 [default = 10];
inline bool MasterComponentConfig::has_processor_queue_max_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MasterComponentConfig::set_has_processor_queue_max_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MasterComponentConfig::clear_has_processor_queue_max_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MasterComponentConfig::clear_processor_queue_max_size() {
  processor_queue_max_size_ = 10;
  clear_has_processor_queue_max_size();
}
inline ::google::protobuf::int32 MasterComponentConfig::processor_queue_max_size() const {
  return processor_queue_max_size_;
}
inline void MasterComponentConfig::set_processor_queue_max_size(::google::protobuf::int32 value) {
  set_has_processor_queue_max_size();
  processor_queue_max_size_ = value;
}

// optional int32 merger_queue_max_size = 8 [default = 10];
inline bool MasterComponentConfig::has_merger_queue_max_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MasterComponentConfig::set_has_merger_queue_max_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MasterComponentConfig::clear_has_merger_queue_max_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MasterComponentConfig::clear_merger_queue_max_size() {
  merger_queue_max_size_ = 10;
  clear_has_merger_queue_max_size();
}
inline ::google::protobuf::int32 MasterComponentConfig::merger_queue_max_size() const {
  return merger_queue_max_size_;
}
inline void MasterComponentConfig::set_merger_queue_max_size(::google::protobuf::int32 value) {
  set_has_merger_queue_max_size();
  merger_queue_max_size_ = value;
}

// repeated .artm.ScoreConfig score_config = 9;
inline int MasterComponentConfig::score_config_size() const {
  return score_config_.size();
}
inline void MasterComponentConfig::clear_score_config() {
  score_config_.Clear();
}
inline const ::artm::ScoreConfig& MasterComponentConfig::score_config(int index) const {
  return score_config_.Get(index);
}
inline ::artm::ScoreConfig* MasterComponentConfig::mutable_score_config(int index) {
  return score_config_.Mutable(index);
}
inline ::artm::ScoreConfig* MasterComponentConfig::add_score_config() {
  return score_config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >&
MasterComponentConfig::score_config() const {
  return score_config_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::ScoreConfig >*
MasterComponentConfig::mutable_score_config() {
  return &score_config_;
}

// optional bool online_batch_processing = 13 [default = false];
inline bool MasterComponentConfig::has_online_batch_processing() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MasterComponentConfig::set_has_online_batch_processing() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MasterComponentConfig::clear_has_online_batch_processing() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MasterComponentConfig::clear_online_batch_processing() {
  online_batch_processing_ = false;
  clear_has_online_batch_processing();
}
inline bool MasterComponentConfig::online_batch_processing() const {
  return online_batch_processing_;
}
inline void MasterComponentConfig::set_online_batch_processing(bool value) {
  set_has_online_batch_processing();
  online_batch_processing_ = value;
}

// optional string disk_cache_path = 15;
inline bool MasterComponentConfig::has_disk_cache_path() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MasterComponentConfig::set_has_disk_cache_path() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MasterComponentConfig::clear_has_disk_cache_path() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MasterComponentConfig::clear_disk_cache_path() {
  if (disk_cache_path_ != &::google::protobuf::internal::GetEmptyString()) {
    disk_cache_path_->clear();
  }
  clear_has_disk_cache_path();
}
inline const ::std::string& MasterComponentConfig::disk_cache_path() const {
  return *disk_cache_path_;
}
inline void MasterComponentConfig::set_disk_cache_path(const ::std::string& value) {
  set_has_disk_cache_path();
  if (disk_cache_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_cache_path_ = new ::std::string;
  }
  disk_cache_path_->assign(value);
}
inline void MasterComponentConfig::set_disk_cache_path(const char* value) {
  set_has_disk_cache_path();
  if (disk_cache_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_cache_path_ = new ::std::string;
  }
  disk_cache_path_->assign(value);
}
inline void MasterComponentConfig::set_disk_cache_path(const char* value, size_t size) {
  set_has_disk_cache_path();
  if (disk_cache_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_cache_path_ = new ::std::string;
  }
  disk_cache_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterComponentConfig::mutable_disk_cache_path() {
  set_has_disk_cache_path();
  if (disk_cache_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_cache_path_ = new ::std::string;
  }
  return disk_cache_path_;
}
inline ::std::string* MasterComponentConfig::release_disk_cache_path() {
  clear_has_disk_cache_path();
  if (disk_cache_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = disk_cache_path_;
    disk_cache_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MasterComponentConfig::set_allocated_disk_cache_path(::std::string* disk_cache_path) {
  if (disk_cache_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete disk_cache_path_;
  }
  if (disk_cache_path) {
    set_has_disk_cache_path();
    disk_cache_path_ = disk_cache_path;
  } else {
    clear_has_disk_cache_path();
    disk_cache_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// RegularizerSettings

// optional string name = 1;
inline bool RegularizerSettings::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularizerSettings::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularizerSettings::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularizerSettings::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegularizerSettings::name() const {
  return *name_;
}
inline void RegularizerSettings::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerSettings::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerSettings::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerSettings::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegularizerSettings::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizerSettings::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional double tau = 2;
inline bool RegularizerSettings::has_tau() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularizerSettings::set_has_tau() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularizerSettings::clear_has_tau() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularizerSettings::clear_tau() {
  tau_ = 0;
  clear_has_tau();
}
inline double RegularizerSettings::tau() const {
  return tau_;
}
inline void RegularizerSettings::set_tau(double value) {
  set_has_tau();
  tau_ = value;
}

// optional bool use_relative_regularization = 3;
inline bool RegularizerSettings::has_use_relative_regularization() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularizerSettings::set_has_use_relative_regularization() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularizerSettings::clear_has_use_relative_regularization() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularizerSettings::clear_use_relative_regularization() {
  use_relative_regularization_ = false;
  clear_has_use_relative_regularization();
}
inline bool RegularizerSettings::use_relative_regularization() const {
  return use_relative_regularization_;
}
inline void RegularizerSettings::set_use_relative_regularization(bool value) {
  set_has_use_relative_regularization();
  use_relative_regularization_ = value;
}

// optional double gamma = 4;
inline bool RegularizerSettings::has_gamma() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegularizerSettings::set_has_gamma() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegularizerSettings::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegularizerSettings::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline double RegularizerSettings::gamma() const {
  return gamma_;
}
inline void RegularizerSettings::set_gamma(double value) {
  set_has_gamma();
  gamma_ = value;
}

// -------------------------------------------------------------------

// ModelConfig

// optional string name = 1 [default = "@model"];
inline bool ModelConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelConfig::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& ModelConfig::name() const {
  return *name_;
}
inline void ModelConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* ModelConfig::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 topics_count = 2 [default = 32];
inline bool ModelConfig::has_topics_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelConfig::set_has_topics_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelConfig::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelConfig::clear_topics_count() {
  topics_count_ = 32;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 ModelConfig::topics_count() const {
  return topics_count_;
}
inline void ModelConfig::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// repeated string topic_name = 3;
inline int ModelConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void ModelConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& ModelConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* ModelConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void ModelConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void ModelConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void ModelConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void ModelConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_topic_name() {
  return &topic_name_;
}

// optional bool enabled = 4 [default = true];
inline bool ModelConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool ModelConfig::enabled() const {
  return enabled_;
}
inline void ModelConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional int32 inner_iterations_count = 5 [default = 10];
inline bool ModelConfig::has_inner_iterations_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelConfig::set_has_inner_iterations_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelConfig::clear_has_inner_iterations_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelConfig::clear_inner_iterations_count() {
  inner_iterations_count_ = 10;
  clear_has_inner_iterations_count();
}
inline ::google::protobuf::int32 ModelConfig::inner_iterations_count() const {
  return inner_iterations_count_;
}
inline void ModelConfig::set_inner_iterations_count(::google::protobuf::int32 value) {
  set_has_inner_iterations_count();
  inner_iterations_count_ = value;
}

// optional string field_name = 6 [default = "@body"];
inline bool ModelConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModelConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModelConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModelConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& ModelConfig::field_name() const {
  return *field_name_;
}
inline void ModelConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ModelConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ModelConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* ModelConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 7 [default = "@global"];
inline bool ModelConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModelConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModelConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModelConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& ModelConfig::stream_name() const {
  return *stream_name_;
}
inline void ModelConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ModelConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ModelConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* ModelConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void ModelConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// repeated string score_name = 8;
inline int ModelConfig::score_name_size() const {
  return score_name_.size();
}
inline void ModelConfig::clear_score_name() {
  score_name_.Clear();
}
inline const ::std::string& ModelConfig::score_name(int index) const {
  return score_name_.Get(index);
}
inline ::std::string* ModelConfig::mutable_score_name(int index) {
  return score_name_.Mutable(index);
}
inline void ModelConfig::set_score_name(int index, const ::std::string& value) {
  score_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_score_name(int index, const char* value) {
  score_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_score_name(int index, const char* value, size_t size) {
  score_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_score_name() {
  return score_name_.Add();
}
inline void ModelConfig::add_score_name(const ::std::string& value) {
  score_name_.Add()->assign(value);
}
inline void ModelConfig::add_score_name(const char* value) {
  score_name_.Add()->assign(value);
}
inline void ModelConfig::add_score_name(const char* value, size_t size) {
  score_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::score_name() const {
  return score_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_score_name() {
  return &score_name_;
}

// optional bool reuse_theta = 9 [default = false];
inline bool ModelConfig::has_reuse_theta() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ModelConfig::set_has_reuse_theta() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ModelConfig::clear_has_reuse_theta() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ModelConfig::clear_reuse_theta() {
  reuse_theta_ = false;
  clear_has_reuse_theta();
}
inline bool ModelConfig::reuse_theta() const {
  return reuse_theta_;
}
inline void ModelConfig::set_reuse_theta(bool value) {
  set_has_reuse_theta();
  reuse_theta_ = value;
}

// repeated string regularizer_name = 10;
inline int ModelConfig::regularizer_name_size() const {
  return regularizer_name_.size();
}
inline void ModelConfig::clear_regularizer_name() {
  regularizer_name_.Clear();
}
inline const ::std::string& ModelConfig::regularizer_name(int index) const {
  return regularizer_name_.Get(index);
}
inline ::std::string* ModelConfig::mutable_regularizer_name(int index) {
  return regularizer_name_.Mutable(index);
}
inline void ModelConfig::set_regularizer_name(int index, const ::std::string& value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_regularizer_name(int index, const char* value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_regularizer_name(int index, const char* value, size_t size) {
  regularizer_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_regularizer_name() {
  return regularizer_name_.Add();
}
inline void ModelConfig::add_regularizer_name(const ::std::string& value) {
  regularizer_name_.Add()->assign(value);
}
inline void ModelConfig::add_regularizer_name(const char* value) {
  regularizer_name_.Add()->assign(value);
}
inline void ModelConfig::add_regularizer_name(const char* value, size_t size) {
  regularizer_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::regularizer_name() const {
  return regularizer_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_regularizer_name() {
  return &regularizer_name_;
}

// repeated double regularizer_tau = 11;
inline int ModelConfig::regularizer_tau_size() const {
  return regularizer_tau_.size();
}
inline void ModelConfig::clear_regularizer_tau() {
  regularizer_tau_.Clear();
}
inline double ModelConfig::regularizer_tau(int index) const {
  return regularizer_tau_.Get(index);
}
inline void ModelConfig::set_regularizer_tau(int index, double value) {
  regularizer_tau_.Set(index, value);
}
inline void ModelConfig::add_regularizer_tau(double value) {
  regularizer_tau_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ModelConfig::regularizer_tau() const {
  return regularizer_tau_;
}
inline ::google::protobuf::RepeatedField< double >*
ModelConfig::mutable_regularizer_tau() {
  return &regularizer_tau_;
}

// repeated string class_id = 12;
inline int ModelConfig::class_id_size() const {
  return class_id_.size();
}
inline void ModelConfig::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& ModelConfig::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* ModelConfig::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void ModelConfig::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void ModelConfig::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfig::add_class_id() {
  return class_id_.Add();
}
inline void ModelConfig::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void ModelConfig::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void ModelConfig::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelConfig::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelConfig::mutable_class_id() {
  return &class_id_;
}

// repeated float class_weight = 13;
inline int ModelConfig::class_weight_size() const {
  return class_weight_.size();
}
inline void ModelConfig::clear_class_weight() {
  class_weight_.Clear();
}
inline float ModelConfig::class_weight(int index) const {
  return class_weight_.Get(index);
}
inline void ModelConfig::set_class_weight(int index, float value) {
  class_weight_.Set(index, value);
}
inline void ModelConfig::add_class_weight(float value) {
  class_weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelConfig::class_weight() const {
  return class_weight_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelConfig::mutable_class_weight() {
  return &class_weight_;
}

// optional bool use_sparse_bow = 14 [default = true];
inline bool ModelConfig::has_use_sparse_bow() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ModelConfig::set_has_use_sparse_bow() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ModelConfig::clear_has_use_sparse_bow() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ModelConfig::clear_use_sparse_bow() {
  use_sparse_bow_ = true;
  clear_has_use_sparse_bow();
}
inline bool ModelConfig::use_sparse_bow() const {
  return use_sparse_bow_;
}
inline void ModelConfig::set_use_sparse_bow(bool value) {
  set_has_use_sparse_bow();
  use_sparse_bow_ = value;
}

// optional bool use_random_theta = 15 [default = false];
inline bool ModelConfig::has_use_random_theta() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ModelConfig::set_has_use_random_theta() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ModelConfig::clear_has_use_random_theta() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ModelConfig::clear_use_random_theta() {
  use_random_theta_ = false;
  clear_has_use_random_theta();
}
inline bool ModelConfig::use_random_theta() const {
  return use_random_theta_;
}
inline void ModelConfig::set_use_random_theta(bool value) {
  set_has_use_random_theta();
  use_random_theta_ = value;
}

// optional bool use_new_tokens = 16 [default = true];
inline bool ModelConfig::has_use_new_tokens() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ModelConfig::set_has_use_new_tokens() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ModelConfig::clear_has_use_new_tokens() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ModelConfig::clear_use_new_tokens() {
  use_new_tokens_ = true;
  clear_has_use_new_tokens();
}
inline bool ModelConfig::use_new_tokens() const {
  return use_new_tokens_;
}
inline void ModelConfig::set_use_new_tokens(bool value) {
  set_has_use_new_tokens();
  use_new_tokens_ = value;
}

// optional bool opt_for_avx = 17 [default = true];
inline bool ModelConfig::has_opt_for_avx() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ModelConfig::set_has_opt_for_avx() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ModelConfig::clear_has_opt_for_avx() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ModelConfig::clear_opt_for_avx() {
  opt_for_avx_ = true;
  clear_has_opt_for_avx();
}
inline bool ModelConfig::opt_for_avx() const {
  return opt_for_avx_;
}
inline void ModelConfig::set_opt_for_avx(bool value) {
  set_has_opt_for_avx();
  opt_for_avx_ = value;
}

// repeated .artm.RegularizerSettings regularizer_settings = 18;
inline int ModelConfig::regularizer_settings_size() const {
  return regularizer_settings_.size();
}
inline void ModelConfig::clear_regularizer_settings() {
  regularizer_settings_.Clear();
}
inline const ::artm::RegularizerSettings& ModelConfig::regularizer_settings(int index) const {
  return regularizer_settings_.Get(index);
}
inline ::artm::RegularizerSettings* ModelConfig::mutable_regularizer_settings(int index) {
  return regularizer_settings_.Mutable(index);
}
inline ::artm::RegularizerSettings* ModelConfig::add_regularizer_settings() {
  return regularizer_settings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >&
ModelConfig::regularizer_settings() const {
  return regularizer_settings_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >*
ModelConfig::mutable_regularizer_settings() {
  return &regularizer_settings_;
}

// -------------------------------------------------------------------

// RegularizerConfig

// optional string name = 1;
inline bool RegularizerConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularizerConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularizerConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularizerConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegularizerConfig::name() const {
  return *name_;
}
inline void RegularizerConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegularizerConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizerConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.RegularizerConfig.Type type = 2;
inline bool RegularizerConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularizerConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularizerConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularizerConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::RegularizerConfig_Type RegularizerConfig::type() const {
  return static_cast< ::artm::RegularizerConfig_Type >(type_);
}
inline void RegularizerConfig::set_type(::artm::RegularizerConfig_Type value) {
  assert(::artm::RegularizerConfig_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes config = 3;
inline bool RegularizerConfig::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularizerConfig::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularizerConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularizerConfig::clear_config() {
  if (config_ != &::google::protobuf::internal::GetEmptyString()) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& RegularizerConfig::config() const {
  return *config_;
}
inline void RegularizerConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void RegularizerConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void RegularizerConfig::set_config(const void* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerConfig::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* RegularizerConfig::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizerConfig::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::GetEmptyString()) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SmoothSparseThetaConfig

// repeated string topic_name = 1;
inline int SmoothSparseThetaConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void SmoothSparseThetaConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& SmoothSparseThetaConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* SmoothSparseThetaConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void SmoothSparseThetaConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SmoothSparseThetaConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SmoothSparseThetaConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmoothSparseThetaConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void SmoothSparseThetaConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void SmoothSparseThetaConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void SmoothSparseThetaConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmoothSparseThetaConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmoothSparseThetaConfig::mutable_topic_name() {
  return &topic_name_;
}

// repeated float alpha_iter = 2;
inline int SmoothSparseThetaConfig::alpha_iter_size() const {
  return alpha_iter_.size();
}
inline void SmoothSparseThetaConfig::clear_alpha_iter() {
  alpha_iter_.Clear();
}
inline float SmoothSparseThetaConfig::alpha_iter(int index) const {
  return alpha_iter_.Get(index);
}
inline void SmoothSparseThetaConfig::set_alpha_iter(int index, float value) {
  alpha_iter_.Set(index, value);
}
inline void SmoothSparseThetaConfig::add_alpha_iter(float value) {
  alpha_iter_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SmoothSparseThetaConfig::alpha_iter() const {
  return alpha_iter_;
}
inline ::google::protobuf::RepeatedField< float >*
SmoothSparseThetaConfig::mutable_alpha_iter() {
  return &alpha_iter_;
}

// -------------------------------------------------------------------

// SmoothSparsePhiConfig

// repeated string topic_name = 1;
inline int SmoothSparsePhiConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void SmoothSparsePhiConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& SmoothSparsePhiConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* SmoothSparsePhiConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void SmoothSparsePhiConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SmoothSparsePhiConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SmoothSparsePhiConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmoothSparsePhiConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void SmoothSparsePhiConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void SmoothSparsePhiConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void SmoothSparsePhiConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmoothSparsePhiConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmoothSparsePhiConfig::mutable_topic_name() {
  return &topic_name_;
}

// repeated string class_id = 2;
inline int SmoothSparsePhiConfig::class_id_size() const {
  return class_id_.size();
}
inline void SmoothSparsePhiConfig::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& SmoothSparsePhiConfig::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* SmoothSparsePhiConfig::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void SmoothSparsePhiConfig::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void SmoothSparsePhiConfig::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void SmoothSparsePhiConfig::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmoothSparsePhiConfig::add_class_id() {
  return class_id_.Add();
}
inline void SmoothSparsePhiConfig::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void SmoothSparsePhiConfig::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void SmoothSparsePhiConfig::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmoothSparsePhiConfig::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmoothSparsePhiConfig::mutable_class_id() {
  return &class_id_;
}

// optional string dictionary_name = 3;
inline bool SmoothSparsePhiConfig::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmoothSparsePhiConfig::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmoothSparsePhiConfig::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmoothSparsePhiConfig::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& SmoothSparsePhiConfig::dictionary_name() const {
  return *dictionary_name_;
}
inline void SmoothSparsePhiConfig::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void SmoothSparsePhiConfig::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void SmoothSparsePhiConfig::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmoothSparsePhiConfig::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* SmoothSparsePhiConfig::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SmoothSparsePhiConfig::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// DecorrelatorPhiConfig

// repeated string topic_name = 1;
inline int DecorrelatorPhiConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void DecorrelatorPhiConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& DecorrelatorPhiConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* DecorrelatorPhiConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void DecorrelatorPhiConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void DecorrelatorPhiConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void DecorrelatorPhiConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DecorrelatorPhiConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void DecorrelatorPhiConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void DecorrelatorPhiConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void DecorrelatorPhiConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DecorrelatorPhiConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DecorrelatorPhiConfig::mutable_topic_name() {
  return &topic_name_;
}

// repeated string class_id = 2;
inline int DecorrelatorPhiConfig::class_id_size() const {
  return class_id_.size();
}
inline void DecorrelatorPhiConfig::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& DecorrelatorPhiConfig::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* DecorrelatorPhiConfig::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void DecorrelatorPhiConfig::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void DecorrelatorPhiConfig::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void DecorrelatorPhiConfig::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DecorrelatorPhiConfig::add_class_id() {
  return class_id_.Add();
}
inline void DecorrelatorPhiConfig::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void DecorrelatorPhiConfig::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void DecorrelatorPhiConfig::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DecorrelatorPhiConfig::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DecorrelatorPhiConfig::mutable_class_id() {
  return &class_id_;
}

// -------------------------------------------------------------------

// MultiLanguagePhiConfig

// -------------------------------------------------------------------

// LabelRegularizationPhiConfig

// repeated string topic_name = 1;
inline int LabelRegularizationPhiConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void LabelRegularizationPhiConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& LabelRegularizationPhiConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* LabelRegularizationPhiConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void LabelRegularizationPhiConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void LabelRegularizationPhiConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void LabelRegularizationPhiConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelRegularizationPhiConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void LabelRegularizationPhiConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void LabelRegularizationPhiConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void LabelRegularizationPhiConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LabelRegularizationPhiConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LabelRegularizationPhiConfig::mutable_topic_name() {
  return &topic_name_;
}

// repeated string class_id = 2;
inline int LabelRegularizationPhiConfig::class_id_size() const {
  return class_id_.size();
}
inline void LabelRegularizationPhiConfig::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& LabelRegularizationPhiConfig::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* LabelRegularizationPhiConfig::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void LabelRegularizationPhiConfig::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void LabelRegularizationPhiConfig::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void LabelRegularizationPhiConfig::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelRegularizationPhiConfig::add_class_id() {
  return class_id_.Add();
}
inline void LabelRegularizationPhiConfig::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void LabelRegularizationPhiConfig::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void LabelRegularizationPhiConfig::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LabelRegularizationPhiConfig::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LabelRegularizationPhiConfig::mutable_class_id() {
  return &class_id_;
}

// optional string dictionary_name = 3;
inline bool LabelRegularizationPhiConfig::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LabelRegularizationPhiConfig::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LabelRegularizationPhiConfig::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LabelRegularizationPhiConfig::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& LabelRegularizationPhiConfig::dictionary_name() const {
  return *dictionary_name_;
}
inline void LabelRegularizationPhiConfig::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void LabelRegularizationPhiConfig::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void LabelRegularizationPhiConfig::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelRegularizationPhiConfig::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* LabelRegularizationPhiConfig::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void LabelRegularizationPhiConfig::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SpecifiedSparsePhiConfig

// repeated string topic_name = 1;
inline int SpecifiedSparsePhiConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void SpecifiedSparsePhiConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& SpecifiedSparsePhiConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* SpecifiedSparsePhiConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void SpecifiedSparsePhiConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SpecifiedSparsePhiConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SpecifiedSparsePhiConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpecifiedSparsePhiConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void SpecifiedSparsePhiConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void SpecifiedSparsePhiConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void SpecifiedSparsePhiConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SpecifiedSparsePhiConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SpecifiedSparsePhiConfig::mutable_topic_name() {
  return &topic_name_;
}

// optional string class_id = 2 [default = "@default_class"];
inline bool SpecifiedSparsePhiConfig::has_class_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpecifiedSparsePhiConfig::set_has_class_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpecifiedSparsePhiConfig::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpecifiedSparsePhiConfig::clear_class_id() {
  if (class_id_ != _default_class_id_) {
    class_id_->assign(*_default_class_id_);
  }
  clear_has_class_id();
}
inline const ::std::string& SpecifiedSparsePhiConfig::class_id() const {
  return *class_id_;
}
inline void SpecifiedSparsePhiConfig::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void SpecifiedSparsePhiConfig::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void SpecifiedSparsePhiConfig::set_class_id(const char* value, size_t size) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpecifiedSparsePhiConfig::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string(*_default_class_id_);
  }
  return class_id_;
}
inline ::std::string* SpecifiedSparsePhiConfig::release_class_id() {
  clear_has_class_id();
  if (class_id_ == _default_class_id_) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
    return temp;
  }
}
inline void SpecifiedSparsePhiConfig::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != _default_class_id_) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
  }
}

// optional int32 max_elements_count = 3 [default = 20];
inline bool SpecifiedSparsePhiConfig::has_max_elements_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpecifiedSparsePhiConfig::set_has_max_elements_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpecifiedSparsePhiConfig::clear_has_max_elements_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpecifiedSparsePhiConfig::clear_max_elements_count() {
  max_elements_count_ = 20;
  clear_has_max_elements_count();
}
inline ::google::protobuf::int32 SpecifiedSparsePhiConfig::max_elements_count() const {
  return max_elements_count_;
}
inline void SpecifiedSparsePhiConfig::set_max_elements_count(::google::protobuf::int32 value) {
  set_has_max_elements_count();
  max_elements_count_ = value;
}

// optional float probability_threshold = 4 [default = 0.99];
inline bool SpecifiedSparsePhiConfig::has_probability_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpecifiedSparsePhiConfig::set_has_probability_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpecifiedSparsePhiConfig::clear_has_probability_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpecifiedSparsePhiConfig::clear_probability_threshold() {
  probability_threshold_ = 0.99f;
  clear_has_probability_threshold();
}
inline float SpecifiedSparsePhiConfig::probability_threshold() const {
  return probability_threshold_;
}
inline void SpecifiedSparsePhiConfig::set_probability_threshold(float value) {
  set_has_probability_threshold();
  probability_threshold_ = value;
}

// optional .artm.SpecifiedSparsePhiConfig.Mode mode = 5 [default = SparseTopics];
inline bool SpecifiedSparsePhiConfig::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpecifiedSparsePhiConfig::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpecifiedSparsePhiConfig::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpecifiedSparsePhiConfig::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::artm::SpecifiedSparsePhiConfig_Mode SpecifiedSparsePhiConfig::mode() const {
  return static_cast< ::artm::SpecifiedSparsePhiConfig_Mode >(mode_);
}
inline void SpecifiedSparsePhiConfig::set_mode(::artm::SpecifiedSparsePhiConfig_Mode value) {
  assert(::artm::SpecifiedSparsePhiConfig_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// ImproveCoherencePhiConfig

// repeated string topic_name = 1;
inline int ImproveCoherencePhiConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void ImproveCoherencePhiConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& ImproveCoherencePhiConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* ImproveCoherencePhiConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void ImproveCoherencePhiConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void ImproveCoherencePhiConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void ImproveCoherencePhiConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImproveCoherencePhiConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void ImproveCoherencePhiConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void ImproveCoherencePhiConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void ImproveCoherencePhiConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImproveCoherencePhiConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImproveCoherencePhiConfig::mutable_topic_name() {
  return &topic_name_;
}

// repeated string class_id = 2;
inline int ImproveCoherencePhiConfig::class_id_size() const {
  return class_id_.size();
}
inline void ImproveCoherencePhiConfig::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& ImproveCoherencePhiConfig::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* ImproveCoherencePhiConfig::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void ImproveCoherencePhiConfig::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void ImproveCoherencePhiConfig::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void ImproveCoherencePhiConfig::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImproveCoherencePhiConfig::add_class_id() {
  return class_id_.Add();
}
inline void ImproveCoherencePhiConfig::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void ImproveCoherencePhiConfig::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void ImproveCoherencePhiConfig::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImproveCoherencePhiConfig::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImproveCoherencePhiConfig::mutable_class_id() {
  return &class_id_;
}

// optional string dictionary_name = 3;
inline bool ImproveCoherencePhiConfig::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImproveCoherencePhiConfig::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImproveCoherencePhiConfig::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImproveCoherencePhiConfig::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& ImproveCoherencePhiConfig::dictionary_name() const {
  return *dictionary_name_;
}
inline void ImproveCoherencePhiConfig::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void ImproveCoherencePhiConfig::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void ImproveCoherencePhiConfig::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImproveCoherencePhiConfig::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* ImproveCoherencePhiConfig::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ImproveCoherencePhiConfig::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// RegularizerInternalState

// optional string name = 1;
inline bool RegularizerInternalState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularizerInternalState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularizerInternalState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularizerInternalState::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegularizerInternalState::name() const {
  return *name_;
}
inline void RegularizerInternalState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerInternalState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegularizerInternalState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerInternalState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegularizerInternalState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizerInternalState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.RegularizerInternalState.Type type = 2;
inline bool RegularizerInternalState::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularizerInternalState::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularizerInternalState::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularizerInternalState::clear_type() {
  type_ = 3;
  clear_has_type();
}
inline ::artm::RegularizerInternalState_Type RegularizerInternalState::type() const {
  return static_cast< ::artm::RegularizerInternalState_Type >(type_);
}
inline void RegularizerInternalState::set_type(::artm::RegularizerInternalState_Type value) {
  assert(::artm::RegularizerInternalState_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes data = 3;
inline bool RegularizerInternalState::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularizerInternalState::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularizerInternalState::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularizerInternalState::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RegularizerInternalState::data() const {
  return *data_;
}
inline void RegularizerInternalState::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void RegularizerInternalState::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void RegularizerInternalState::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizerInternalState::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* RegularizerInternalState::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizerInternalState::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// MultiLanguagePhiInternalState

// optional int32 no_regularization_calls = 1 [default = 0];
inline bool MultiLanguagePhiInternalState::has_no_regularization_calls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiLanguagePhiInternalState::set_has_no_regularization_calls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiLanguagePhiInternalState::clear_has_no_regularization_calls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiLanguagePhiInternalState::clear_no_regularization_calls() {
  no_regularization_calls_ = 0;
  clear_has_no_regularization_calls();
}
inline ::google::protobuf::int32 MultiLanguagePhiInternalState::no_regularization_calls() const {
  return no_regularization_calls_;
}
inline void MultiLanguagePhiInternalState::set_no_regularization_calls(::google::protobuf::int32 value) {
  set_has_no_regularization_calls();
  no_regularization_calls_ = value;
}

// -------------------------------------------------------------------

// DictionaryConfig

// optional string name = 1;
inline bool DictionaryConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DictionaryConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DictionaryConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DictionaryConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DictionaryConfig::name() const {
  return *name_;
}
inline void DictionaryConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DictionaryConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DictionaryConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DictionaryConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DictionaryConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .artm.DictionaryEntry entry = 2;
inline int DictionaryConfig::entry_size() const {
  return entry_.size();
}
inline void DictionaryConfig::clear_entry() {
  entry_.Clear();
}
inline const ::artm::DictionaryEntry& DictionaryConfig::entry(int index) const {
  return entry_.Get(index);
}
inline ::artm::DictionaryEntry* DictionaryConfig::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::artm::DictionaryEntry* DictionaryConfig::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >&
DictionaryConfig::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::DictionaryEntry >*
DictionaryConfig::mutable_entry() {
  return &entry_;
}

// optional int32 total_token_count = 3;
inline bool DictionaryConfig::has_total_token_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DictionaryConfig::set_has_total_token_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DictionaryConfig::clear_has_total_token_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DictionaryConfig::clear_total_token_count() {
  total_token_count_ = 0;
  clear_has_total_token_count();
}
inline ::google::protobuf::int32 DictionaryConfig::total_token_count() const {
  return total_token_count_;
}
inline void DictionaryConfig::set_total_token_count(::google::protobuf::int32 value) {
  set_has_total_token_count();
  total_token_count_ = value;
}

// optional int32 total_items_count = 4;
inline bool DictionaryConfig::has_total_items_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DictionaryConfig::set_has_total_items_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DictionaryConfig::clear_has_total_items_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DictionaryConfig::clear_total_items_count() {
  total_items_count_ = 0;
  clear_has_total_items_count();
}
inline ::google::protobuf::int32 DictionaryConfig::total_items_count() const {
  return total_items_count_;
}
inline void DictionaryConfig::set_total_items_count(::google::protobuf::int32 value) {
  set_has_total_items_count();
  total_items_count_ = value;
}

// optional .artm.DictionaryCoocurenceEntries cooc_entries = 5;
inline bool DictionaryConfig::has_cooc_entries() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DictionaryConfig::set_has_cooc_entries() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DictionaryConfig::clear_has_cooc_entries() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DictionaryConfig::clear_cooc_entries() {
  if (cooc_entries_ != NULL) cooc_entries_->::artm::DictionaryCoocurenceEntries::Clear();
  clear_has_cooc_entries();
}
inline const ::artm::DictionaryCoocurenceEntries& DictionaryConfig::cooc_entries() const {
  return cooc_entries_ != NULL ? *cooc_entries_ : *default_instance_->cooc_entries_;
}
inline ::artm::DictionaryCoocurenceEntries* DictionaryConfig::mutable_cooc_entries() {
  set_has_cooc_entries();
  if (cooc_entries_ == NULL) cooc_entries_ = new ::artm::DictionaryCoocurenceEntries;
  return cooc_entries_;
}
inline ::artm::DictionaryCoocurenceEntries* DictionaryConfig::release_cooc_entries() {
  clear_has_cooc_entries();
  ::artm::DictionaryCoocurenceEntries* temp = cooc_entries_;
  cooc_entries_ = NULL;
  return temp;
}
inline void DictionaryConfig::set_allocated_cooc_entries(::artm::DictionaryCoocurenceEntries* cooc_entries) {
  delete cooc_entries_;
  cooc_entries_ = cooc_entries;
  if (cooc_entries) {
    set_has_cooc_entries();
  } else {
    clear_has_cooc_entries();
  }
}

// -------------------------------------------------------------------

// DictionaryEntry

// optional string key_token = 1;
inline bool DictionaryEntry::has_key_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DictionaryEntry::set_has_key_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DictionaryEntry::clear_has_key_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DictionaryEntry::clear_key_token() {
  if (key_token_ != &::google::protobuf::internal::GetEmptyString()) {
    key_token_->clear();
  }
  clear_has_key_token();
}
inline const ::std::string& DictionaryEntry::key_token() const {
  return *key_token_;
}
inline void DictionaryEntry::set_key_token(const ::std::string& value) {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::GetEmptyString()) {
    key_token_ = new ::std::string;
  }
  key_token_->assign(value);
}
inline void DictionaryEntry::set_key_token(const char* value) {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::GetEmptyString()) {
    key_token_ = new ::std::string;
  }
  key_token_->assign(value);
}
inline void DictionaryEntry::set_key_token(const char* value, size_t size) {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::GetEmptyString()) {
    key_token_ = new ::std::string;
  }
  key_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryEntry::mutable_key_token() {
  set_has_key_token();
  if (key_token_ == &::google::protobuf::internal::GetEmptyString()) {
    key_token_ = new ::std::string;
  }
  return key_token_;
}
inline ::std::string* DictionaryEntry::release_key_token() {
  clear_has_key_token();
  if (key_token_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = key_token_;
    key_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DictionaryEntry::set_allocated_key_token(::std::string* key_token) {
  if (key_token_ != &::google::protobuf::internal::GetEmptyString()) {
    delete key_token_;
  }
  if (key_token) {
    set_has_key_token();
    key_token_ = key_token;
  } else {
    clear_has_key_token();
    key_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string class_id = 2;
inline bool DictionaryEntry::has_class_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DictionaryEntry::set_has_class_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DictionaryEntry::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DictionaryEntry::clear_class_id() {
  if (class_id_ != &::google::protobuf::internal::GetEmptyString()) {
    class_id_->clear();
  }
  clear_has_class_id();
}
inline const ::std::string& DictionaryEntry::class_id() const {
  return *class_id_;
}
inline void DictionaryEntry::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void DictionaryEntry::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void DictionaryEntry::set_class_id(const char* value, size_t size) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryEntry::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  return class_id_;
}
inline ::std::string* DictionaryEntry::release_class_id() {
  clear_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DictionaryEntry::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional float value = 3;
inline bool DictionaryEntry::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DictionaryEntry::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DictionaryEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DictionaryEntry::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float DictionaryEntry::value() const {
  return value_;
}
inline void DictionaryEntry::set_value(float value) {
  set_has_value();
  value_ = value;
}

// repeated string value_tokens = 4;
inline int DictionaryEntry::value_tokens_size() const {
  return value_tokens_.size();
}
inline void DictionaryEntry::clear_value_tokens() {
  value_tokens_.Clear();
}
inline const ::std::string& DictionaryEntry::value_tokens(int index) const {
  return value_tokens_.Get(index);
}
inline ::std::string* DictionaryEntry::mutable_value_tokens(int index) {
  return value_tokens_.Mutable(index);
}
inline void DictionaryEntry::set_value_tokens(int index, const ::std::string& value) {
  value_tokens_.Mutable(index)->assign(value);
}
inline void DictionaryEntry::set_value_tokens(int index, const char* value) {
  value_tokens_.Mutable(index)->assign(value);
}
inline void DictionaryEntry::set_value_tokens(int index, const char* value, size_t size) {
  value_tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DictionaryEntry::add_value_tokens() {
  return value_tokens_.Add();
}
inline void DictionaryEntry::add_value_tokens(const ::std::string& value) {
  value_tokens_.Add()->assign(value);
}
inline void DictionaryEntry::add_value_tokens(const char* value) {
  value_tokens_.Add()->assign(value);
}
inline void DictionaryEntry::add_value_tokens(const char* value, size_t size) {
  value_tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DictionaryEntry::value_tokens() const {
  return value_tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DictionaryEntry::mutable_value_tokens() {
  return &value_tokens_;
}

// optional .artm.FloatArray values = 5;
inline bool DictionaryEntry::has_values() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DictionaryEntry::set_has_values() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DictionaryEntry::clear_has_values() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DictionaryEntry::clear_values() {
  if (values_ != NULL) values_->::artm::FloatArray::Clear();
  clear_has_values();
}
inline const ::artm::FloatArray& DictionaryEntry::values() const {
  return values_ != NULL ? *values_ : *default_instance_->values_;
}
inline ::artm::FloatArray* DictionaryEntry::mutable_values() {
  set_has_values();
  if (values_ == NULL) values_ = new ::artm::FloatArray;
  return values_;
}
inline ::artm::FloatArray* DictionaryEntry::release_values() {
  clear_has_values();
  ::artm::FloatArray* temp = values_;
  values_ = NULL;
  return temp;
}
inline void DictionaryEntry::set_allocated_values(::artm::FloatArray* values) {
  delete values_;
  values_ = values;
  if (values) {
    set_has_values();
  } else {
    clear_has_values();
  }
}

// optional int32 token_count = 6;
inline bool DictionaryEntry::has_token_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DictionaryEntry::set_has_token_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DictionaryEntry::clear_has_token_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DictionaryEntry::clear_token_count() {
  token_count_ = 0;
  clear_has_token_count();
}
inline ::google::protobuf::int32 DictionaryEntry::token_count() const {
  return token_count_;
}
inline void DictionaryEntry::set_token_count(::google::protobuf::int32 value) {
  set_has_token_count();
  token_count_ = value;
}

// optional int32 items_count = 7;
inline bool DictionaryEntry::has_items_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DictionaryEntry::set_has_items_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DictionaryEntry::clear_has_items_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DictionaryEntry::clear_items_count() {
  items_count_ = 0;
  clear_has_items_count();
}
inline ::google::protobuf::int32 DictionaryEntry::items_count() const {
  return items_count_;
}
inline void DictionaryEntry::set_items_count(::google::protobuf::int32 value) {
  set_has_items_count();
  items_count_ = value;
}

// -------------------------------------------------------------------

// DictionaryCoocurenceEntries

// repeated int32 first_index = 1;
inline int DictionaryCoocurenceEntries::first_index_size() const {
  return first_index_.size();
}
inline void DictionaryCoocurenceEntries::clear_first_index() {
  first_index_.Clear();
}
inline ::google::protobuf::int32 DictionaryCoocurenceEntries::first_index(int index) const {
  return first_index_.Get(index);
}
inline void DictionaryCoocurenceEntries::set_first_index(int index, ::google::protobuf::int32 value) {
  first_index_.Set(index, value);
}
inline void DictionaryCoocurenceEntries::add_first_index(::google::protobuf::int32 value) {
  first_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DictionaryCoocurenceEntries::first_index() const {
  return first_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DictionaryCoocurenceEntries::mutable_first_index() {
  return &first_index_;
}

// repeated int32 second_index = 2;
inline int DictionaryCoocurenceEntries::second_index_size() const {
  return second_index_.size();
}
inline void DictionaryCoocurenceEntries::clear_second_index() {
  second_index_.Clear();
}
inline ::google::protobuf::int32 DictionaryCoocurenceEntries::second_index(int index) const {
  return second_index_.Get(index);
}
inline void DictionaryCoocurenceEntries::set_second_index(int index, ::google::protobuf::int32 value) {
  second_index_.Set(index, value);
}
inline void DictionaryCoocurenceEntries::add_second_index(::google::protobuf::int32 value) {
  second_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DictionaryCoocurenceEntries::second_index() const {
  return second_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DictionaryCoocurenceEntries::mutable_second_index() {
  return &second_index_;
}

// repeated float items_count = 3;
inline int DictionaryCoocurenceEntries::items_count_size() const {
  return items_count_.size();
}
inline void DictionaryCoocurenceEntries::clear_items_count() {
  items_count_.Clear();
}
inline float DictionaryCoocurenceEntries::items_count(int index) const {
  return items_count_.Get(index);
}
inline void DictionaryCoocurenceEntries::set_items_count(int index, float value) {
  items_count_.Set(index, value);
}
inline void DictionaryCoocurenceEntries::add_items_count(float value) {
  items_count_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
DictionaryCoocurenceEntries::items_count() const {
  return items_count_;
}
inline ::google::protobuf::RepeatedField< float >*
DictionaryCoocurenceEntries::mutable_items_count() {
  return &items_count_;
}

// -------------------------------------------------------------------

// ScoreConfig

// optional string name = 1;
inline bool ScoreConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ScoreConfig::name() const {
  return *name_;
}
inline void ScoreConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ScoreConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ScoreConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.ScoreConfig.Type type = 2;
inline bool ScoreConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::ScoreConfig_Type ScoreConfig::type() const {
  return static_cast< ::artm::ScoreConfig_Type >(type_);
}
inline void ScoreConfig::set_type(::artm::ScoreConfig_Type value) {
  assert(::artm::ScoreConfig_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes config = 3;
inline bool ScoreConfig::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScoreConfig::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScoreConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScoreConfig::clear_config() {
  if (config_ != &::google::protobuf::internal::GetEmptyString()) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& ScoreConfig::config() const {
  return *config_;
}
inline void ScoreConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void ScoreConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void ScoreConfig::set_config(const void* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreConfig::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* ScoreConfig::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ScoreConfig::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::GetEmptyString()) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ScoreData

// optional string name = 1;
inline bool ScoreData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ScoreData::name() const {
  return *name_;
}
inline void ScoreData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScoreData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ScoreData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ScoreData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.ScoreData.Type type = 2;
inline bool ScoreData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::artm::ScoreData_Type ScoreData::type() const {
  return static_cast< ::artm::ScoreData_Type >(type_);
}
inline void ScoreData::set_type(::artm::ScoreData_Type value) {
  assert(::artm::ScoreData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes data = 3;
inline bool ScoreData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScoreData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScoreData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScoreData::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ScoreData::data() const {
  return *data_;
}
inline void ScoreData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ScoreData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ScoreData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ScoreData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ScoreData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// PerplexityScoreConfig

// optional string field_name = 1 [default = "@body"];
inline bool PerplexityScoreConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerplexityScoreConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerplexityScoreConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerplexityScoreConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& PerplexityScoreConfig::field_name() const {
  return *field_name_;
}
inline void PerplexityScoreConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void PerplexityScoreConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void PerplexityScoreConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* PerplexityScoreConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void PerplexityScoreConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 2 [default = "@global"];
inline bool PerplexityScoreConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerplexityScoreConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerplexityScoreConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerplexityScoreConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& PerplexityScoreConfig::stream_name() const {
  return *stream_name_;
}
inline void PerplexityScoreConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void PerplexityScoreConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void PerplexityScoreConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* PerplexityScoreConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void PerplexityScoreConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// optional .artm.PerplexityScoreConfig.Type model_type = 3 [default = UnigramDocumentModel];
inline bool PerplexityScoreConfig::has_model_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerplexityScoreConfig::set_has_model_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerplexityScoreConfig::clear_has_model_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerplexityScoreConfig::clear_model_type() {
  model_type_ = 0;
  clear_has_model_type();
}
inline ::artm::PerplexityScoreConfig_Type PerplexityScoreConfig::model_type() const {
  return static_cast< ::artm::PerplexityScoreConfig_Type >(model_type_);
}
inline void PerplexityScoreConfig::set_model_type(::artm::PerplexityScoreConfig_Type value) {
  assert(::artm::PerplexityScoreConfig_Type_IsValid(value));
  set_has_model_type();
  model_type_ = value;
}

// optional string dictionary_name = 4;
inline bool PerplexityScoreConfig::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerplexityScoreConfig::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerplexityScoreConfig::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerplexityScoreConfig::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& PerplexityScoreConfig::dictionary_name() const {
  return *dictionary_name_;
}
inline void PerplexityScoreConfig::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void PerplexityScoreConfig::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void PerplexityScoreConfig::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* PerplexityScoreConfig::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PerplexityScoreConfig::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional float theta_sparsity_eps = 5 [default = 1e-037];
inline bool PerplexityScoreConfig::has_theta_sparsity_eps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerplexityScoreConfig::set_has_theta_sparsity_eps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerplexityScoreConfig::clear_has_theta_sparsity_eps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerplexityScoreConfig::clear_theta_sparsity_eps() {
  theta_sparsity_eps_ = 1e-037f;
  clear_has_theta_sparsity_eps();
}
inline float PerplexityScoreConfig::theta_sparsity_eps() const {
  return theta_sparsity_eps_;
}
inline void PerplexityScoreConfig::set_theta_sparsity_eps(float value) {
  set_has_theta_sparsity_eps();
  theta_sparsity_eps_ = value;
}

// repeated string theta_sparsity_topic_name = 6;
inline int PerplexityScoreConfig::theta_sparsity_topic_name_size() const {
  return theta_sparsity_topic_name_.size();
}
inline void PerplexityScoreConfig::clear_theta_sparsity_topic_name() {
  theta_sparsity_topic_name_.Clear();
}
inline const ::std::string& PerplexityScoreConfig::theta_sparsity_topic_name(int index) const {
  return theta_sparsity_topic_name_.Get(index);
}
inline ::std::string* PerplexityScoreConfig::mutable_theta_sparsity_topic_name(int index) {
  return theta_sparsity_topic_name_.Mutable(index);
}
inline void PerplexityScoreConfig::set_theta_sparsity_topic_name(int index, const ::std::string& value) {
  theta_sparsity_topic_name_.Mutable(index)->assign(value);
}
inline void PerplexityScoreConfig::set_theta_sparsity_topic_name(int index, const char* value) {
  theta_sparsity_topic_name_.Mutable(index)->assign(value);
}
inline void PerplexityScoreConfig::set_theta_sparsity_topic_name(int index, const char* value, size_t size) {
  theta_sparsity_topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::add_theta_sparsity_topic_name() {
  return theta_sparsity_topic_name_.Add();
}
inline void PerplexityScoreConfig::add_theta_sparsity_topic_name(const ::std::string& value) {
  theta_sparsity_topic_name_.Add()->assign(value);
}
inline void PerplexityScoreConfig::add_theta_sparsity_topic_name(const char* value) {
  theta_sparsity_topic_name_.Add()->assign(value);
}
inline void PerplexityScoreConfig::add_theta_sparsity_topic_name(const char* value, size_t size) {
  theta_sparsity_topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PerplexityScoreConfig::theta_sparsity_topic_name() const {
  return theta_sparsity_topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PerplexityScoreConfig::mutable_theta_sparsity_topic_name() {
  return &theta_sparsity_topic_name_;
}

// repeated string class_id = 7;
inline int PerplexityScoreConfig::class_id_size() const {
  return class_id_.size();
}
inline void PerplexityScoreConfig::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& PerplexityScoreConfig::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* PerplexityScoreConfig::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void PerplexityScoreConfig::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void PerplexityScoreConfig::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void PerplexityScoreConfig::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PerplexityScoreConfig::add_class_id() {
  return class_id_.Add();
}
inline void PerplexityScoreConfig::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void PerplexityScoreConfig::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void PerplexityScoreConfig::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PerplexityScoreConfig::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PerplexityScoreConfig::mutable_class_id() {
  return &class_id_;
}

// -------------------------------------------------------------------

// PerplexityScore

// optional double value = 1;
inline bool PerplexityScore::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerplexityScore::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerplexityScore::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerplexityScore::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double PerplexityScore::value() const {
  return value_;
}
inline void PerplexityScore::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional double raw = 2;
inline bool PerplexityScore::has_raw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerplexityScore::set_has_raw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerplexityScore::clear_has_raw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerplexityScore::clear_raw() {
  raw_ = 0;
  clear_has_raw();
}
inline double PerplexityScore::raw() const {
  return raw_;
}
inline void PerplexityScore::set_raw(double value) {
  set_has_raw();
  raw_ = value;
}

// optional double normalizer = 3;
inline bool PerplexityScore::has_normalizer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerplexityScore::set_has_normalizer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerplexityScore::clear_has_normalizer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerplexityScore::clear_normalizer() {
  normalizer_ = 0;
  clear_has_normalizer();
}
inline double PerplexityScore::normalizer() const {
  return normalizer_;
}
inline void PerplexityScore::set_normalizer(double value) {
  set_has_normalizer();
  normalizer_ = value;
}

// optional int32 zero_words = 4;
inline bool PerplexityScore::has_zero_words() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerplexityScore::set_has_zero_words() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerplexityScore::clear_has_zero_words() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerplexityScore::clear_zero_words() {
  zero_words_ = 0;
  clear_has_zero_words();
}
inline ::google::protobuf::int32 PerplexityScore::zero_words() const {
  return zero_words_;
}
inline void PerplexityScore::set_zero_words(::google::protobuf::int32 value) {
  set_has_zero_words();
  zero_words_ = value;
}

// optional double theta_sparsity_value = 5;
inline bool PerplexityScore::has_theta_sparsity_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerplexityScore::set_has_theta_sparsity_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerplexityScore::clear_has_theta_sparsity_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerplexityScore::clear_theta_sparsity_value() {
  theta_sparsity_value_ = 0;
  clear_has_theta_sparsity_value();
}
inline double PerplexityScore::theta_sparsity_value() const {
  return theta_sparsity_value_;
}
inline void PerplexityScore::set_theta_sparsity_value(double value) {
  set_has_theta_sparsity_value();
  theta_sparsity_value_ = value;
}

// optional int32 theta_sparsity_zero_topics = 6;
inline bool PerplexityScore::has_theta_sparsity_zero_topics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerplexityScore::set_has_theta_sparsity_zero_topics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerplexityScore::clear_has_theta_sparsity_zero_topics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PerplexityScore::clear_theta_sparsity_zero_topics() {
  theta_sparsity_zero_topics_ = 0;
  clear_has_theta_sparsity_zero_topics();
}
inline ::google::protobuf::int32 PerplexityScore::theta_sparsity_zero_topics() const {
  return theta_sparsity_zero_topics_;
}
inline void PerplexityScore::set_theta_sparsity_zero_topics(::google::protobuf::int32 value) {
  set_has_theta_sparsity_zero_topics();
  theta_sparsity_zero_topics_ = value;
}

// optional int32 theta_sparsity_total_topics = 7;
inline bool PerplexityScore::has_theta_sparsity_total_topics() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PerplexityScore::set_has_theta_sparsity_total_topics() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PerplexityScore::clear_has_theta_sparsity_total_topics() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PerplexityScore::clear_theta_sparsity_total_topics() {
  theta_sparsity_total_topics_ = 0;
  clear_has_theta_sparsity_total_topics();
}
inline ::google::protobuf::int32 PerplexityScore::theta_sparsity_total_topics() const {
  return theta_sparsity_total_topics_;
}
inline void PerplexityScore::set_theta_sparsity_total_topics(::google::protobuf::int32 value) {
  set_has_theta_sparsity_total_topics();
  theta_sparsity_total_topics_ = value;
}

// -------------------------------------------------------------------

// SparsityThetaScoreConfig

// optional string field_name = 1 [default = "@body"];
inline bool SparsityThetaScoreConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparsityThetaScoreConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparsityThetaScoreConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparsityThetaScoreConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& SparsityThetaScoreConfig::field_name() const {
  return *field_name_;
}
inline void SparsityThetaScoreConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void SparsityThetaScoreConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void SparsityThetaScoreConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SparsityThetaScoreConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* SparsityThetaScoreConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void SparsityThetaScoreConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 2 [default = "@global"];
inline bool SparsityThetaScoreConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparsityThetaScoreConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparsityThetaScoreConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparsityThetaScoreConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& SparsityThetaScoreConfig::stream_name() const {
  return *stream_name_;
}
inline void SparsityThetaScoreConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void SparsityThetaScoreConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void SparsityThetaScoreConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SparsityThetaScoreConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* SparsityThetaScoreConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void SparsityThetaScoreConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// optional float eps = 3 [default = 1e-037];
inline bool SparsityThetaScoreConfig::has_eps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SparsityThetaScoreConfig::set_has_eps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SparsityThetaScoreConfig::clear_has_eps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SparsityThetaScoreConfig::clear_eps() {
  eps_ = 1e-037f;
  clear_has_eps();
}
inline float SparsityThetaScoreConfig::eps() const {
  return eps_;
}
inline void SparsityThetaScoreConfig::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// repeated string topic_name = 4;
inline int SparsityThetaScoreConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void SparsityThetaScoreConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& SparsityThetaScoreConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* SparsityThetaScoreConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void SparsityThetaScoreConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SparsityThetaScoreConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SparsityThetaScoreConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SparsityThetaScoreConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void SparsityThetaScoreConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void SparsityThetaScoreConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void SparsityThetaScoreConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SparsityThetaScoreConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SparsityThetaScoreConfig::mutable_topic_name() {
  return &topic_name_;
}

// -------------------------------------------------------------------

// SparsityThetaScore

// optional double value = 1;
inline bool SparsityThetaScore::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparsityThetaScore::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparsityThetaScore::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparsityThetaScore::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double SparsityThetaScore::value() const {
  return value_;
}
inline void SparsityThetaScore::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional int32 zero_topics = 2;
inline bool SparsityThetaScore::has_zero_topics() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparsityThetaScore::set_has_zero_topics() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparsityThetaScore::clear_has_zero_topics() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparsityThetaScore::clear_zero_topics() {
  zero_topics_ = 0;
  clear_has_zero_topics();
}
inline ::google::protobuf::int32 SparsityThetaScore::zero_topics() const {
  return zero_topics_;
}
inline void SparsityThetaScore::set_zero_topics(::google::protobuf::int32 value) {
  set_has_zero_topics();
  zero_topics_ = value;
}

// optional int32 total_topics = 3;
inline bool SparsityThetaScore::has_total_topics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SparsityThetaScore::set_has_total_topics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SparsityThetaScore::clear_has_total_topics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SparsityThetaScore::clear_total_topics() {
  total_topics_ = 0;
  clear_has_total_topics();
}
inline ::google::protobuf::int32 SparsityThetaScore::total_topics() const {
  return total_topics_;
}
inline void SparsityThetaScore::set_total_topics(::google::protobuf::int32 value) {
  set_has_total_topics();
  total_topics_ = value;
}

// -------------------------------------------------------------------

// SparsityPhiScoreConfig

// optional float eps = 1 [default = 1e-037];
inline bool SparsityPhiScoreConfig::has_eps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparsityPhiScoreConfig::set_has_eps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparsityPhiScoreConfig::clear_has_eps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparsityPhiScoreConfig::clear_eps() {
  eps_ = 1e-037f;
  clear_has_eps();
}
inline float SparsityPhiScoreConfig::eps() const {
  return eps_;
}
inline void SparsityPhiScoreConfig::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// optional string class_id = 2 [default = "@default_class"];
inline bool SparsityPhiScoreConfig::has_class_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparsityPhiScoreConfig::set_has_class_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparsityPhiScoreConfig::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparsityPhiScoreConfig::clear_class_id() {
  if (class_id_ != _default_class_id_) {
    class_id_->assign(*_default_class_id_);
  }
  clear_has_class_id();
}
inline const ::std::string& SparsityPhiScoreConfig::class_id() const {
  return *class_id_;
}
inline void SparsityPhiScoreConfig::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void SparsityPhiScoreConfig::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void SparsityPhiScoreConfig::set_class_id(const char* value, size_t size) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SparsityPhiScoreConfig::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string(*_default_class_id_);
  }
  return class_id_;
}
inline ::std::string* SparsityPhiScoreConfig::release_class_id() {
  clear_has_class_id();
  if (class_id_ == _default_class_id_) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
    return temp;
  }
}
inline void SparsityPhiScoreConfig::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != _default_class_id_) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
  }
}

// repeated string topic_name = 3;
inline int SparsityPhiScoreConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void SparsityPhiScoreConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& SparsityPhiScoreConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* SparsityPhiScoreConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void SparsityPhiScoreConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SparsityPhiScoreConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void SparsityPhiScoreConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SparsityPhiScoreConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void SparsityPhiScoreConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void SparsityPhiScoreConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void SparsityPhiScoreConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SparsityPhiScoreConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SparsityPhiScoreConfig::mutable_topic_name() {
  return &topic_name_;
}

// -------------------------------------------------------------------

// SparsityPhiScore

// optional double value = 1;
inline bool SparsityPhiScore::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparsityPhiScore::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparsityPhiScore::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparsityPhiScore::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double SparsityPhiScore::value() const {
  return value_;
}
inline void SparsityPhiScore::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional int32 zero_tokens = 2;
inline bool SparsityPhiScore::has_zero_tokens() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparsityPhiScore::set_has_zero_tokens() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparsityPhiScore::clear_has_zero_tokens() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparsityPhiScore::clear_zero_tokens() {
  zero_tokens_ = 0;
  clear_has_zero_tokens();
}
inline ::google::protobuf::int32 SparsityPhiScore::zero_tokens() const {
  return zero_tokens_;
}
inline void SparsityPhiScore::set_zero_tokens(::google::protobuf::int32 value) {
  set_has_zero_tokens();
  zero_tokens_ = value;
}

// optional int32 total_tokens = 3;
inline bool SparsityPhiScore::has_total_tokens() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SparsityPhiScore::set_has_total_tokens() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SparsityPhiScore::clear_has_total_tokens() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SparsityPhiScore::clear_total_tokens() {
  total_tokens_ = 0;
  clear_has_total_tokens();
}
inline ::google::protobuf::int32 SparsityPhiScore::total_tokens() const {
  return total_tokens_;
}
inline void SparsityPhiScore::set_total_tokens(::google::protobuf::int32 value) {
  set_has_total_tokens();
  total_tokens_ = value;
}

// -------------------------------------------------------------------

// ItemsProcessedScoreConfig

// optional string field_name = 1 [default = "@body"];
inline bool ItemsProcessedScoreConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemsProcessedScoreConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemsProcessedScoreConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemsProcessedScoreConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& ItemsProcessedScoreConfig::field_name() const {
  return *field_name_;
}
inline void ItemsProcessedScoreConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ItemsProcessedScoreConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ItemsProcessedScoreConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemsProcessedScoreConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* ItemsProcessedScoreConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void ItemsProcessedScoreConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 2 [default = "@global"];
inline bool ItemsProcessedScoreConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemsProcessedScoreConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemsProcessedScoreConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemsProcessedScoreConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& ItemsProcessedScoreConfig::stream_name() const {
  return *stream_name_;
}
inline void ItemsProcessedScoreConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ItemsProcessedScoreConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ItemsProcessedScoreConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemsProcessedScoreConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* ItemsProcessedScoreConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void ItemsProcessedScoreConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// -------------------------------------------------------------------

// ItemsProcessedScore

// optional int32 value = 1;
inline bool ItemsProcessedScore::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemsProcessedScore::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemsProcessedScore::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemsProcessedScore::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 ItemsProcessedScore::value() const {
  return value_;
}
inline void ItemsProcessedScore::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TopTokensScoreConfig

// optional int32 num_tokens = 1 [default = 10];
inline bool TopTokensScoreConfig::has_num_tokens() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopTokensScoreConfig::set_has_num_tokens() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopTokensScoreConfig::clear_has_num_tokens() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopTokensScoreConfig::clear_num_tokens() {
  num_tokens_ = 10;
  clear_has_num_tokens();
}
inline ::google::protobuf::int32 TopTokensScoreConfig::num_tokens() const {
  return num_tokens_;
}
inline void TopTokensScoreConfig::set_num_tokens(::google::protobuf::int32 value) {
  set_has_num_tokens();
  num_tokens_ = value;
}

// optional string class_id = 2 [default = "@default_class"];
inline bool TopTokensScoreConfig::has_class_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopTokensScoreConfig::set_has_class_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopTokensScoreConfig::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopTokensScoreConfig::clear_class_id() {
  if (class_id_ != _default_class_id_) {
    class_id_->assign(*_default_class_id_);
  }
  clear_has_class_id();
}
inline const ::std::string& TopTokensScoreConfig::class_id() const {
  return *class_id_;
}
inline void TopTokensScoreConfig::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void TopTokensScoreConfig::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void TopTokensScoreConfig::set_class_id(const char* value, size_t size) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopTokensScoreConfig::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string(*_default_class_id_);
  }
  return class_id_;
}
inline ::std::string* TopTokensScoreConfig::release_class_id() {
  clear_has_class_id();
  if (class_id_ == _default_class_id_) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
    return temp;
  }
}
inline void TopTokensScoreConfig::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != _default_class_id_) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
  }
}

// repeated string topic_name = 3;
inline int TopTokensScoreConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void TopTokensScoreConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& TopTokensScoreConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* TopTokensScoreConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void TopTokensScoreConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopTokensScoreConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopTokensScoreConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopTokensScoreConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void TopTokensScoreConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void TopTokensScoreConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void TopTokensScoreConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopTokensScoreConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopTokensScoreConfig::mutable_topic_name() {
  return &topic_name_;
}

// optional string cooccurrence_dictionary_name = 4;
inline bool TopTokensScoreConfig::has_cooccurrence_dictionary_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopTokensScoreConfig::set_has_cooccurrence_dictionary_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopTokensScoreConfig::clear_has_cooccurrence_dictionary_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopTokensScoreConfig::clear_cooccurrence_dictionary_name() {
  if (cooccurrence_dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_->clear();
  }
  clear_has_cooccurrence_dictionary_name();
}
inline const ::std::string& TopTokensScoreConfig::cooccurrence_dictionary_name() const {
  return *cooccurrence_dictionary_name_;
}
inline void TopTokensScoreConfig::set_cooccurrence_dictionary_name(const ::std::string& value) {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  cooccurrence_dictionary_name_->assign(value);
}
inline void TopTokensScoreConfig::set_cooccurrence_dictionary_name(const char* value) {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  cooccurrence_dictionary_name_->assign(value);
}
inline void TopTokensScoreConfig::set_cooccurrence_dictionary_name(const char* value, size_t size) {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  cooccurrence_dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopTokensScoreConfig::mutable_cooccurrence_dictionary_name() {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  return cooccurrence_dictionary_name_;
}
inline ::std::string* TopTokensScoreConfig::release_cooccurrence_dictionary_name() {
  clear_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = cooccurrence_dictionary_name_;
    cooccurrence_dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TopTokensScoreConfig::set_allocated_cooccurrence_dictionary_name(::std::string* cooccurrence_dictionary_name) {
  if (cooccurrence_dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete cooccurrence_dictionary_name_;
  }
  if (cooccurrence_dictionary_name) {
    set_has_cooccurrence_dictionary_name();
    cooccurrence_dictionary_name_ = cooccurrence_dictionary_name;
  } else {
    clear_has_cooccurrence_dictionary_name();
    cooccurrence_dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// TopTokensScore

// optional int32 num_entries = 1;
inline bool TopTokensScore::has_num_entries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopTokensScore::set_has_num_entries() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopTokensScore::clear_has_num_entries() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopTokensScore::clear_num_entries() {
  num_entries_ = 0;
  clear_has_num_entries();
}
inline ::google::protobuf::int32 TopTokensScore::num_entries() const {
  return num_entries_;
}
inline void TopTokensScore::set_num_entries(::google::protobuf::int32 value) {
  set_has_num_entries();
  num_entries_ = value;
}

// repeated string topic_name = 2;
inline int TopTokensScore::topic_name_size() const {
  return topic_name_.size();
}
inline void TopTokensScore::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& TopTokensScore::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* TopTokensScore::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void TopTokensScore::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopTokensScore::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopTokensScore::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopTokensScore::add_topic_name() {
  return topic_name_.Add();
}
inline void TopTokensScore::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void TopTokensScore::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void TopTokensScore::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopTokensScore::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopTokensScore::mutable_topic_name() {
  return &topic_name_;
}

// repeated int32 topic_index = 3;
inline int TopTokensScore::topic_index_size() const {
  return topic_index_.size();
}
inline void TopTokensScore::clear_topic_index() {
  topic_index_.Clear();
}
inline ::google::protobuf::int32 TopTokensScore::topic_index(int index) const {
  return topic_index_.Get(index);
}
inline void TopTokensScore::set_topic_index(int index, ::google::protobuf::int32 value) {
  topic_index_.Set(index, value);
}
inline void TopTokensScore::add_topic_index(::google::protobuf::int32 value) {
  topic_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TopTokensScore::topic_index() const {
  return topic_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TopTokensScore::mutable_topic_index() {
  return &topic_index_;
}

// repeated string token = 4;
inline int TopTokensScore::token_size() const {
  return token_.size();
}
inline void TopTokensScore::clear_token() {
  token_.Clear();
}
inline const ::std::string& TopTokensScore::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* TopTokensScore::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void TopTokensScore::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void TopTokensScore::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void TopTokensScore::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopTokensScore::add_token() {
  return token_.Add();
}
inline void TopTokensScore::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void TopTokensScore::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void TopTokensScore::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopTokensScore::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopTokensScore::mutable_token() {
  return &token_;
}

// repeated float weight = 5;
inline int TopTokensScore::weight_size() const {
  return weight_.size();
}
inline void TopTokensScore::clear_weight() {
  weight_.Clear();
}
inline float TopTokensScore::weight(int index) const {
  return weight_.Get(index);
}
inline void TopTokensScore::set_weight(int index, float value) {
  weight_.Set(index, value);
}
inline void TopTokensScore::add_weight(float value) {
  weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TopTokensScore::weight() const {
  return weight_;
}
inline ::google::protobuf::RepeatedField< float >*
TopTokensScore::mutable_weight() {
  return &weight_;
}

// optional .artm.FloatArray coherence = 6;
inline bool TopTokensScore::has_coherence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopTokensScore::set_has_coherence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopTokensScore::clear_has_coherence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopTokensScore::clear_coherence() {
  if (coherence_ != NULL) coherence_->::artm::FloatArray::Clear();
  clear_has_coherence();
}
inline const ::artm::FloatArray& TopTokensScore::coherence() const {
  return coherence_ != NULL ? *coherence_ : *default_instance_->coherence_;
}
inline ::artm::FloatArray* TopTokensScore::mutable_coherence() {
  set_has_coherence();
  if (coherence_ == NULL) coherence_ = new ::artm::FloatArray;
  return coherence_;
}
inline ::artm::FloatArray* TopTokensScore::release_coherence() {
  clear_has_coherence();
  ::artm::FloatArray* temp = coherence_;
  coherence_ = NULL;
  return temp;
}
inline void TopTokensScore::set_allocated_coherence(::artm::FloatArray* coherence) {
  delete coherence_;
  coherence_ = coherence;
  if (coherence) {
    set_has_coherence();
  } else {
    clear_has_coherence();
  }
}

// optional float average_coherence = 7;
inline bool TopTokensScore::has_average_coherence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TopTokensScore::set_has_average_coherence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TopTokensScore::clear_has_average_coherence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TopTokensScore::clear_average_coherence() {
  average_coherence_ = 0;
  clear_has_average_coherence();
}
inline float TopTokensScore::average_coherence() const {
  return average_coherence_;
}
inline void TopTokensScore::set_average_coherence(float value) {
  set_has_average_coherence();
  average_coherence_ = value;
}

// -------------------------------------------------------------------

// ThetaSnippetScoreConfig

// optional string field_name = 1 [default = "@body"];
inline bool ThetaSnippetScoreConfig::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThetaSnippetScoreConfig::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThetaSnippetScoreConfig::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThetaSnippetScoreConfig::clear_field_name() {
  if (field_name_ != _default_field_name_) {
    field_name_->assign(*_default_field_name_);
  }
  clear_has_field_name();
}
inline const ::std::string& ThetaSnippetScoreConfig::field_name() const {
  return *field_name_;
}
inline void ThetaSnippetScoreConfig::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ThetaSnippetScoreConfig::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
}
inline void ThetaSnippetScoreConfig::set_field_name(const char* value, size_t size) {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThetaSnippetScoreConfig::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == _default_field_name_) {
    field_name_ = new ::std::string(*_default_field_name_);
  }
  return field_name_;
}
inline ::std::string* ThetaSnippetScoreConfig::release_field_name() {
  clear_has_field_name();
  if (field_name_ == _default_field_name_) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
    return temp;
  }
}
inline void ThetaSnippetScoreConfig::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != _default_field_name_) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(_default_field_name_);
  }
}

// optional string stream_name = 2 [default = "@global"];
inline bool ThetaSnippetScoreConfig::has_stream_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThetaSnippetScoreConfig::set_has_stream_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThetaSnippetScoreConfig::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThetaSnippetScoreConfig::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& ThetaSnippetScoreConfig::stream_name() const {
  return *stream_name_;
}
inline void ThetaSnippetScoreConfig::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ThetaSnippetScoreConfig::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ThetaSnippetScoreConfig::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThetaSnippetScoreConfig::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* ThetaSnippetScoreConfig::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void ThetaSnippetScoreConfig::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// repeated int32 item_id = 3 [packed = true];
inline int ThetaSnippetScoreConfig::item_id_size() const {
  return item_id_.size();
}
inline void ThetaSnippetScoreConfig::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::int32 ThetaSnippetScoreConfig::item_id(int index) const {
  return item_id_.Get(index);
}
inline void ThetaSnippetScoreConfig::set_item_id(int index, ::google::protobuf::int32 value) {
  item_id_.Set(index, value);
}
inline void ThetaSnippetScoreConfig::add_item_id(::google::protobuf::int32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ThetaSnippetScoreConfig::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ThetaSnippetScoreConfig::mutable_item_id() {
  return &item_id_;
}

// optional int32 item_count = 4 [default = 10];
inline bool ThetaSnippetScoreConfig::has_item_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThetaSnippetScoreConfig::set_has_item_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThetaSnippetScoreConfig::clear_has_item_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThetaSnippetScoreConfig::clear_item_count() {
  item_count_ = 10;
  clear_has_item_count();
}
inline ::google::protobuf::int32 ThetaSnippetScoreConfig::item_count() const {
  return item_count_;
}
inline void ThetaSnippetScoreConfig::set_item_count(::google::protobuf::int32 value) {
  set_has_item_count();
  item_count_ = value;
}

// -------------------------------------------------------------------

// ThetaSnippetScore

// repeated int32 item_id = 1;
inline int ThetaSnippetScore::item_id_size() const {
  return item_id_.size();
}
inline void ThetaSnippetScore::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::int32 ThetaSnippetScore::item_id(int index) const {
  return item_id_.Get(index);
}
inline void ThetaSnippetScore::set_item_id(int index, ::google::protobuf::int32 value) {
  item_id_.Set(index, value);
}
inline void ThetaSnippetScore::add_item_id(::google::protobuf::int32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ThetaSnippetScore::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ThetaSnippetScore::mutable_item_id() {
  return &item_id_;
}

// repeated .artm.FloatArray values = 2;
inline int ThetaSnippetScore::values_size() const {
  return values_.size();
}
inline void ThetaSnippetScore::clear_values() {
  values_.Clear();
}
inline const ::artm::FloatArray& ThetaSnippetScore::values(int index) const {
  return values_.Get(index);
}
inline ::artm::FloatArray* ThetaSnippetScore::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::artm::FloatArray* ThetaSnippetScore::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
ThetaSnippetScore::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
ThetaSnippetScore::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// TopicKernelScoreConfig

// optional float eps = 1 [default = 1e-037];
inline bool TopicKernelScoreConfig::has_eps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicKernelScoreConfig::set_has_eps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicKernelScoreConfig::clear_has_eps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicKernelScoreConfig::clear_eps() {
  eps_ = 1e-037f;
  clear_has_eps();
}
inline float TopicKernelScoreConfig::eps() const {
  return eps_;
}
inline void TopicKernelScoreConfig::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// optional string class_id = 2 [default = "@default_class"];
inline bool TopicKernelScoreConfig::has_class_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicKernelScoreConfig::set_has_class_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicKernelScoreConfig::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicKernelScoreConfig::clear_class_id() {
  if (class_id_ != _default_class_id_) {
    class_id_->assign(*_default_class_id_);
  }
  clear_has_class_id();
}
inline const ::std::string& TopicKernelScoreConfig::class_id() const {
  return *class_id_;
}
inline void TopicKernelScoreConfig::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void TopicKernelScoreConfig::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void TopicKernelScoreConfig::set_class_id(const char* value, size_t size) {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicKernelScoreConfig::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == _default_class_id_) {
    class_id_ = new ::std::string(*_default_class_id_);
  }
  return class_id_;
}
inline ::std::string* TopicKernelScoreConfig::release_class_id() {
  clear_has_class_id();
  if (class_id_ == _default_class_id_) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
    return temp;
  }
}
inline void TopicKernelScoreConfig::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != _default_class_id_) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(_default_class_id_);
  }
}

// repeated string topic_name = 3;
inline int TopicKernelScoreConfig::topic_name_size() const {
  return topic_name_.size();
}
inline void TopicKernelScoreConfig::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& TopicKernelScoreConfig::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* TopicKernelScoreConfig::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void TopicKernelScoreConfig::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopicKernelScoreConfig::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopicKernelScoreConfig::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicKernelScoreConfig::add_topic_name() {
  return topic_name_.Add();
}
inline void TopicKernelScoreConfig::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void TopicKernelScoreConfig::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void TopicKernelScoreConfig::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopicKernelScoreConfig::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopicKernelScoreConfig::mutable_topic_name() {
  return &topic_name_;
}

// optional double probability_mass_threshold = 4 [default = 0.1];
inline bool TopicKernelScoreConfig::has_probability_mass_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopicKernelScoreConfig::set_has_probability_mass_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopicKernelScoreConfig::clear_has_probability_mass_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopicKernelScoreConfig::clear_probability_mass_threshold() {
  probability_mass_threshold_ = 0.1;
  clear_has_probability_mass_threshold();
}
inline double TopicKernelScoreConfig::probability_mass_threshold() const {
  return probability_mass_threshold_;
}
inline void TopicKernelScoreConfig::set_probability_mass_threshold(double value) {
  set_has_probability_mass_threshold();
  probability_mass_threshold_ = value;
}

// optional string cooccurrence_dictionary_name = 5;
inline bool TopicKernelScoreConfig::has_cooccurrence_dictionary_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopicKernelScoreConfig::set_has_cooccurrence_dictionary_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopicKernelScoreConfig::clear_has_cooccurrence_dictionary_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopicKernelScoreConfig::clear_cooccurrence_dictionary_name() {
  if (cooccurrence_dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_->clear();
  }
  clear_has_cooccurrence_dictionary_name();
}
inline const ::std::string& TopicKernelScoreConfig::cooccurrence_dictionary_name() const {
  return *cooccurrence_dictionary_name_;
}
inline void TopicKernelScoreConfig::set_cooccurrence_dictionary_name(const ::std::string& value) {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  cooccurrence_dictionary_name_->assign(value);
}
inline void TopicKernelScoreConfig::set_cooccurrence_dictionary_name(const char* value) {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  cooccurrence_dictionary_name_->assign(value);
}
inline void TopicKernelScoreConfig::set_cooccurrence_dictionary_name(const char* value, size_t size) {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  cooccurrence_dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicKernelScoreConfig::mutable_cooccurrence_dictionary_name() {
  set_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    cooccurrence_dictionary_name_ = new ::std::string;
  }
  return cooccurrence_dictionary_name_;
}
inline ::std::string* TopicKernelScoreConfig::release_cooccurrence_dictionary_name() {
  clear_has_cooccurrence_dictionary_name();
  if (cooccurrence_dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = cooccurrence_dictionary_name_;
    cooccurrence_dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TopicKernelScoreConfig::set_allocated_cooccurrence_dictionary_name(::std::string* cooccurrence_dictionary_name) {
  if (cooccurrence_dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete cooccurrence_dictionary_name_;
  }
  if (cooccurrence_dictionary_name) {
    set_has_cooccurrence_dictionary_name();
    cooccurrence_dictionary_name_ = cooccurrence_dictionary_name;
  } else {
    clear_has_cooccurrence_dictionary_name();
    cooccurrence_dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// TopicKernelScore

// optional .artm.DoubleArray kernel_size = 1;
inline bool TopicKernelScore::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicKernelScore::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicKernelScore::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicKernelScore::clear_kernel_size() {
  if (kernel_size_ != NULL) kernel_size_->::artm::DoubleArray::Clear();
  clear_has_kernel_size();
}
inline const ::artm::DoubleArray& TopicKernelScore::kernel_size() const {
  return kernel_size_ != NULL ? *kernel_size_ : *default_instance_->kernel_size_;
}
inline ::artm::DoubleArray* TopicKernelScore::mutable_kernel_size() {
  set_has_kernel_size();
  if (kernel_size_ == NULL) kernel_size_ = new ::artm::DoubleArray;
  return kernel_size_;
}
inline ::artm::DoubleArray* TopicKernelScore::release_kernel_size() {
  clear_has_kernel_size();
  ::artm::DoubleArray* temp = kernel_size_;
  kernel_size_ = NULL;
  return temp;
}
inline void TopicKernelScore::set_allocated_kernel_size(::artm::DoubleArray* kernel_size) {
  delete kernel_size_;
  kernel_size_ = kernel_size;
  if (kernel_size) {
    set_has_kernel_size();
  } else {
    clear_has_kernel_size();
  }
}

// optional .artm.DoubleArray kernel_purity = 2;
inline bool TopicKernelScore::has_kernel_purity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicKernelScore::set_has_kernel_purity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicKernelScore::clear_has_kernel_purity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicKernelScore::clear_kernel_purity() {
  if (kernel_purity_ != NULL) kernel_purity_->::artm::DoubleArray::Clear();
  clear_has_kernel_purity();
}
inline const ::artm::DoubleArray& TopicKernelScore::kernel_purity() const {
  return kernel_purity_ != NULL ? *kernel_purity_ : *default_instance_->kernel_purity_;
}
inline ::artm::DoubleArray* TopicKernelScore::mutable_kernel_purity() {
  set_has_kernel_purity();
  if (kernel_purity_ == NULL) kernel_purity_ = new ::artm::DoubleArray;
  return kernel_purity_;
}
inline ::artm::DoubleArray* TopicKernelScore::release_kernel_purity() {
  clear_has_kernel_purity();
  ::artm::DoubleArray* temp = kernel_purity_;
  kernel_purity_ = NULL;
  return temp;
}
inline void TopicKernelScore::set_allocated_kernel_purity(::artm::DoubleArray* kernel_purity) {
  delete kernel_purity_;
  kernel_purity_ = kernel_purity;
  if (kernel_purity) {
    set_has_kernel_purity();
  } else {
    clear_has_kernel_purity();
  }
}

// optional .artm.DoubleArray kernel_contrast = 3;
inline bool TopicKernelScore::has_kernel_contrast() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicKernelScore::set_has_kernel_contrast() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicKernelScore::clear_has_kernel_contrast() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicKernelScore::clear_kernel_contrast() {
  if (kernel_contrast_ != NULL) kernel_contrast_->::artm::DoubleArray::Clear();
  clear_has_kernel_contrast();
}
inline const ::artm::DoubleArray& TopicKernelScore::kernel_contrast() const {
  return kernel_contrast_ != NULL ? *kernel_contrast_ : *default_instance_->kernel_contrast_;
}
inline ::artm::DoubleArray* TopicKernelScore::mutable_kernel_contrast() {
  set_has_kernel_contrast();
  if (kernel_contrast_ == NULL) kernel_contrast_ = new ::artm::DoubleArray;
  return kernel_contrast_;
}
inline ::artm::DoubleArray* TopicKernelScore::release_kernel_contrast() {
  clear_has_kernel_contrast();
  ::artm::DoubleArray* temp = kernel_contrast_;
  kernel_contrast_ = NULL;
  return temp;
}
inline void TopicKernelScore::set_allocated_kernel_contrast(::artm::DoubleArray* kernel_contrast) {
  delete kernel_contrast_;
  kernel_contrast_ = kernel_contrast;
  if (kernel_contrast) {
    set_has_kernel_contrast();
  } else {
    clear_has_kernel_contrast();
  }
}

// optional double average_kernel_size = 4;
inline bool TopicKernelScore::has_average_kernel_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopicKernelScore::set_has_average_kernel_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopicKernelScore::clear_has_average_kernel_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopicKernelScore::clear_average_kernel_size() {
  average_kernel_size_ = 0;
  clear_has_average_kernel_size();
}
inline double TopicKernelScore::average_kernel_size() const {
  return average_kernel_size_;
}
inline void TopicKernelScore::set_average_kernel_size(double value) {
  set_has_average_kernel_size();
  average_kernel_size_ = value;
}

// optional double average_kernel_purity = 5;
inline bool TopicKernelScore::has_average_kernel_purity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopicKernelScore::set_has_average_kernel_purity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopicKernelScore::clear_has_average_kernel_purity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopicKernelScore::clear_average_kernel_purity() {
  average_kernel_purity_ = 0;
  clear_has_average_kernel_purity();
}
inline double TopicKernelScore::average_kernel_purity() const {
  return average_kernel_purity_;
}
inline void TopicKernelScore::set_average_kernel_purity(double value) {
  set_has_average_kernel_purity();
  average_kernel_purity_ = value;
}

// optional double average_kernel_contrast = 6;
inline bool TopicKernelScore::has_average_kernel_contrast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopicKernelScore::set_has_average_kernel_contrast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopicKernelScore::clear_has_average_kernel_contrast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopicKernelScore::clear_average_kernel_contrast() {
  average_kernel_contrast_ = 0;
  clear_has_average_kernel_contrast();
}
inline double TopicKernelScore::average_kernel_contrast() const {
  return average_kernel_contrast_;
}
inline void TopicKernelScore::set_average_kernel_contrast(double value) {
  set_has_average_kernel_contrast();
  average_kernel_contrast_ = value;
}

// optional .artm.DoubleArray coherence = 7;
inline bool TopicKernelScore::has_coherence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TopicKernelScore::set_has_coherence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TopicKernelScore::clear_has_coherence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TopicKernelScore::clear_coherence() {
  if (coherence_ != NULL) coherence_->::artm::DoubleArray::Clear();
  clear_has_coherence();
}
inline const ::artm::DoubleArray& TopicKernelScore::coherence() const {
  return coherence_ != NULL ? *coherence_ : *default_instance_->coherence_;
}
inline ::artm::DoubleArray* TopicKernelScore::mutable_coherence() {
  set_has_coherence();
  if (coherence_ == NULL) coherence_ = new ::artm::DoubleArray;
  return coherence_;
}
inline ::artm::DoubleArray* TopicKernelScore::release_coherence() {
  clear_has_coherence();
  ::artm::DoubleArray* temp = coherence_;
  coherence_ = NULL;
  return temp;
}
inline void TopicKernelScore::set_allocated_coherence(::artm::DoubleArray* coherence) {
  delete coherence_;
  coherence_ = coherence;
  if (coherence) {
    set_has_coherence();
  } else {
    clear_has_coherence();
  }
}

// optional float average_coherence = 8;
inline bool TopicKernelScore::has_average_coherence() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TopicKernelScore::set_has_average_coherence() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TopicKernelScore::clear_has_average_coherence() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TopicKernelScore::clear_average_coherence() {
  average_coherence_ = 0;
  clear_has_average_coherence();
}
inline float TopicKernelScore::average_coherence() const {
  return average_coherence_;
}
inline void TopicKernelScore::set_average_coherence(float value) {
  set_has_average_coherence();
  average_coherence_ = value;
}

// repeated .artm.StringArray kernel_tokens = 9;
inline int TopicKernelScore::kernel_tokens_size() const {
  return kernel_tokens_.size();
}
inline void TopicKernelScore::clear_kernel_tokens() {
  kernel_tokens_.Clear();
}
inline const ::artm::StringArray& TopicKernelScore::kernel_tokens(int index) const {
  return kernel_tokens_.Get(index);
}
inline ::artm::StringArray* TopicKernelScore::mutable_kernel_tokens(int index) {
  return kernel_tokens_.Mutable(index);
}
inline ::artm::StringArray* TopicKernelScore::add_kernel_tokens() {
  return kernel_tokens_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::StringArray >&
TopicKernelScore::kernel_tokens() const {
  return kernel_tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::StringArray >*
TopicKernelScore::mutable_kernel_tokens() {
  return &kernel_tokens_;
}

// -------------------------------------------------------------------

// TopicModel_TopicModelInternals

// repeated .artm.FloatArray n_wt = 1;
inline int TopicModel_TopicModelInternals::n_wt_size() const {
  return n_wt_.size();
}
inline void TopicModel_TopicModelInternals::clear_n_wt() {
  n_wt_.Clear();
}
inline const ::artm::FloatArray& TopicModel_TopicModelInternals::n_wt(int index) const {
  return n_wt_.Get(index);
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::mutable_n_wt(int index) {
  return n_wt_.Mutable(index);
}
inline ::artm::FloatArray* TopicModel_TopicModelInternals::add_n_wt() {
  return n_wt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
TopicModel_TopicModelInternals::n_wt() const {
  return n_wt_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
TopicModel_TopicModelInternals::mutable_n_wt() {
  return &n_wt_;
}

// -------------------------------------------------------------------

// TopicModel

// optional string name = 1 [default = "@model"];
inline bool TopicModel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicModel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicModel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicModel::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& TopicModel::name() const {
  return *name_;
}
inline void TopicModel::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TopicModel::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TopicModel::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* TopicModel::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void TopicModel::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// optional int32 topics_count = 2;
inline bool TopicModel::has_topics_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicModel::set_has_topics_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicModel::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicModel::clear_topics_count() {
  topics_count_ = 0;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 TopicModel::topics_count() const {
  return topics_count_;
}
inline void TopicModel::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// repeated string topic_name = 3;
inline int TopicModel::topic_name_size() const {
  return topic_name_.size();
}
inline void TopicModel::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& TopicModel::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* TopicModel::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void TopicModel::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopicModel::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void TopicModel::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::add_topic_name() {
  return topic_name_.Add();
}
inline void TopicModel::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void TopicModel::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void TopicModel::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopicModel::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopicModel::mutable_topic_name() {
  return &topic_name_;
}

// repeated string token = 4;
inline int TopicModel::token_size() const {
  return token_.size();
}
inline void TopicModel::clear_token() {
  token_.Clear();
}
inline const ::std::string& TopicModel::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* TopicModel::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void TopicModel::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void TopicModel::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void TopicModel::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::add_token() {
  return token_.Add();
}
inline void TopicModel::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void TopicModel::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void TopicModel::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopicModel::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopicModel::mutable_token() {
  return &token_;
}

// repeated .artm.FloatArray token_weights = 5;
inline int TopicModel::token_weights_size() const {
  return token_weights_.size();
}
inline void TopicModel::clear_token_weights() {
  token_weights_.Clear();
}
inline const ::artm::FloatArray& TopicModel::token_weights(int index) const {
  return token_weights_.Get(index);
}
inline ::artm::FloatArray* TopicModel::mutable_token_weights(int index) {
  return token_weights_.Mutable(index);
}
inline ::artm::FloatArray* TopicModel::add_token_weights() {
  return token_weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
TopicModel::token_weights() const {
  return token_weights_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
TopicModel::mutable_token_weights() {
  return &token_weights_;
}

// repeated string class_id = 6;
inline int TopicModel::class_id_size() const {
  return class_id_.size();
}
inline void TopicModel::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& TopicModel::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* TopicModel::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void TopicModel::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void TopicModel::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void TopicModel::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::add_class_id() {
  return class_id_.Add();
}
inline void TopicModel::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void TopicModel::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void TopicModel::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TopicModel::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TopicModel::mutable_class_id() {
  return &class_id_;
}

// optional bytes internals = 7;
inline bool TopicModel::has_internals() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TopicModel::set_has_internals() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TopicModel::clear_has_internals() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TopicModel::clear_internals() {
  if (internals_ != &::google::protobuf::internal::GetEmptyString()) {
    internals_->clear();
  }
  clear_has_internals();
}
inline const ::std::string& TopicModel::internals() const {
  return *internals_;
}
inline void TopicModel::set_internals(const ::std::string& value) {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::GetEmptyString()) {
    internals_ = new ::std::string;
  }
  internals_->assign(value);
}
inline void TopicModel::set_internals(const char* value) {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::GetEmptyString()) {
    internals_ = new ::std::string;
  }
  internals_->assign(value);
}
inline void TopicModel::set_internals(const void* value, size_t size) {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::GetEmptyString()) {
    internals_ = new ::std::string;
  }
  internals_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicModel::mutable_internals() {
  set_has_internals();
  if (internals_ == &::google::protobuf::internal::GetEmptyString()) {
    internals_ = new ::std::string;
  }
  return internals_;
}
inline ::std::string* TopicModel::release_internals() {
  clear_has_internals();
  if (internals_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = internals_;
    internals_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TopicModel::set_allocated_internals(::std::string* internals) {
  if (internals_ != &::google::protobuf::internal::GetEmptyString()) {
    delete internals_;
  }
  if (internals) {
    set_has_internals();
    internals_ = internals;
  } else {
    clear_has_internals();
    internals_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .artm.IntArray topic_index = 8;
inline int TopicModel::topic_index_size() const {
  return topic_index_.size();
}
inline void TopicModel::clear_topic_index() {
  topic_index_.Clear();
}
inline const ::artm::IntArray& TopicModel::topic_index(int index) const {
  return topic_index_.Get(index);
}
inline ::artm::IntArray* TopicModel::mutable_topic_index(int index) {
  return topic_index_.Mutable(index);
}
inline ::artm::IntArray* TopicModel::add_topic_index() {
  return topic_index_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::IntArray >&
TopicModel::topic_index() const {
  return topic_index_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::IntArray >*
TopicModel::mutable_topic_index() {
  return &topic_index_;
}

// repeated .artm.TopicModel.OperationType operation_type = 9;
inline int TopicModel::operation_type_size() const {
  return operation_type_.size();
}
inline void TopicModel::clear_operation_type() {
  operation_type_.Clear();
}
inline ::artm::TopicModel_OperationType TopicModel::operation_type(int index) const {
  return static_cast< ::artm::TopicModel_OperationType >(operation_type_.Get(index));
}
inline void TopicModel::set_operation_type(int index, ::artm::TopicModel_OperationType value) {
  assert(::artm::TopicModel_OperationType_IsValid(value));
  operation_type_.Set(index, value);
}
inline void TopicModel::add_operation_type(::artm::TopicModel_OperationType value) {
  assert(::artm::TopicModel_OperationType_IsValid(value));
  operation_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TopicModel::operation_type() const {
  return operation_type_;
}
inline ::google::protobuf::RepeatedField<int>*
TopicModel::mutable_operation_type() {
  return &operation_type_;
}

// -------------------------------------------------------------------

// ThetaMatrix

// optional string model_name = 1 [default = "@model"];
inline bool ThetaMatrix::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThetaMatrix::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThetaMatrix::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThetaMatrix::clear_model_name() {
  if (model_name_ != _default_model_name_) {
    model_name_->assign(*_default_model_name_);
  }
  clear_has_model_name();
}
inline const ::std::string& ThetaMatrix::model_name() const {
  return *model_name_;
}
inline void ThetaMatrix::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ThetaMatrix::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ThetaMatrix::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThetaMatrix::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == _default_model_name_) {
    model_name_ = new ::std::string(*_default_model_name_);
  }
  return model_name_;
}
inline ::std::string* ThetaMatrix::release_model_name() {
  clear_has_model_name();
  if (model_name_ == _default_model_name_) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(_default_model_name_);
    return temp;
  }
}
inline void ThetaMatrix::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != _default_model_name_) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(_default_model_name_);
  }
}

// repeated int32 item_id = 2;
inline int ThetaMatrix::item_id_size() const {
  return item_id_.size();
}
inline void ThetaMatrix::clear_item_id() {
  item_id_.Clear();
}
inline ::google::protobuf::int32 ThetaMatrix::item_id(int index) const {
  return item_id_.Get(index);
}
inline void ThetaMatrix::set_item_id(int index, ::google::protobuf::int32 value) {
  item_id_.Set(index, value);
}
inline void ThetaMatrix::add_item_id(::google::protobuf::int32 value) {
  item_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ThetaMatrix::item_id() const {
  return item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ThetaMatrix::mutable_item_id() {
  return &item_id_;
}

// repeated .artm.FloatArray item_weights = 3;
inline int ThetaMatrix::item_weights_size() const {
  return item_weights_.size();
}
inline void ThetaMatrix::clear_item_weights() {
  item_weights_.Clear();
}
inline const ::artm::FloatArray& ThetaMatrix::item_weights(int index) const {
  return item_weights_.Get(index);
}
inline ::artm::FloatArray* ThetaMatrix::mutable_item_weights(int index) {
  return item_weights_.Mutable(index);
}
inline ::artm::FloatArray* ThetaMatrix::add_item_weights() {
  return item_weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >&
ThetaMatrix::item_weights() const {
  return item_weights_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::FloatArray >*
ThetaMatrix::mutable_item_weights() {
  return &item_weights_;
}

// repeated string topic_name = 4;
inline int ThetaMatrix::topic_name_size() const {
  return topic_name_.size();
}
inline void ThetaMatrix::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& ThetaMatrix::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* ThetaMatrix::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void ThetaMatrix::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void ThetaMatrix::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void ThetaMatrix::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThetaMatrix::add_topic_name() {
  return topic_name_.Add();
}
inline void ThetaMatrix::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void ThetaMatrix::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void ThetaMatrix::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ThetaMatrix::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ThetaMatrix::mutable_topic_name() {
  return &topic_name_;
}

// optional int32 topics_count = 5;
inline bool ThetaMatrix::has_topics_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThetaMatrix::set_has_topics_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThetaMatrix::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThetaMatrix::clear_topics_count() {
  topics_count_ = 0;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 ThetaMatrix::topics_count() const {
  return topics_count_;
}
inline void ThetaMatrix::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// repeated string item_title = 6;
inline int ThetaMatrix::item_title_size() const {
  return item_title_.size();
}
inline void ThetaMatrix::clear_item_title() {
  item_title_.Clear();
}
inline const ::std::string& ThetaMatrix::item_title(int index) const {
  return item_title_.Get(index);
}
inline ::std::string* ThetaMatrix::mutable_item_title(int index) {
  return item_title_.Mutable(index);
}
inline void ThetaMatrix::set_item_title(int index, const ::std::string& value) {
  item_title_.Mutable(index)->assign(value);
}
inline void ThetaMatrix::set_item_title(int index, const char* value) {
  item_title_.Mutable(index)->assign(value);
}
inline void ThetaMatrix::set_item_title(int index, const char* value, size_t size) {
  item_title_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ThetaMatrix::add_item_title() {
  return item_title_.Add();
}
inline void ThetaMatrix::add_item_title(const ::std::string& value) {
  item_title_.Add()->assign(value);
}
inline void ThetaMatrix::add_item_title(const char* value) {
  item_title_.Add()->assign(value);
}
inline void ThetaMatrix::add_item_title(const char* value, size_t size) {
  item_title_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ThetaMatrix::item_title() const {
  return item_title_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ThetaMatrix::mutable_item_title() {
  return &item_title_;
}

// repeated .artm.IntArray topic_index = 7;
inline int ThetaMatrix::topic_index_size() const {
  return topic_index_.size();
}
inline void ThetaMatrix::clear_topic_index() {
  topic_index_.Clear();
}
inline const ::artm::IntArray& ThetaMatrix::topic_index(int index) const {
  return topic_index_.Get(index);
}
inline ::artm::IntArray* ThetaMatrix::mutable_topic_index(int index) {
  return topic_index_.Mutable(index);
}
inline ::artm::IntArray* ThetaMatrix::add_topic_index() {
  return topic_index_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::IntArray >&
ThetaMatrix::topic_index() const {
  return topic_index_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::IntArray >*
ThetaMatrix::mutable_topic_index() {
  return &topic_index_;
}

// -------------------------------------------------------------------

// CollectionParserConfig

// optional .artm.CollectionParserConfig.Format format = 1 [default = BagOfWordsUci];
inline bool CollectionParserConfig::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectionParserConfig::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectionParserConfig::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectionParserConfig::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::artm::CollectionParserConfig_Format CollectionParserConfig::format() const {
  return static_cast< ::artm::CollectionParserConfig_Format >(format_);
}
inline void CollectionParserConfig::set_format(::artm::CollectionParserConfig_Format value) {
  assert(::artm::CollectionParserConfig_Format_IsValid(value));
  set_has_format();
  format_ = value;
}

// optional string docword_file_path = 2;
inline bool CollectionParserConfig::has_docword_file_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectionParserConfig::set_has_docword_file_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectionParserConfig::clear_has_docword_file_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectionParserConfig::clear_docword_file_path() {
  if (docword_file_path_ != &::google::protobuf::internal::GetEmptyString()) {
    docword_file_path_->clear();
  }
  clear_has_docword_file_path();
}
inline const ::std::string& CollectionParserConfig::docword_file_path() const {
  return *docword_file_path_;
}
inline void CollectionParserConfig::set_docword_file_path(const ::std::string& value) {
  set_has_docword_file_path();
  if (docword_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    docword_file_path_ = new ::std::string;
  }
  docword_file_path_->assign(value);
}
inline void CollectionParserConfig::set_docword_file_path(const char* value) {
  set_has_docword_file_path();
  if (docword_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    docword_file_path_ = new ::std::string;
  }
  docword_file_path_->assign(value);
}
inline void CollectionParserConfig::set_docword_file_path(const char* value, size_t size) {
  set_has_docword_file_path();
  if (docword_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    docword_file_path_ = new ::std::string;
  }
  docword_file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectionParserConfig::mutable_docword_file_path() {
  set_has_docword_file_path();
  if (docword_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    docword_file_path_ = new ::std::string;
  }
  return docword_file_path_;
}
inline ::std::string* CollectionParserConfig::release_docword_file_path() {
  clear_has_docword_file_path();
  if (docword_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = docword_file_path_;
    docword_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CollectionParserConfig::set_allocated_docword_file_path(::std::string* docword_file_path) {
  if (docword_file_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete docword_file_path_;
  }
  if (docword_file_path) {
    set_has_docword_file_path();
    docword_file_path_ = docword_file_path;
  } else {
    clear_has_docword_file_path();
    docword_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string vocab_file_path = 3;
inline bool CollectionParserConfig::has_vocab_file_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectionParserConfig::set_has_vocab_file_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectionParserConfig::clear_has_vocab_file_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectionParserConfig::clear_vocab_file_path() {
  if (vocab_file_path_ != &::google::protobuf::internal::GetEmptyString()) {
    vocab_file_path_->clear();
  }
  clear_has_vocab_file_path();
}
inline const ::std::string& CollectionParserConfig::vocab_file_path() const {
  return *vocab_file_path_;
}
inline void CollectionParserConfig::set_vocab_file_path(const ::std::string& value) {
  set_has_vocab_file_path();
  if (vocab_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    vocab_file_path_ = new ::std::string;
  }
  vocab_file_path_->assign(value);
}
inline void CollectionParserConfig::set_vocab_file_path(const char* value) {
  set_has_vocab_file_path();
  if (vocab_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    vocab_file_path_ = new ::std::string;
  }
  vocab_file_path_->assign(value);
}
inline void CollectionParserConfig::set_vocab_file_path(const char* value, size_t size) {
  set_has_vocab_file_path();
  if (vocab_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    vocab_file_path_ = new ::std::string;
  }
  vocab_file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectionParserConfig::mutable_vocab_file_path() {
  set_has_vocab_file_path();
  if (vocab_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    vocab_file_path_ = new ::std::string;
  }
  return vocab_file_path_;
}
inline ::std::string* CollectionParserConfig::release_vocab_file_path() {
  clear_has_vocab_file_path();
  if (vocab_file_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vocab_file_path_;
    vocab_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CollectionParserConfig::set_allocated_vocab_file_path(::std::string* vocab_file_path) {
  if (vocab_file_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vocab_file_path_;
  }
  if (vocab_file_path) {
    set_has_vocab_file_path();
    vocab_file_path_ = vocab_file_path;
  } else {
    clear_has_vocab_file_path();
    vocab_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string target_folder = 4;
inline bool CollectionParserConfig::has_target_folder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollectionParserConfig::set_has_target_folder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollectionParserConfig::clear_has_target_folder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollectionParserConfig::clear_target_folder() {
  if (target_folder_ != &::google::protobuf::internal::GetEmptyString()) {
    target_folder_->clear();
  }
  clear_has_target_folder();
}
inline const ::std::string& CollectionParserConfig::target_folder() const {
  return *target_folder_;
}
inline void CollectionParserConfig::set_target_folder(const ::std::string& value) {
  set_has_target_folder();
  if (target_folder_ == &::google::protobuf::internal::GetEmptyString()) {
    target_folder_ = new ::std::string;
  }
  target_folder_->assign(value);
}
inline void CollectionParserConfig::set_target_folder(const char* value) {
  set_has_target_folder();
  if (target_folder_ == &::google::protobuf::internal::GetEmptyString()) {
    target_folder_ = new ::std::string;
  }
  target_folder_->assign(value);
}
inline void CollectionParserConfig::set_target_folder(const char* value, size_t size) {
  set_has_target_folder();
  if (target_folder_ == &::google::protobuf::internal::GetEmptyString()) {
    target_folder_ = new ::std::string;
  }
  target_folder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectionParserConfig::mutable_target_folder() {
  set_has_target_folder();
  if (target_folder_ == &::google::protobuf::internal::GetEmptyString()) {
    target_folder_ = new ::std::string;
  }
  return target_folder_;
}
inline ::std::string* CollectionParserConfig::release_target_folder() {
  clear_has_target_folder();
  if (target_folder_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = target_folder_;
    target_folder_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CollectionParserConfig::set_allocated_target_folder(::std::string* target_folder) {
  if (target_folder_ != &::google::protobuf::internal::GetEmptyString()) {
    delete target_folder_;
  }
  if (target_folder) {
    set_has_target_folder();
    target_folder_ = target_folder;
  } else {
    clear_has_target_folder();
    target_folder_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string dictionary_file_name = 5;
inline bool CollectionParserConfig::has_dictionary_file_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollectionParserConfig::set_has_dictionary_file_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollectionParserConfig::clear_has_dictionary_file_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollectionParserConfig::clear_dictionary_file_name() {
  if (dictionary_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    dictionary_file_name_->clear();
  }
  clear_has_dictionary_file_name();
}
inline const ::std::string& CollectionParserConfig::dictionary_file_name() const {
  return *dictionary_file_name_;
}
inline void CollectionParserConfig::set_dictionary_file_name(const ::std::string& value) {
  set_has_dictionary_file_name();
  if (dictionary_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_file_name_ = new ::std::string;
  }
  dictionary_file_name_->assign(value);
}
inline void CollectionParserConfig::set_dictionary_file_name(const char* value) {
  set_has_dictionary_file_name();
  if (dictionary_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_file_name_ = new ::std::string;
  }
  dictionary_file_name_->assign(value);
}
inline void CollectionParserConfig::set_dictionary_file_name(const char* value, size_t size) {
  set_has_dictionary_file_name();
  if (dictionary_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_file_name_ = new ::std::string;
  }
  dictionary_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectionParserConfig::mutable_dictionary_file_name() {
  set_has_dictionary_file_name();
  if (dictionary_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_file_name_ = new ::std::string;
  }
  return dictionary_file_name_;
}
inline ::std::string* CollectionParserConfig::release_dictionary_file_name() {
  clear_has_dictionary_file_name();
  if (dictionary_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_file_name_;
    dictionary_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CollectionParserConfig::set_allocated_dictionary_file_name(::std::string* dictionary_file_name) {
  if (dictionary_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete dictionary_file_name_;
  }
  if (dictionary_file_name) {
    set_has_dictionary_file_name();
    dictionary_file_name_ = dictionary_file_name;
  } else {
    clear_has_dictionary_file_name();
    dictionary_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 num_items_per_batch = 6 [default = 1000];
inline bool CollectionParserConfig::has_num_items_per_batch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollectionParserConfig::set_has_num_items_per_batch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollectionParserConfig::clear_has_num_items_per_batch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollectionParserConfig::clear_num_items_per_batch() {
  num_items_per_batch_ = 1000;
  clear_has_num_items_per_batch();
}
inline ::google::protobuf::int32 CollectionParserConfig::num_items_per_batch() const {
  return num_items_per_batch_;
}
inline void CollectionParserConfig::set_num_items_per_batch(::google::protobuf::int32 value) {
  set_has_num_items_per_batch();
  num_items_per_batch_ = value;
}

// repeated string cooccurrence_token = 7;
inline int CollectionParserConfig::cooccurrence_token_size() const {
  return cooccurrence_token_.size();
}
inline void CollectionParserConfig::clear_cooccurrence_token() {
  cooccurrence_token_.Clear();
}
inline const ::std::string& CollectionParserConfig::cooccurrence_token(int index) const {
  return cooccurrence_token_.Get(index);
}
inline ::std::string* CollectionParserConfig::mutable_cooccurrence_token(int index) {
  return cooccurrence_token_.Mutable(index);
}
inline void CollectionParserConfig::set_cooccurrence_token(int index, const ::std::string& value) {
  cooccurrence_token_.Mutable(index)->assign(value);
}
inline void CollectionParserConfig::set_cooccurrence_token(int index, const char* value) {
  cooccurrence_token_.Mutable(index)->assign(value);
}
inline void CollectionParserConfig::set_cooccurrence_token(int index, const char* value, size_t size) {
  cooccurrence_token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectionParserConfig::add_cooccurrence_token() {
  return cooccurrence_token_.Add();
}
inline void CollectionParserConfig::add_cooccurrence_token(const ::std::string& value) {
  cooccurrence_token_.Add()->assign(value);
}
inline void CollectionParserConfig::add_cooccurrence_token(const char* value) {
  cooccurrence_token_.Add()->assign(value);
}
inline void CollectionParserConfig::add_cooccurrence_token(const char* value, size_t size) {
  cooccurrence_token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollectionParserConfig::cooccurrence_token() const {
  return cooccurrence_token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollectionParserConfig::mutable_cooccurrence_token() {
  return &cooccurrence_token_;
}

// optional bool use_unity_based_indices = 8 [default = true];
inline bool CollectionParserConfig::has_use_unity_based_indices() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CollectionParserConfig::set_has_use_unity_based_indices() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CollectionParserConfig::clear_has_use_unity_based_indices() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CollectionParserConfig::clear_use_unity_based_indices() {
  use_unity_based_indices_ = true;
  clear_has_use_unity_based_indices();
}
inline bool CollectionParserConfig::use_unity_based_indices() const {
  return use_unity_based_indices_;
}
inline void CollectionParserConfig::set_use_unity_based_indices(bool value) {
  set_has_use_unity_based_indices();
  use_unity_based_indices_ = value;
}

// optional bool gather_cooc = 9 [default = false];
inline bool CollectionParserConfig::has_gather_cooc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CollectionParserConfig::set_has_gather_cooc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CollectionParserConfig::clear_has_gather_cooc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CollectionParserConfig::clear_gather_cooc() {
  gather_cooc_ = false;
  clear_has_gather_cooc();
}
inline bool CollectionParserConfig::gather_cooc() const {
  return gather_cooc_;
}
inline void CollectionParserConfig::set_gather_cooc(bool value) {
  set_has_gather_cooc();
  gather_cooc_ = value;
}

// -------------------------------------------------------------------

// SynchronizeModelArgs

// optional string model_name = 1;
inline bool SynchronizeModelArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SynchronizeModelArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SynchronizeModelArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SynchronizeModelArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& SynchronizeModelArgs::model_name() const {
  return *model_name_;
}
inline void SynchronizeModelArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void SynchronizeModelArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void SynchronizeModelArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SynchronizeModelArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* SynchronizeModelArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SynchronizeModelArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional float decay_weight = 2 [default = 0];
inline bool SynchronizeModelArgs::has_decay_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SynchronizeModelArgs::set_has_decay_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SynchronizeModelArgs::clear_has_decay_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SynchronizeModelArgs::clear_decay_weight() {
  decay_weight_ = 0;
  clear_has_decay_weight();
}
inline float SynchronizeModelArgs::decay_weight() const {
  return decay_weight_;
}
inline void SynchronizeModelArgs::set_decay_weight(float value) {
  set_has_decay_weight();
  decay_weight_ = value;
}

// optional bool invoke_regularizers = 3 [default = true];
inline bool SynchronizeModelArgs::has_invoke_regularizers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SynchronizeModelArgs::set_has_invoke_regularizers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SynchronizeModelArgs::clear_has_invoke_regularizers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SynchronizeModelArgs::clear_invoke_regularizers() {
  invoke_regularizers_ = true;
  clear_has_invoke_regularizers();
}
inline bool SynchronizeModelArgs::invoke_regularizers() const {
  return invoke_regularizers_;
}
inline void SynchronizeModelArgs::set_invoke_regularizers(bool value) {
  set_has_invoke_regularizers();
  invoke_regularizers_ = value;
}

// optional float apply_weight = 4 [default = 1];
inline bool SynchronizeModelArgs::has_apply_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SynchronizeModelArgs::set_has_apply_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SynchronizeModelArgs::clear_has_apply_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SynchronizeModelArgs::clear_apply_weight() {
  apply_weight_ = 1;
  clear_has_apply_weight();
}
inline float SynchronizeModelArgs::apply_weight() const {
  return apply_weight_;
}
inline void SynchronizeModelArgs::set_apply_weight(float value) {
  set_has_apply_weight();
  apply_weight_ = value;
}

// -------------------------------------------------------------------

// InitializeModelArgs_Filter

// optional string class_id = 1;
inline bool InitializeModelArgs_Filter::has_class_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_class_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitializeModelArgs_Filter::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitializeModelArgs_Filter::clear_class_id() {
  if (class_id_ != &::google::protobuf::internal::GetEmptyString()) {
    class_id_->clear();
  }
  clear_has_class_id();
}
inline const ::std::string& InitializeModelArgs_Filter::class_id() const {
  return *class_id_;
}
inline void InitializeModelArgs_Filter::set_class_id(const ::std::string& value) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void InitializeModelArgs_Filter::set_class_id(const char* value) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(value);
}
inline void InitializeModelArgs_Filter::set_class_id(const char* value, size_t size) {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  class_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitializeModelArgs_Filter::mutable_class_id() {
  set_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    class_id_ = new ::std::string;
  }
  return class_id_;
}
inline ::std::string* InitializeModelArgs_Filter::release_class_id() {
  clear_has_class_id();
  if (class_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = class_id_;
    class_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void InitializeModelArgs_Filter::set_allocated_class_id(::std::string* class_id) {
  if (class_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete class_id_;
  }
  if (class_id) {
    set_has_class_id();
    class_id_ = class_id;
  } else {
    clear_has_class_id();
    class_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional float min_percentage = 2;
inline bool InitializeModelArgs_Filter::has_min_percentage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_min_percentage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitializeModelArgs_Filter::clear_has_min_percentage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitializeModelArgs_Filter::clear_min_percentage() {
  min_percentage_ = 0;
  clear_has_min_percentage();
}
inline float InitializeModelArgs_Filter::min_percentage() const {
  return min_percentage_;
}
inline void InitializeModelArgs_Filter::set_min_percentage(float value) {
  set_has_min_percentage();
  min_percentage_ = value;
}

// optional float max_percentage = 3;
inline bool InitializeModelArgs_Filter::has_max_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_max_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitializeModelArgs_Filter::clear_has_max_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitializeModelArgs_Filter::clear_max_percentage() {
  max_percentage_ = 0;
  clear_has_max_percentage();
}
inline float InitializeModelArgs_Filter::max_percentage() const {
  return max_percentage_;
}
inline void InitializeModelArgs_Filter::set_max_percentage(float value) {
  set_has_max_percentage();
  max_percentage_ = value;
}

// optional int32 min_items = 4;
inline bool InitializeModelArgs_Filter::has_min_items() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_min_items() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitializeModelArgs_Filter::clear_has_min_items() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitializeModelArgs_Filter::clear_min_items() {
  min_items_ = 0;
  clear_has_min_items();
}
inline ::google::protobuf::int32 InitializeModelArgs_Filter::min_items() const {
  return min_items_;
}
inline void InitializeModelArgs_Filter::set_min_items(::google::protobuf::int32 value) {
  set_has_min_items();
  min_items_ = value;
}

// optional int32 max_items = 5;
inline bool InitializeModelArgs_Filter::has_max_items() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_max_items() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitializeModelArgs_Filter::clear_has_max_items() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitializeModelArgs_Filter::clear_max_items() {
  max_items_ = 0;
  clear_has_max_items();
}
inline ::google::protobuf::int32 InitializeModelArgs_Filter::max_items() const {
  return max_items_;
}
inline void InitializeModelArgs_Filter::set_max_items(::google::protobuf::int32 value) {
  set_has_max_items();
  max_items_ = value;
}

// optional int32 min_total_count = 6;
inline bool InitializeModelArgs_Filter::has_min_total_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_min_total_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitializeModelArgs_Filter::clear_has_min_total_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitializeModelArgs_Filter::clear_min_total_count() {
  min_total_count_ = 0;
  clear_has_min_total_count();
}
inline ::google::protobuf::int32 InitializeModelArgs_Filter::min_total_count() const {
  return min_total_count_;
}
inline void InitializeModelArgs_Filter::set_min_total_count(::google::protobuf::int32 value) {
  set_has_min_total_count();
  min_total_count_ = value;
}

// optional int32 min_one_item_count = 7;
inline bool InitializeModelArgs_Filter::has_min_one_item_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InitializeModelArgs_Filter::set_has_min_one_item_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InitializeModelArgs_Filter::clear_has_min_one_item_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InitializeModelArgs_Filter::clear_min_one_item_count() {
  min_one_item_count_ = 0;
  clear_has_min_one_item_count();
}
inline ::google::protobuf::int32 InitializeModelArgs_Filter::min_one_item_count() const {
  return min_one_item_count_;
}
inline void InitializeModelArgs_Filter::set_min_one_item_count(::google::protobuf::int32 value) {
  set_has_min_one_item_count();
  min_one_item_count_ = value;
}

// -------------------------------------------------------------------

// InitializeModelArgs

// optional string model_name = 1;
inline bool InitializeModelArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeModelArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitializeModelArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitializeModelArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& InitializeModelArgs::model_name() const {
  return *model_name_;
}
inline void InitializeModelArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void InitializeModelArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void InitializeModelArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitializeModelArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* InitializeModelArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void InitializeModelArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string dictionary_name = 2;
inline bool InitializeModelArgs::has_dictionary_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitializeModelArgs::set_has_dictionary_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitializeModelArgs::clear_has_dictionary_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitializeModelArgs::clear_dictionary_name() {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_->clear();
  }
  clear_has_dictionary_name();
}
inline const ::std::string& InitializeModelArgs::dictionary_name() const {
  return *dictionary_name_;
}
inline void InitializeModelArgs::set_dictionary_name(const ::std::string& value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void InitializeModelArgs::set_dictionary_name(const char* value) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(value);
}
inline void InitializeModelArgs::set_dictionary_name(const char* value, size_t size) {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  dictionary_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitializeModelArgs::mutable_dictionary_name() {
  set_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    dictionary_name_ = new ::std::string;
  }
  return dictionary_name_;
}
inline ::std::string* InitializeModelArgs::release_dictionary_name() {
  clear_has_dictionary_name();
  if (dictionary_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = dictionary_name_;
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void InitializeModelArgs::set_allocated_dictionary_name(::std::string* dictionary_name) {
  if (dictionary_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete dictionary_name_;
  }
  if (dictionary_name) {
    set_has_dictionary_name();
    dictionary_name_ = dictionary_name;
  } else {
    clear_has_dictionary_name();
    dictionary_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.InitializeModelArgs.SourceType source_type = 3 [default = Dictionary];
inline bool InitializeModelArgs::has_source_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitializeModelArgs::set_has_source_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitializeModelArgs::clear_has_source_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitializeModelArgs::clear_source_type() {
  source_type_ = 0;
  clear_has_source_type();
}
inline ::artm::InitializeModelArgs_SourceType InitializeModelArgs::source_type() const {
  return static_cast< ::artm::InitializeModelArgs_SourceType >(source_type_);
}
inline void InitializeModelArgs::set_source_type(::artm::InitializeModelArgs_SourceType value) {
  assert(::artm::InitializeModelArgs_SourceType_IsValid(value));
  set_has_source_type();
  source_type_ = value;
}

// optional string disk_path = 4;
inline bool InitializeModelArgs::has_disk_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitializeModelArgs::set_has_disk_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitializeModelArgs::clear_has_disk_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitializeModelArgs::clear_disk_path() {
  if (disk_path_ != &::google::protobuf::internal::GetEmptyString()) {
    disk_path_->clear();
  }
  clear_has_disk_path();
}
inline const ::std::string& InitializeModelArgs::disk_path() const {
  return *disk_path_;
}
inline void InitializeModelArgs::set_disk_path(const ::std::string& value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void InitializeModelArgs::set_disk_path(const char* value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void InitializeModelArgs::set_disk_path(const char* value, size_t size) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitializeModelArgs::mutable_disk_path() {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  return disk_path_;
}
inline ::std::string* InitializeModelArgs::release_disk_path() {
  clear_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = disk_path_;
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void InitializeModelArgs::set_allocated_disk_path(::std::string* disk_path) {
  if (disk_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete disk_path_;
  }
  if (disk_path) {
    set_has_disk_path();
    disk_path_ = disk_path;
  } else {
    clear_has_disk_path();
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .artm.InitializeModelArgs.Filter filter = 5;
inline int InitializeModelArgs::filter_size() const {
  return filter_.size();
}
inline void InitializeModelArgs::clear_filter() {
  filter_.Clear();
}
inline const ::artm::InitializeModelArgs_Filter& InitializeModelArgs::filter(int index) const {
  return filter_.Get(index);
}
inline ::artm::InitializeModelArgs_Filter* InitializeModelArgs::mutable_filter(int index) {
  return filter_.Mutable(index);
}
inline ::artm::InitializeModelArgs_Filter* InitializeModelArgs::add_filter() {
  return filter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::InitializeModelArgs_Filter >&
InitializeModelArgs::filter() const {
  return filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::InitializeModelArgs_Filter >*
InitializeModelArgs::mutable_filter() {
  return &filter_;
}

// optional int32 topics_count = 6;
inline bool InitializeModelArgs::has_topics_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitializeModelArgs::set_has_topics_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitializeModelArgs::clear_has_topics_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitializeModelArgs::clear_topics_count() {
  topics_count_ = 0;
  clear_has_topics_count();
}
inline ::google::protobuf::int32 InitializeModelArgs::topics_count() const {
  return topics_count_;
}
inline void InitializeModelArgs::set_topics_count(::google::protobuf::int32 value) {
  set_has_topics_count();
  topics_count_ = value;
}

// repeated string topic_name = 7;
inline int InitializeModelArgs::topic_name_size() const {
  return topic_name_.size();
}
inline void InitializeModelArgs::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& InitializeModelArgs::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* InitializeModelArgs::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void InitializeModelArgs::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void InitializeModelArgs::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void InitializeModelArgs::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitializeModelArgs::add_topic_name() {
  return topic_name_.Add();
}
inline void InitializeModelArgs::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void InitializeModelArgs::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void InitializeModelArgs::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InitializeModelArgs::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InitializeModelArgs::mutable_topic_name() {
  return &topic_name_;
}

// -------------------------------------------------------------------

// GetTopicModelArgs

// optional string model_name = 1;
inline bool GetTopicModelArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTopicModelArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTopicModelArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTopicModelArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& GetTopicModelArgs::model_name() const {
  return *model_name_;
}
inline void GetTopicModelArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void GetTopicModelArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void GetTopicModelArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTopicModelArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* GetTopicModelArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetTopicModelArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated string topic_name = 2;
inline int GetTopicModelArgs::topic_name_size() const {
  return topic_name_.size();
}
inline void GetTopicModelArgs::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& GetTopicModelArgs::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* GetTopicModelArgs::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void GetTopicModelArgs::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void GetTopicModelArgs::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void GetTopicModelArgs::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTopicModelArgs::add_topic_name() {
  return topic_name_.Add();
}
inline void GetTopicModelArgs::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void GetTopicModelArgs::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void GetTopicModelArgs::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTopicModelArgs::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTopicModelArgs::mutable_topic_name() {
  return &topic_name_;
}

// repeated string token = 3;
inline int GetTopicModelArgs::token_size() const {
  return token_.size();
}
inline void GetTopicModelArgs::clear_token() {
  token_.Clear();
}
inline const ::std::string& GetTopicModelArgs::token(int index) const {
  return token_.Get(index);
}
inline ::std::string* GetTopicModelArgs::mutable_token(int index) {
  return token_.Mutable(index);
}
inline void GetTopicModelArgs::set_token(int index, const ::std::string& value) {
  token_.Mutable(index)->assign(value);
}
inline void GetTopicModelArgs::set_token(int index, const char* value) {
  token_.Mutable(index)->assign(value);
}
inline void GetTopicModelArgs::set_token(int index, const char* value, size_t size) {
  token_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTopicModelArgs::add_token() {
  return token_.Add();
}
inline void GetTopicModelArgs::add_token(const ::std::string& value) {
  token_.Add()->assign(value);
}
inline void GetTopicModelArgs::add_token(const char* value) {
  token_.Add()->assign(value);
}
inline void GetTopicModelArgs::add_token(const char* value, size_t size) {
  token_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTopicModelArgs::token() const {
  return token_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTopicModelArgs::mutable_token() {
  return &token_;
}

// repeated string class_id = 4;
inline int GetTopicModelArgs::class_id_size() const {
  return class_id_.size();
}
inline void GetTopicModelArgs::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& GetTopicModelArgs::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* GetTopicModelArgs::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void GetTopicModelArgs::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void GetTopicModelArgs::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void GetTopicModelArgs::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetTopicModelArgs::add_class_id() {
  return class_id_.Add();
}
inline void GetTopicModelArgs::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void GetTopicModelArgs::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void GetTopicModelArgs::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTopicModelArgs::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTopicModelArgs::mutable_class_id() {
  return &class_id_;
}

// optional bool use_sparse_format = 5;
inline bool GetTopicModelArgs::has_use_sparse_format() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetTopicModelArgs::set_has_use_sparse_format() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetTopicModelArgs::clear_has_use_sparse_format() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetTopicModelArgs::clear_use_sparse_format() {
  use_sparse_format_ = false;
  clear_has_use_sparse_format();
}
inline bool GetTopicModelArgs::use_sparse_format() const {
  return use_sparse_format_;
}
inline void GetTopicModelArgs::set_use_sparse_format(bool value) {
  set_has_use_sparse_format();
  use_sparse_format_ = value;
}

// optional float eps = 6 [default = 1e-037];
inline bool GetTopicModelArgs::has_eps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetTopicModelArgs::set_has_eps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetTopicModelArgs::clear_has_eps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetTopicModelArgs::clear_eps() {
  eps_ = 1e-037f;
  clear_has_eps();
}
inline float GetTopicModelArgs::eps() const {
  return eps_;
}
inline void GetTopicModelArgs::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// optional .artm.GetTopicModelArgs.RequestType request_type = 7 [default = Pwt];
inline bool GetTopicModelArgs::has_request_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetTopicModelArgs::set_has_request_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetTopicModelArgs::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetTopicModelArgs::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::artm::GetTopicModelArgs_RequestType GetTopicModelArgs::request_type() const {
  return static_cast< ::artm::GetTopicModelArgs_RequestType >(request_type_);
}
inline void GetTopicModelArgs::set_request_type(::artm::GetTopicModelArgs_RequestType value) {
  assert(::artm::GetTopicModelArgs_RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// -------------------------------------------------------------------

// GetThetaMatrixArgs

// optional string model_name = 1;
inline bool GetThetaMatrixArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetThetaMatrixArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetThetaMatrixArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetThetaMatrixArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& GetThetaMatrixArgs::model_name() const {
  return *model_name_;
}
inline void GetThetaMatrixArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void GetThetaMatrixArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void GetThetaMatrixArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetThetaMatrixArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* GetThetaMatrixArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetThetaMatrixArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.Batch batch = 2;
inline bool GetThetaMatrixArgs::has_batch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetThetaMatrixArgs::set_has_batch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetThetaMatrixArgs::clear_has_batch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetThetaMatrixArgs::clear_batch() {
  if (batch_ != NULL) batch_->::artm::Batch::Clear();
  clear_has_batch();
}
inline const ::artm::Batch& GetThetaMatrixArgs::batch() const {
  return batch_ != NULL ? *batch_ : *default_instance_->batch_;
}
inline ::artm::Batch* GetThetaMatrixArgs::mutable_batch() {
  set_has_batch();
  if (batch_ == NULL) batch_ = new ::artm::Batch;
  return batch_;
}
inline ::artm::Batch* GetThetaMatrixArgs::release_batch() {
  clear_has_batch();
  ::artm::Batch* temp = batch_;
  batch_ = NULL;
  return temp;
}
inline void GetThetaMatrixArgs::set_allocated_batch(::artm::Batch* batch) {
  delete batch_;
  batch_ = batch;
  if (batch) {
    set_has_batch();
  } else {
    clear_has_batch();
  }
}

// repeated string topic_name = 3;
inline int GetThetaMatrixArgs::topic_name_size() const {
  return topic_name_.size();
}
inline void GetThetaMatrixArgs::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& GetThetaMatrixArgs::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* GetThetaMatrixArgs::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void GetThetaMatrixArgs::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void GetThetaMatrixArgs::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void GetThetaMatrixArgs::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetThetaMatrixArgs::add_topic_name() {
  return topic_name_.Add();
}
inline void GetThetaMatrixArgs::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void GetThetaMatrixArgs::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void GetThetaMatrixArgs::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetThetaMatrixArgs::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetThetaMatrixArgs::mutable_topic_name() {
  return &topic_name_;
}

// repeated int32 topic_index = 4;
inline int GetThetaMatrixArgs::topic_index_size() const {
  return topic_index_.size();
}
inline void GetThetaMatrixArgs::clear_topic_index() {
  topic_index_.Clear();
}
inline ::google::protobuf::int32 GetThetaMatrixArgs::topic_index(int index) const {
  return topic_index_.Get(index);
}
inline void GetThetaMatrixArgs::set_topic_index(int index, ::google::protobuf::int32 value) {
  topic_index_.Set(index, value);
}
inline void GetThetaMatrixArgs::add_topic_index(::google::protobuf::int32 value) {
  topic_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GetThetaMatrixArgs::topic_index() const {
  return topic_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GetThetaMatrixArgs::mutable_topic_index() {
  return &topic_index_;
}

// optional bool clean_cache = 5 [default = false];
inline bool GetThetaMatrixArgs::has_clean_cache() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetThetaMatrixArgs::set_has_clean_cache() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetThetaMatrixArgs::clear_has_clean_cache() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetThetaMatrixArgs::clear_clean_cache() {
  clean_cache_ = false;
  clear_has_clean_cache();
}
inline bool GetThetaMatrixArgs::clean_cache() const {
  return clean_cache_;
}
inline void GetThetaMatrixArgs::set_clean_cache(bool value) {
  set_has_clean_cache();
  clean_cache_ = value;
}

// optional bool use_sparse_format = 6;
inline bool GetThetaMatrixArgs::has_use_sparse_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetThetaMatrixArgs::set_has_use_sparse_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetThetaMatrixArgs::clear_has_use_sparse_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetThetaMatrixArgs::clear_use_sparse_format() {
  use_sparse_format_ = false;
  clear_has_use_sparse_format();
}
inline bool GetThetaMatrixArgs::use_sparse_format() const {
  return use_sparse_format_;
}
inline void GetThetaMatrixArgs::set_use_sparse_format(bool value) {
  set_has_use_sparse_format();
  use_sparse_format_ = value;
}

// optional float eps = 7 [default = 1e-037];
inline bool GetThetaMatrixArgs::has_eps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetThetaMatrixArgs::set_has_eps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetThetaMatrixArgs::clear_has_eps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetThetaMatrixArgs::clear_eps() {
  eps_ = 1e-037f;
  clear_has_eps();
}
inline float GetThetaMatrixArgs::eps() const {
  return eps_;
}
inline void GetThetaMatrixArgs::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// -------------------------------------------------------------------

// GetScoreValueArgs

// optional string model_name = 1;
inline bool GetScoreValueArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetScoreValueArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetScoreValueArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetScoreValueArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& GetScoreValueArgs::model_name() const {
  return *model_name_;
}
inline void GetScoreValueArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void GetScoreValueArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void GetScoreValueArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetScoreValueArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* GetScoreValueArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetScoreValueArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string score_name = 2;
inline bool GetScoreValueArgs::has_score_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetScoreValueArgs::set_has_score_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetScoreValueArgs::clear_has_score_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetScoreValueArgs::clear_score_name() {
  if (score_name_ != &::google::protobuf::internal::GetEmptyString()) {
    score_name_->clear();
  }
  clear_has_score_name();
}
inline const ::std::string& GetScoreValueArgs::score_name() const {
  return *score_name_;
}
inline void GetScoreValueArgs::set_score_name(const ::std::string& value) {
  set_has_score_name();
  if (score_name_ == &::google::protobuf::internal::GetEmptyString()) {
    score_name_ = new ::std::string;
  }
  score_name_->assign(value);
}
inline void GetScoreValueArgs::set_score_name(const char* value) {
  set_has_score_name();
  if (score_name_ == &::google::protobuf::internal::GetEmptyString()) {
    score_name_ = new ::std::string;
  }
  score_name_->assign(value);
}
inline void GetScoreValueArgs::set_score_name(const char* value, size_t size) {
  set_has_score_name();
  if (score_name_ == &::google::protobuf::internal::GetEmptyString()) {
    score_name_ = new ::std::string;
  }
  score_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetScoreValueArgs::mutable_score_name() {
  set_has_score_name();
  if (score_name_ == &::google::protobuf::internal::GetEmptyString()) {
    score_name_ = new ::std::string;
  }
  return score_name_;
}
inline ::std::string* GetScoreValueArgs::release_score_name() {
  clear_has_score_name();
  if (score_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = score_name_;
    score_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetScoreValueArgs::set_allocated_score_name(::std::string* score_name) {
  if (score_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete score_name_;
  }
  if (score_name) {
    set_has_score_name();
    score_name_ = score_name;
  } else {
    clear_has_score_name();
    score_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .artm.Batch batch = 3;
inline bool GetScoreValueArgs::has_batch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetScoreValueArgs::set_has_batch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetScoreValueArgs::clear_has_batch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetScoreValueArgs::clear_batch() {
  if (batch_ != NULL) batch_->::artm::Batch::Clear();
  clear_has_batch();
}
inline const ::artm::Batch& GetScoreValueArgs::batch() const {
  return batch_ != NULL ? *batch_ : *default_instance_->batch_;
}
inline ::artm::Batch* GetScoreValueArgs::mutable_batch() {
  set_has_batch();
  if (batch_ == NULL) batch_ = new ::artm::Batch;
  return batch_;
}
inline ::artm::Batch* GetScoreValueArgs::release_batch() {
  clear_has_batch();
  ::artm::Batch* temp = batch_;
  batch_ = NULL;
  return temp;
}
inline void GetScoreValueArgs::set_allocated_batch(::artm::Batch* batch) {
  delete batch_;
  batch_ = batch;
  if (batch) {
    set_has_batch();
  } else {
    clear_has_batch();
  }
}

// -------------------------------------------------------------------

// AddBatchArgs

// optional .artm.Batch batch = 1;
inline bool AddBatchArgs::has_batch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddBatchArgs::set_has_batch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddBatchArgs::clear_has_batch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddBatchArgs::clear_batch() {
  if (batch_ != NULL) batch_->::artm::Batch::Clear();
  clear_has_batch();
}
inline const ::artm::Batch& AddBatchArgs::batch() const {
  return batch_ != NULL ? *batch_ : *default_instance_->batch_;
}
inline ::artm::Batch* AddBatchArgs::mutable_batch() {
  set_has_batch();
  if (batch_ == NULL) batch_ = new ::artm::Batch;
  return batch_;
}
inline ::artm::Batch* AddBatchArgs::release_batch() {
  clear_has_batch();
  ::artm::Batch* temp = batch_;
  batch_ = NULL;
  return temp;
}
inline void AddBatchArgs::set_allocated_batch(::artm::Batch* batch) {
  delete batch_;
  batch_ = batch;
  if (batch) {
    set_has_batch();
  } else {
    clear_has_batch();
  }
}

// optional int32 timeout_milliseconds = 2 [default = -1];
inline bool AddBatchArgs::has_timeout_milliseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddBatchArgs::set_has_timeout_milliseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddBatchArgs::clear_has_timeout_milliseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddBatchArgs::clear_timeout_milliseconds() {
  timeout_milliseconds_ = -1;
  clear_has_timeout_milliseconds();
}
inline ::google::protobuf::int32 AddBatchArgs::timeout_milliseconds() const {
  return timeout_milliseconds_;
}
inline void AddBatchArgs::set_timeout_milliseconds(::google::protobuf::int32 value) {
  set_has_timeout_milliseconds();
  timeout_milliseconds_ = value;
}

// optional bool reset_scores = 3 [default = false];
inline bool AddBatchArgs::has_reset_scores() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddBatchArgs::set_has_reset_scores() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddBatchArgs::clear_has_reset_scores() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddBatchArgs::clear_reset_scores() {
  reset_scores_ = false;
  clear_has_reset_scores();
}
inline bool AddBatchArgs::reset_scores() const {
  return reset_scores_;
}
inline void AddBatchArgs::set_reset_scores(bool value) {
  set_has_reset_scores();
  reset_scores_ = value;
}

// optional string batch_file_name = 4;
inline bool AddBatchArgs::has_batch_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddBatchArgs::set_has_batch_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddBatchArgs::clear_has_batch_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddBatchArgs::clear_batch_file_name() {
  if (batch_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    batch_file_name_->clear();
  }
  clear_has_batch_file_name();
}
inline const ::std::string& AddBatchArgs::batch_file_name() const {
  return *batch_file_name_;
}
inline void AddBatchArgs::set_batch_file_name(const ::std::string& value) {
  set_has_batch_file_name();
  if (batch_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    batch_file_name_ = new ::std::string;
  }
  batch_file_name_->assign(value);
}
inline void AddBatchArgs::set_batch_file_name(const char* value) {
  set_has_batch_file_name();
  if (batch_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    batch_file_name_ = new ::std::string;
  }
  batch_file_name_->assign(value);
}
inline void AddBatchArgs::set_batch_file_name(const char* value, size_t size) {
  set_has_batch_file_name();
  if (batch_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    batch_file_name_ = new ::std::string;
  }
  batch_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBatchArgs::mutable_batch_file_name() {
  set_has_batch_file_name();
  if (batch_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    batch_file_name_ = new ::std::string;
  }
  return batch_file_name_;
}
inline ::std::string* AddBatchArgs::release_batch_file_name() {
  clear_has_batch_file_name();
  if (batch_file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = batch_file_name_;
    batch_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void AddBatchArgs::set_allocated_batch_file_name(::std::string* batch_file_name) {
  if (batch_file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete batch_file_name_;
  }
  if (batch_file_name) {
    set_has_batch_file_name();
    batch_file_name_ = batch_file_name;
  } else {
    clear_has_batch_file_name();
    batch_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// InvokeIterationArgs

// optional int32 iterations_count = 1 [default = 1];
inline bool InvokeIterationArgs::has_iterations_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvokeIterationArgs::set_has_iterations_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvokeIterationArgs::clear_has_iterations_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvokeIterationArgs::clear_iterations_count() {
  iterations_count_ = 1;
  clear_has_iterations_count();
}
inline ::google::protobuf::int32 InvokeIterationArgs::iterations_count() const {
  return iterations_count_;
}
inline void InvokeIterationArgs::set_iterations_count(::google::protobuf::int32 value) {
  set_has_iterations_count();
  iterations_count_ = value;
}

// optional bool reset_scores = 2 [default = true];
inline bool InvokeIterationArgs::has_reset_scores() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvokeIterationArgs::set_has_reset_scores() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvokeIterationArgs::clear_has_reset_scores() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvokeIterationArgs::clear_reset_scores() {
  reset_scores_ = true;
  clear_has_reset_scores();
}
inline bool InvokeIterationArgs::reset_scores() const {
  return reset_scores_;
}
inline void InvokeIterationArgs::set_reset_scores(bool value) {
  set_has_reset_scores();
  reset_scores_ = value;
}

// optional string disk_path = 3;
inline bool InvokeIterationArgs::has_disk_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvokeIterationArgs::set_has_disk_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvokeIterationArgs::clear_has_disk_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvokeIterationArgs::clear_disk_path() {
  if (disk_path_ != &::google::protobuf::internal::GetEmptyString()) {
    disk_path_->clear();
  }
  clear_has_disk_path();
}
inline const ::std::string& InvokeIterationArgs::disk_path() const {
  return *disk_path_;
}
inline void InvokeIterationArgs::set_disk_path(const ::std::string& value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void InvokeIterationArgs::set_disk_path(const char* value) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(value);
}
inline void InvokeIterationArgs::set_disk_path(const char* value, size_t size) {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  disk_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvokeIterationArgs::mutable_disk_path() {
  set_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    disk_path_ = new ::std::string;
  }
  return disk_path_;
}
inline ::std::string* InvokeIterationArgs::release_disk_path() {
  clear_has_disk_path();
  if (disk_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = disk_path_;
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void InvokeIterationArgs::set_allocated_disk_path(::std::string* disk_path) {
  if (disk_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete disk_path_;
  }
  if (disk_path) {
    set_has_disk_path();
    disk_path_ = disk_path;
  } else {
    clear_has_disk_path();
    disk_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// WaitIdleArgs

// optional int32 timeout_milliseconds = 1 [default = -1];
inline bool WaitIdleArgs::has_timeout_milliseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaitIdleArgs::set_has_timeout_milliseconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaitIdleArgs::clear_has_timeout_milliseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaitIdleArgs::clear_timeout_milliseconds() {
  timeout_milliseconds_ = -1;
  clear_has_timeout_milliseconds();
}
inline ::google::protobuf::int32 WaitIdleArgs::timeout_milliseconds() const {
  return timeout_milliseconds_;
}
inline void WaitIdleArgs::set_timeout_milliseconds(::google::protobuf::int32 value) {
  set_has_timeout_milliseconds();
  timeout_milliseconds_ = value;
}

// -------------------------------------------------------------------

// ExportModelArgs

// optional string file_name = 1;
inline bool ExportModelArgs::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExportModelArgs::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExportModelArgs::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExportModelArgs::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& ExportModelArgs::file_name() const {
  return *file_name_;
}
inline void ExportModelArgs::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void ExportModelArgs::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void ExportModelArgs::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExportModelArgs::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* ExportModelArgs::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ExportModelArgs::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string model_name = 2;
inline bool ExportModelArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExportModelArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExportModelArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExportModelArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& ExportModelArgs::model_name() const {
  return *model_name_;
}
inline void ExportModelArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ExportModelArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ExportModelArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExportModelArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* ExportModelArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ExportModelArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ImportModelArgs

// optional string file_name = 1;
inline bool ImportModelArgs::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImportModelArgs::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImportModelArgs::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImportModelArgs::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& ImportModelArgs::file_name() const {
  return *file_name_;
}
inline void ImportModelArgs::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void ImportModelArgs::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void ImportModelArgs::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImportModelArgs::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* ImportModelArgs::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ImportModelArgs::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string model_name = 2;
inline bool ImportModelArgs::has_model_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImportModelArgs::set_has_model_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImportModelArgs::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImportModelArgs::clear_model_name() {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    model_name_->clear();
  }
  clear_has_model_name();
}
inline const ::std::string& ImportModelArgs::model_name() const {
  return *model_name_;
}
inline void ImportModelArgs::set_model_name(const ::std::string& value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ImportModelArgs::set_model_name(const char* value) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(value);
}
inline void ImportModelArgs::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  model_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImportModelArgs::mutable_model_name() {
  set_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    model_name_ = new ::std::string;
  }
  return model_name_;
}
inline ::std::string* ImportModelArgs::release_model_name() {
  clear_has_model_name();
  if (model_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = model_name_;
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ImportModelArgs::set_allocated_model_name(::std::string* model_name) {
  if (model_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete model_name_;
  }
  if (model_name) {
    set_has_model_name();
    model_name_ = model_name;
  } else {
    clear_has_model_name();
    model_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ProcessBatchesArgs

// optional string nwt_target_name = 1;
inline bool ProcessBatchesArgs::has_nwt_target_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessBatchesArgs::set_has_nwt_target_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessBatchesArgs::clear_has_nwt_target_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessBatchesArgs::clear_nwt_target_name() {
  if (nwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_->clear();
  }
  clear_has_nwt_target_name();
}
inline const ::std::string& ProcessBatchesArgs::nwt_target_name() const {
  return *nwt_target_name_;
}
inline void ProcessBatchesArgs::set_nwt_target_name(const ::std::string& value) {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  nwt_target_name_->assign(value);
}
inline void ProcessBatchesArgs::set_nwt_target_name(const char* value) {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  nwt_target_name_->assign(value);
}
inline void ProcessBatchesArgs::set_nwt_target_name(const char* value, size_t size) {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  nwt_target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessBatchesArgs::mutable_nwt_target_name() {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  return nwt_target_name_;
}
inline ::std::string* ProcessBatchesArgs::release_nwt_target_name() {
  clear_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = nwt_target_name_;
    nwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ProcessBatchesArgs::set_allocated_nwt_target_name(::std::string* nwt_target_name) {
  if (nwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete nwt_target_name_;
  }
  if (nwt_target_name) {
    set_has_nwt_target_name();
    nwt_target_name_ = nwt_target_name;
  } else {
    clear_has_nwt_target_name();
    nwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated string batch_filename = 2;
inline int ProcessBatchesArgs::batch_filename_size() const {
  return batch_filename_.size();
}
inline void ProcessBatchesArgs::clear_batch_filename() {
  batch_filename_.Clear();
}
inline const ::std::string& ProcessBatchesArgs::batch_filename(int index) const {
  return batch_filename_.Get(index);
}
inline ::std::string* ProcessBatchesArgs::mutable_batch_filename(int index) {
  return batch_filename_.Mutable(index);
}
inline void ProcessBatchesArgs::set_batch_filename(int index, const ::std::string& value) {
  batch_filename_.Mutable(index)->assign(value);
}
inline void ProcessBatchesArgs::set_batch_filename(int index, const char* value) {
  batch_filename_.Mutable(index)->assign(value);
}
inline void ProcessBatchesArgs::set_batch_filename(int index, const char* value, size_t size) {
  batch_filename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessBatchesArgs::add_batch_filename() {
  return batch_filename_.Add();
}
inline void ProcessBatchesArgs::add_batch_filename(const ::std::string& value) {
  batch_filename_.Add()->assign(value);
}
inline void ProcessBatchesArgs::add_batch_filename(const char* value) {
  batch_filename_.Add()->assign(value);
}
inline void ProcessBatchesArgs::add_batch_filename(const char* value, size_t size) {
  batch_filename_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcessBatchesArgs::batch_filename() const {
  return batch_filename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcessBatchesArgs::mutable_batch_filename() {
  return &batch_filename_;
}

// optional string pwt_source_name = 3;
inline bool ProcessBatchesArgs::has_pwt_source_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessBatchesArgs::set_has_pwt_source_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessBatchesArgs::clear_has_pwt_source_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessBatchesArgs::clear_pwt_source_name() {
  if (pwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_->clear();
  }
  clear_has_pwt_source_name();
}
inline const ::std::string& ProcessBatchesArgs::pwt_source_name() const {
  return *pwt_source_name_;
}
inline void ProcessBatchesArgs::set_pwt_source_name(const ::std::string& value) {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  pwt_source_name_->assign(value);
}
inline void ProcessBatchesArgs::set_pwt_source_name(const char* value) {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  pwt_source_name_->assign(value);
}
inline void ProcessBatchesArgs::set_pwt_source_name(const char* value, size_t size) {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  pwt_source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessBatchesArgs::mutable_pwt_source_name() {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  return pwt_source_name_;
}
inline ::std::string* ProcessBatchesArgs::release_pwt_source_name() {
  clear_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = pwt_source_name_;
    pwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ProcessBatchesArgs::set_allocated_pwt_source_name(::std::string* pwt_source_name) {
  if (pwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete pwt_source_name_;
  }
  if (pwt_source_name) {
    set_has_pwt_source_name();
    pwt_source_name_ = pwt_source_name;
  } else {
    clear_has_pwt_source_name();
    pwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 inner_iterations_count = 4 [default = 10];
inline bool ProcessBatchesArgs::has_inner_iterations_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessBatchesArgs::set_has_inner_iterations_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessBatchesArgs::clear_has_inner_iterations_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessBatchesArgs::clear_inner_iterations_count() {
  inner_iterations_count_ = 10;
  clear_has_inner_iterations_count();
}
inline ::google::protobuf::int32 ProcessBatchesArgs::inner_iterations_count() const {
  return inner_iterations_count_;
}
inline void ProcessBatchesArgs::set_inner_iterations_count(::google::protobuf::int32 value) {
  set_has_inner_iterations_count();
  inner_iterations_count_ = value;
}

// optional string stream_name = 5 [default = "@global"];
inline bool ProcessBatchesArgs::has_stream_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessBatchesArgs::set_has_stream_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessBatchesArgs::clear_has_stream_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessBatchesArgs::clear_stream_name() {
  if (stream_name_ != _default_stream_name_) {
    stream_name_->assign(*_default_stream_name_);
  }
  clear_has_stream_name();
}
inline const ::std::string& ProcessBatchesArgs::stream_name() const {
  return *stream_name_;
}
inline void ProcessBatchesArgs::set_stream_name(const ::std::string& value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ProcessBatchesArgs::set_stream_name(const char* value) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(value);
}
inline void ProcessBatchesArgs::set_stream_name(const char* value, size_t size) {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string;
  }
  stream_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessBatchesArgs::mutable_stream_name() {
  set_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    stream_name_ = new ::std::string(*_default_stream_name_);
  }
  return stream_name_;
}
inline ::std::string* ProcessBatchesArgs::release_stream_name() {
  clear_has_stream_name();
  if (stream_name_ == _default_stream_name_) {
    return NULL;
  } else {
    ::std::string* temp = stream_name_;
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
    return temp;
  }
}
inline void ProcessBatchesArgs::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name_ != _default_stream_name_) {
    delete stream_name_;
  }
  if (stream_name) {
    set_has_stream_name();
    stream_name_ = stream_name;
  } else {
    clear_has_stream_name();
    stream_name_ = const_cast< ::std::string*>(_default_stream_name_);
  }
}

// repeated string regularizer_name = 6;
inline int ProcessBatchesArgs::regularizer_name_size() const {
  return regularizer_name_.size();
}
inline void ProcessBatchesArgs::clear_regularizer_name() {
  regularizer_name_.Clear();
}
inline const ::std::string& ProcessBatchesArgs::regularizer_name(int index) const {
  return regularizer_name_.Get(index);
}
inline ::std::string* ProcessBatchesArgs::mutable_regularizer_name(int index) {
  return regularizer_name_.Mutable(index);
}
inline void ProcessBatchesArgs::set_regularizer_name(int index, const ::std::string& value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ProcessBatchesArgs::set_regularizer_name(int index, const char* value) {
  regularizer_name_.Mutable(index)->assign(value);
}
inline void ProcessBatchesArgs::set_regularizer_name(int index, const char* value, size_t size) {
  regularizer_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessBatchesArgs::add_regularizer_name() {
  return regularizer_name_.Add();
}
inline void ProcessBatchesArgs::add_regularizer_name(const ::std::string& value) {
  regularizer_name_.Add()->assign(value);
}
inline void ProcessBatchesArgs::add_regularizer_name(const char* value) {
  regularizer_name_.Add()->assign(value);
}
inline void ProcessBatchesArgs::add_regularizer_name(const char* value, size_t size) {
  regularizer_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcessBatchesArgs::regularizer_name() const {
  return regularizer_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcessBatchesArgs::mutable_regularizer_name() {
  return &regularizer_name_;
}

// repeated double regularizer_tau = 7;
inline int ProcessBatchesArgs::regularizer_tau_size() const {
  return regularizer_tau_.size();
}
inline void ProcessBatchesArgs::clear_regularizer_tau() {
  regularizer_tau_.Clear();
}
inline double ProcessBatchesArgs::regularizer_tau(int index) const {
  return regularizer_tau_.Get(index);
}
inline void ProcessBatchesArgs::set_regularizer_tau(int index, double value) {
  regularizer_tau_.Set(index, value);
}
inline void ProcessBatchesArgs::add_regularizer_tau(double value) {
  regularizer_tau_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ProcessBatchesArgs::regularizer_tau() const {
  return regularizer_tau_;
}
inline ::google::protobuf::RepeatedField< double >*
ProcessBatchesArgs::mutable_regularizer_tau() {
  return &regularizer_tau_;
}

// repeated string class_id = 8;
inline int ProcessBatchesArgs::class_id_size() const {
  return class_id_.size();
}
inline void ProcessBatchesArgs::clear_class_id() {
  class_id_.Clear();
}
inline const ::std::string& ProcessBatchesArgs::class_id(int index) const {
  return class_id_.Get(index);
}
inline ::std::string* ProcessBatchesArgs::mutable_class_id(int index) {
  return class_id_.Mutable(index);
}
inline void ProcessBatchesArgs::set_class_id(int index, const ::std::string& value) {
  class_id_.Mutable(index)->assign(value);
}
inline void ProcessBatchesArgs::set_class_id(int index, const char* value) {
  class_id_.Mutable(index)->assign(value);
}
inline void ProcessBatchesArgs::set_class_id(int index, const char* value, size_t size) {
  class_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessBatchesArgs::add_class_id() {
  return class_id_.Add();
}
inline void ProcessBatchesArgs::add_class_id(const ::std::string& value) {
  class_id_.Add()->assign(value);
}
inline void ProcessBatchesArgs::add_class_id(const char* value) {
  class_id_.Add()->assign(value);
}
inline void ProcessBatchesArgs::add_class_id(const char* value, size_t size) {
  class_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcessBatchesArgs::class_id() const {
  return class_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcessBatchesArgs::mutable_class_id() {
  return &class_id_;
}

// repeated float class_weight = 9;
inline int ProcessBatchesArgs::class_weight_size() const {
  return class_weight_.size();
}
inline void ProcessBatchesArgs::clear_class_weight() {
  class_weight_.Clear();
}
inline float ProcessBatchesArgs::class_weight(int index) const {
  return class_weight_.Get(index);
}
inline void ProcessBatchesArgs::set_class_weight(int index, float value) {
  class_weight_.Set(index, value);
}
inline void ProcessBatchesArgs::add_class_weight(float value) {
  class_weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ProcessBatchesArgs::class_weight() const {
  return class_weight_;
}
inline ::google::protobuf::RepeatedField< float >*
ProcessBatchesArgs::mutable_class_weight() {
  return &class_weight_;
}

// optional bool reuse_theta = 10 [default = false];
inline bool ProcessBatchesArgs::has_reuse_theta() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProcessBatchesArgs::set_has_reuse_theta() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProcessBatchesArgs::clear_has_reuse_theta() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProcessBatchesArgs::clear_reuse_theta() {
  reuse_theta_ = false;
  clear_has_reuse_theta();
}
inline bool ProcessBatchesArgs::reuse_theta() const {
  return reuse_theta_;
}
inline void ProcessBatchesArgs::set_reuse_theta(bool value) {
  set_has_reuse_theta();
  reuse_theta_ = value;
}

// optional bool opt_for_avx = 11 [default = true];
inline bool ProcessBatchesArgs::has_opt_for_avx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProcessBatchesArgs::set_has_opt_for_avx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProcessBatchesArgs::clear_has_opt_for_avx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProcessBatchesArgs::clear_opt_for_avx() {
  opt_for_avx_ = true;
  clear_has_opt_for_avx();
}
inline bool ProcessBatchesArgs::opt_for_avx() const {
  return opt_for_avx_;
}
inline void ProcessBatchesArgs::set_opt_for_avx(bool value) {
  set_has_opt_for_avx();
  opt_for_avx_ = value;
}

// optional bool use_sparse_bow = 12 [default = true];
inline bool ProcessBatchesArgs::has_use_sparse_bow() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProcessBatchesArgs::set_has_use_sparse_bow() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProcessBatchesArgs::clear_has_use_sparse_bow() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProcessBatchesArgs::clear_use_sparse_bow() {
  use_sparse_bow_ = true;
  clear_has_use_sparse_bow();
}
inline bool ProcessBatchesArgs::use_sparse_bow() const {
  return use_sparse_bow_;
}
inline void ProcessBatchesArgs::set_use_sparse_bow(bool value) {
  set_has_use_sparse_bow();
  use_sparse_bow_ = value;
}

// optional bool reset_scores = 13 [default = true];
inline bool ProcessBatchesArgs::has_reset_scores() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProcessBatchesArgs::set_has_reset_scores() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProcessBatchesArgs::clear_has_reset_scores() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProcessBatchesArgs::clear_reset_scores() {
  reset_scores_ = true;
  clear_has_reset_scores();
}
inline bool ProcessBatchesArgs::reset_scores() const {
  return reset_scores_;
}
inline void ProcessBatchesArgs::set_reset_scores(bool value) {
  set_has_reset_scores();
  reset_scores_ = value;
}

// optional .artm.ProcessBatchesArgs.ThetaMatrixType theta_matrix_type = 14 [default = Cache];
inline bool ProcessBatchesArgs::has_theta_matrix_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProcessBatchesArgs::set_has_theta_matrix_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProcessBatchesArgs::clear_has_theta_matrix_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProcessBatchesArgs::clear_theta_matrix_type() {
  theta_matrix_type_ = 3;
  clear_has_theta_matrix_type();
}
inline ::artm::ProcessBatchesArgs_ThetaMatrixType ProcessBatchesArgs::theta_matrix_type() const {
  return static_cast< ::artm::ProcessBatchesArgs_ThetaMatrixType >(theta_matrix_type_);
}
inline void ProcessBatchesArgs::set_theta_matrix_type(::artm::ProcessBatchesArgs_ThetaMatrixType value) {
  assert(::artm::ProcessBatchesArgs_ThetaMatrixType_IsValid(value));
  set_has_theta_matrix_type();
  theta_matrix_type_ = value;
}

// -------------------------------------------------------------------

// ProcessBatchesResult

// repeated .artm.ScoreData score_data = 1;
inline int ProcessBatchesResult::score_data_size() const {
  return score_data_.size();
}
inline void ProcessBatchesResult::clear_score_data() {
  score_data_.Clear();
}
inline const ::artm::ScoreData& ProcessBatchesResult::score_data(int index) const {
  return score_data_.Get(index);
}
inline ::artm::ScoreData* ProcessBatchesResult::mutable_score_data(int index) {
  return score_data_.Mutable(index);
}
inline ::artm::ScoreData* ProcessBatchesResult::add_score_data() {
  return score_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::ScoreData >&
ProcessBatchesResult::score_data() const {
  return score_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::ScoreData >*
ProcessBatchesResult::mutable_score_data() {
  return &score_data_;
}

// optional .artm.ThetaMatrix theta_matrix = 2;
inline bool ProcessBatchesResult::has_theta_matrix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessBatchesResult::set_has_theta_matrix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessBatchesResult::clear_has_theta_matrix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessBatchesResult::clear_theta_matrix() {
  if (theta_matrix_ != NULL) theta_matrix_->::artm::ThetaMatrix::Clear();
  clear_has_theta_matrix();
}
inline const ::artm::ThetaMatrix& ProcessBatchesResult::theta_matrix() const {
  return theta_matrix_ != NULL ? *theta_matrix_ : *default_instance_->theta_matrix_;
}
inline ::artm::ThetaMatrix* ProcessBatchesResult::mutable_theta_matrix() {
  set_has_theta_matrix();
  if (theta_matrix_ == NULL) theta_matrix_ = new ::artm::ThetaMatrix;
  return theta_matrix_;
}
inline ::artm::ThetaMatrix* ProcessBatchesResult::release_theta_matrix() {
  clear_has_theta_matrix();
  ::artm::ThetaMatrix* temp = theta_matrix_;
  theta_matrix_ = NULL;
  return temp;
}
inline void ProcessBatchesResult::set_allocated_theta_matrix(::artm::ThetaMatrix* theta_matrix) {
  delete theta_matrix_;
  theta_matrix_ = theta_matrix;
  if (theta_matrix) {
    set_has_theta_matrix();
  } else {
    clear_has_theta_matrix();
  }
}

// -------------------------------------------------------------------

// MergeModelArgs

// optional string nwt_target_name = 1;
inline bool MergeModelArgs::has_nwt_target_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MergeModelArgs::set_has_nwt_target_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MergeModelArgs::clear_has_nwt_target_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MergeModelArgs::clear_nwt_target_name() {
  if (nwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_->clear();
  }
  clear_has_nwt_target_name();
}
inline const ::std::string& MergeModelArgs::nwt_target_name() const {
  return *nwt_target_name_;
}
inline void MergeModelArgs::set_nwt_target_name(const ::std::string& value) {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  nwt_target_name_->assign(value);
}
inline void MergeModelArgs::set_nwt_target_name(const char* value) {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  nwt_target_name_->assign(value);
}
inline void MergeModelArgs::set_nwt_target_name(const char* value, size_t size) {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  nwt_target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeModelArgs::mutable_nwt_target_name() {
  set_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_target_name_ = new ::std::string;
  }
  return nwt_target_name_;
}
inline ::std::string* MergeModelArgs::release_nwt_target_name() {
  clear_has_nwt_target_name();
  if (nwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = nwt_target_name_;
    nwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MergeModelArgs::set_allocated_nwt_target_name(::std::string* nwt_target_name) {
  if (nwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete nwt_target_name_;
  }
  if (nwt_target_name) {
    set_has_nwt_target_name();
    nwt_target_name_ = nwt_target_name;
  } else {
    clear_has_nwt_target_name();
    nwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated string nwt_source_name = 2;
inline int MergeModelArgs::nwt_source_name_size() const {
  return nwt_source_name_.size();
}
inline void MergeModelArgs::clear_nwt_source_name() {
  nwt_source_name_.Clear();
}
inline const ::std::string& MergeModelArgs::nwt_source_name(int index) const {
  return nwt_source_name_.Get(index);
}
inline ::std::string* MergeModelArgs::mutable_nwt_source_name(int index) {
  return nwt_source_name_.Mutable(index);
}
inline void MergeModelArgs::set_nwt_source_name(int index, const ::std::string& value) {
  nwt_source_name_.Mutable(index)->assign(value);
}
inline void MergeModelArgs::set_nwt_source_name(int index, const char* value) {
  nwt_source_name_.Mutable(index)->assign(value);
}
inline void MergeModelArgs::set_nwt_source_name(int index, const char* value, size_t size) {
  nwt_source_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeModelArgs::add_nwt_source_name() {
  return nwt_source_name_.Add();
}
inline void MergeModelArgs::add_nwt_source_name(const ::std::string& value) {
  nwt_source_name_.Add()->assign(value);
}
inline void MergeModelArgs::add_nwt_source_name(const char* value) {
  nwt_source_name_.Add()->assign(value);
}
inline void MergeModelArgs::add_nwt_source_name(const char* value, size_t size) {
  nwt_source_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MergeModelArgs::nwt_source_name() const {
  return nwt_source_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MergeModelArgs::mutable_nwt_source_name() {
  return &nwt_source_name_;
}

// repeated float source_weight = 3;
inline int MergeModelArgs::source_weight_size() const {
  return source_weight_.size();
}
inline void MergeModelArgs::clear_source_weight() {
  source_weight_.Clear();
}
inline float MergeModelArgs::source_weight(int index) const {
  return source_weight_.Get(index);
}
inline void MergeModelArgs::set_source_weight(int index, float value) {
  source_weight_.Set(index, value);
}
inline void MergeModelArgs::add_source_weight(float value) {
  source_weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
MergeModelArgs::source_weight() const {
  return source_weight_;
}
inline ::google::protobuf::RepeatedField< float >*
MergeModelArgs::mutable_source_weight() {
  return &source_weight_;
}

// repeated string topic_name = 4;
inline int MergeModelArgs::topic_name_size() const {
  return topic_name_.size();
}
inline void MergeModelArgs::clear_topic_name() {
  topic_name_.Clear();
}
inline const ::std::string& MergeModelArgs::topic_name(int index) const {
  return topic_name_.Get(index);
}
inline ::std::string* MergeModelArgs::mutable_topic_name(int index) {
  return topic_name_.Mutable(index);
}
inline void MergeModelArgs::set_topic_name(int index, const ::std::string& value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void MergeModelArgs::set_topic_name(int index, const char* value) {
  topic_name_.Mutable(index)->assign(value);
}
inline void MergeModelArgs::set_topic_name(int index, const char* value, size_t size) {
  topic_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MergeModelArgs::add_topic_name() {
  return topic_name_.Add();
}
inline void MergeModelArgs::add_topic_name(const ::std::string& value) {
  topic_name_.Add()->assign(value);
}
inline void MergeModelArgs::add_topic_name(const char* value) {
  topic_name_.Add()->assign(value);
}
inline void MergeModelArgs::add_topic_name(const char* value, size_t size) {
  topic_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MergeModelArgs::topic_name() const {
  return topic_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MergeModelArgs::mutable_topic_name() {
  return &topic_name_;
}

// -------------------------------------------------------------------

// RegularizeModelArgs

// optional string rwt_target_name = 1;
inline bool RegularizeModelArgs::has_rwt_target_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularizeModelArgs::set_has_rwt_target_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularizeModelArgs::clear_has_rwt_target_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularizeModelArgs::clear_rwt_target_name() {
  if (rwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    rwt_target_name_->clear();
  }
  clear_has_rwt_target_name();
}
inline const ::std::string& RegularizeModelArgs::rwt_target_name() const {
  return *rwt_target_name_;
}
inline void RegularizeModelArgs::set_rwt_target_name(const ::std::string& value) {
  set_has_rwt_target_name();
  if (rwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_target_name_ = new ::std::string;
  }
  rwt_target_name_->assign(value);
}
inline void RegularizeModelArgs::set_rwt_target_name(const char* value) {
  set_has_rwt_target_name();
  if (rwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_target_name_ = new ::std::string;
  }
  rwt_target_name_->assign(value);
}
inline void RegularizeModelArgs::set_rwt_target_name(const char* value, size_t size) {
  set_has_rwt_target_name();
  if (rwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_target_name_ = new ::std::string;
  }
  rwt_target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizeModelArgs::mutable_rwt_target_name() {
  set_has_rwt_target_name();
  if (rwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_target_name_ = new ::std::string;
  }
  return rwt_target_name_;
}
inline ::std::string* RegularizeModelArgs::release_rwt_target_name() {
  clear_has_rwt_target_name();
  if (rwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = rwt_target_name_;
    rwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizeModelArgs::set_allocated_rwt_target_name(::std::string* rwt_target_name) {
  if (rwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete rwt_target_name_;
  }
  if (rwt_target_name) {
    set_has_rwt_target_name();
    rwt_target_name_ = rwt_target_name;
  } else {
    clear_has_rwt_target_name();
    rwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string pwt_source_name = 2;
inline bool RegularizeModelArgs::has_pwt_source_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularizeModelArgs::set_has_pwt_source_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularizeModelArgs::clear_has_pwt_source_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularizeModelArgs::clear_pwt_source_name() {
  if (pwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_->clear();
  }
  clear_has_pwt_source_name();
}
inline const ::std::string& RegularizeModelArgs::pwt_source_name() const {
  return *pwt_source_name_;
}
inline void RegularizeModelArgs::set_pwt_source_name(const ::std::string& value) {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  pwt_source_name_->assign(value);
}
inline void RegularizeModelArgs::set_pwt_source_name(const char* value) {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  pwt_source_name_->assign(value);
}
inline void RegularizeModelArgs::set_pwt_source_name(const char* value, size_t size) {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  pwt_source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizeModelArgs::mutable_pwt_source_name() {
  set_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_source_name_ = new ::std::string;
  }
  return pwt_source_name_;
}
inline ::std::string* RegularizeModelArgs::release_pwt_source_name() {
  clear_has_pwt_source_name();
  if (pwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = pwt_source_name_;
    pwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizeModelArgs::set_allocated_pwt_source_name(::std::string* pwt_source_name) {
  if (pwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete pwt_source_name_;
  }
  if (pwt_source_name) {
    set_has_pwt_source_name();
    pwt_source_name_ = pwt_source_name;
  } else {
    clear_has_pwt_source_name();
    pwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string nwt_source_name = 3;
inline bool RegularizeModelArgs::has_nwt_source_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularizeModelArgs::set_has_nwt_source_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularizeModelArgs::clear_has_nwt_source_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularizeModelArgs::clear_nwt_source_name() {
  if (nwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_->clear();
  }
  clear_has_nwt_source_name();
}
inline const ::std::string& RegularizeModelArgs::nwt_source_name() const {
  return *nwt_source_name_;
}
inline void RegularizeModelArgs::set_nwt_source_name(const ::std::string& value) {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  nwt_source_name_->assign(value);
}
inline void RegularizeModelArgs::set_nwt_source_name(const char* value) {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  nwt_source_name_->assign(value);
}
inline void RegularizeModelArgs::set_nwt_source_name(const char* value, size_t size) {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  nwt_source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegularizeModelArgs::mutable_nwt_source_name() {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  return nwt_source_name_;
}
inline ::std::string* RegularizeModelArgs::release_nwt_source_name() {
  clear_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = nwt_source_name_;
    nwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RegularizeModelArgs::set_allocated_nwt_source_name(::std::string* nwt_source_name) {
  if (nwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete nwt_source_name_;
  }
  if (nwt_source_name) {
    set_has_nwt_source_name();
    nwt_source_name_ = nwt_source_name;
  } else {
    clear_has_nwt_source_name();
    nwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .artm.RegularizerSettings regularizer_settings = 4;
inline int RegularizeModelArgs::regularizer_settings_size() const {
  return regularizer_settings_.size();
}
inline void RegularizeModelArgs::clear_regularizer_settings() {
  regularizer_settings_.Clear();
}
inline const ::artm::RegularizerSettings& RegularizeModelArgs::regularizer_settings(int index) const {
  return regularizer_settings_.Get(index);
}
inline ::artm::RegularizerSettings* RegularizeModelArgs::mutable_regularizer_settings(int index) {
  return regularizer_settings_.Mutable(index);
}
inline ::artm::RegularizerSettings* RegularizeModelArgs::add_regularizer_settings() {
  return regularizer_settings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >&
RegularizeModelArgs::regularizer_settings() const {
  return regularizer_settings_;
}
inline ::google::protobuf::RepeatedPtrField< ::artm::RegularizerSettings >*
RegularizeModelArgs::mutable_regularizer_settings() {
  return &regularizer_settings_;
}

// -------------------------------------------------------------------

// NormalizeModelArgs

// optional string pwt_target_name = 1;
inline bool NormalizeModelArgs::has_pwt_target_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalizeModelArgs::set_has_pwt_target_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalizeModelArgs::clear_has_pwt_target_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalizeModelArgs::clear_pwt_target_name() {
  if (pwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    pwt_target_name_->clear();
  }
  clear_has_pwt_target_name();
}
inline const ::std::string& NormalizeModelArgs::pwt_target_name() const {
  return *pwt_target_name_;
}
inline void NormalizeModelArgs::set_pwt_target_name(const ::std::string& value) {
  set_has_pwt_target_name();
  if (pwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_target_name_ = new ::std::string;
  }
  pwt_target_name_->assign(value);
}
inline void NormalizeModelArgs::set_pwt_target_name(const char* value) {
  set_has_pwt_target_name();
  if (pwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_target_name_ = new ::std::string;
  }
  pwt_target_name_->assign(value);
}
inline void NormalizeModelArgs::set_pwt_target_name(const char* value, size_t size) {
  set_has_pwt_target_name();
  if (pwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_target_name_ = new ::std::string;
  }
  pwt_target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalizeModelArgs::mutable_pwt_target_name() {
  set_has_pwt_target_name();
  if (pwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    pwt_target_name_ = new ::std::string;
  }
  return pwt_target_name_;
}
inline ::std::string* NormalizeModelArgs::release_pwt_target_name() {
  clear_has_pwt_target_name();
  if (pwt_target_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = pwt_target_name_;
    pwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NormalizeModelArgs::set_allocated_pwt_target_name(::std::string* pwt_target_name) {
  if (pwt_target_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete pwt_target_name_;
  }
  if (pwt_target_name) {
    set_has_pwt_target_name();
    pwt_target_name_ = pwt_target_name;
  } else {
    clear_has_pwt_target_name();
    pwt_target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string nwt_source_name = 2;
inline bool NormalizeModelArgs::has_nwt_source_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalizeModelArgs::set_has_nwt_source_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalizeModelArgs::clear_has_nwt_source_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalizeModelArgs::clear_nwt_source_name() {
  if (nwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_->clear();
  }
  clear_has_nwt_source_name();
}
inline const ::std::string& NormalizeModelArgs::nwt_source_name() const {
  return *nwt_source_name_;
}
inline void NormalizeModelArgs::set_nwt_source_name(const ::std::string& value) {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  nwt_source_name_->assign(value);
}
inline void NormalizeModelArgs::set_nwt_source_name(const char* value) {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  nwt_source_name_->assign(value);
}
inline void NormalizeModelArgs::set_nwt_source_name(const char* value, size_t size) {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  nwt_source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalizeModelArgs::mutable_nwt_source_name() {
  set_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    nwt_source_name_ = new ::std::string;
  }
  return nwt_source_name_;
}
inline ::std::string* NormalizeModelArgs::release_nwt_source_name() {
  clear_has_nwt_source_name();
  if (nwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = nwt_source_name_;
    nwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NormalizeModelArgs::set_allocated_nwt_source_name(::std::string* nwt_source_name) {
  if (nwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete nwt_source_name_;
  }
  if (nwt_source_name) {
    set_has_nwt_source_name();
    nwt_source_name_ = nwt_source_name;
  } else {
    clear_has_nwt_source_name();
    nwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string rwt_source_name = 3;
inline bool NormalizeModelArgs::has_rwt_source_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalizeModelArgs::set_has_rwt_source_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NormalizeModelArgs::clear_has_rwt_source_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NormalizeModelArgs::clear_rwt_source_name() {
  if (rwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    rwt_source_name_->clear();
  }
  clear_has_rwt_source_name();
}
inline const ::std::string& NormalizeModelArgs::rwt_source_name() const {
  return *rwt_source_name_;
}
inline void NormalizeModelArgs::set_rwt_source_name(const ::std::string& value) {
  set_has_rwt_source_name();
  if (rwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_source_name_ = new ::std::string;
  }
  rwt_source_name_->assign(value);
}
inline void NormalizeModelArgs::set_rwt_source_name(const char* value) {
  set_has_rwt_source_name();
  if (rwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_source_name_ = new ::std::string;
  }
  rwt_source_name_->assign(value);
}
inline void NormalizeModelArgs::set_rwt_source_name(const char* value, size_t size) {
  set_has_rwt_source_name();
  if (rwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_source_name_ = new ::std::string;
  }
  rwt_source_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalizeModelArgs::mutable_rwt_source_name() {
  set_has_rwt_source_name();
  if (rwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    rwt_source_name_ = new ::std::string;
  }
  return rwt_source_name_;
}
inline ::std::string* NormalizeModelArgs::release_rwt_source_name() {
  clear_has_rwt_source_name();
  if (rwt_source_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = rwt_source_name_;
    rwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NormalizeModelArgs::set_allocated_rwt_source_name(::std::string* rwt_source_name) {
  if (rwt_source_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete rwt_source_name_;
  }
  if (rwt_source_name) {
    set_has_rwt_source_name();
    rwt_source_name_ = rwt_source_name;
  } else {
    clear_has_rwt_source_name();
    rwt_source_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace artm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::Stream_Type>() {
  return ::artm::Stream_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::RegularizerConfig_Type>() {
  return ::artm::RegularizerConfig_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::SpecifiedSparsePhiConfig_Mode>() {
  return ::artm::SpecifiedSparsePhiConfig_Mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::RegularizerInternalState_Type>() {
  return ::artm::RegularizerInternalState_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::ScoreConfig_Type>() {
  return ::artm::ScoreConfig_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::ScoreData_Type>() {
  return ::artm::ScoreData_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::PerplexityScoreConfig_Type>() {
  return ::artm::PerplexityScoreConfig_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::TopicModel_OperationType>() {
  return ::artm::TopicModel_OperationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::CollectionParserConfig_Format>() {
  return ::artm::CollectionParserConfig_Format_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::InitializeModelArgs_SourceType>() {
  return ::artm::InitializeModelArgs_SourceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::GetTopicModelArgs_RequestType>() {
  return ::artm::GetTopicModelArgs_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::artm::ProcessBatchesArgs_ThetaMatrixType>() {
  return ::artm::ProcessBatchesArgs_ThetaMatrixType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_artm_2fmessages_2eproto__INCLUDED
